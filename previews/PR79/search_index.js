var documenterSearchIndex = {"docs":
[{"location":"examples/wkb_mountain_wave_simulation/#WKB-mountain-wave-simulation","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"","category":"section"},{"location":"examples/wkb_mountain_wave_simulation/#Simulation","page":"WKB mountain-wave simulation","title":"Simulation","text":"","category":"section"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"The script","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"# examples/submit/wkb_mountain_wave.jl\n\nusing PinCFlow\n\n@ivy if length(ARGS) == 0\n    output_file = \"./pincflow_output.h5\"\nelseif length(ARGS) == 1\n    output_file = ARGS[1] * \"/pincflow_output.h5\"\nelse\n    error(\"Too many arguments to the script!\")\nend\n\natmosphere = AtmosphereNamelist(; backgroundflow_dim = (1.0E+1, 0.0E+0, 0.0E+0))\ndomain = DomainNamelist(;\n    sizex = 40,\n    sizey = 40,\n    sizez = 40,\n    nbx = 3,\n    nby = 3,\n    nbz = 3,\n    lx_dim = 4.0E+5,\n    ly_dim = 4.0E+5,\n    lz_dim = 2.0E+4,\n    npx = 8,\n    npy = 8,\n)\ngrid = GridNamelist(;\n    mountainheight_dim = 1.5E+2,\n    mountainwidth_dim = 5.0E+3,\n    mountain_case = 13,\n    height_factor = 2.0E+0,\n    width_factor = 1.0E+1,\n)\noutput = OutputNamelist(; output_variables = (:w,), output_file = output_file)\nsetting = SettingNamelist(; testcase = WKBMountainWave())\nsponge = SpongeNamelist(;\n    spongelayer = true,\n    spongeheight = 1.0E-1,\n    alpharmax = 1.79E-2,\n    betarmax = 0.0E+0,\n    lateralsponge = true,\n    spongetype = ExponentialSponge(),\n    relax_to_mean = false,\n    relaxation_wind = (1.0E+1, 0.0E+0, 0.0E+0),\n)\nwkb = WKBNamelist(;\n    xrmin_dim = -2.0E+5,\n    xrmax_dim = 2.0E+5,\n    yrmin_dim = -2.0E+5,\n    yrmax_dim = 2.0E+5,\n    zrmin_dim = 0.0,\n    zrmax_dim = 2.0E+4,\n)\n\nintegrate(Namelists(; atmosphere, domain, grid, output, setting, sponge, wkb))\n","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"performs a 3D WKB mountain-wave simulation with parallelization in the zonal and meridional dimensions, and writes the vertical wind to pincflow_output.h5, if executed with","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"mpiexec=$(julia --project -e 'using MPICH_jll; println(MPICH_jll.mpiexec_path)')\n${mpiexec} -n 64 julia --project examples/submit/wkb_mountain_wave.jl","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"from the root directory of the repository (provided MPI.jl and HDF5.jl are configured to use their default backends). The full surface topography is given by","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"beginalign*\n    h left(x yright)  = begincases\n        frach_02 left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right leftr_h + cos left(fracpi xl_0right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\nendalign*","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"where h_0 = 150  mathrmm, l_0 = 5  mathrmkm, r_h = 2, and r_l = 10. This is decomposed into a large-scale part h_mathrmb and a small-scale part with the spectral amplitude h_mathrmw, such that","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"beginalign*\n    h_mathrmb left(x yright)  = r_h h_mathrmw left(x yright)\n    h_mathrmw left(x yright)  = begincases\n        frach_02 left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\nendalign*","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"The large-scale part is resolved, so that the grid is defined from it, whereas the small-scale part is used by MSGWaM to parameterize the mountain waves generated by the resolved wind crossing it. A visualization of this decomposition is shown below. As in the first mountain-wave example, the atmosphere is isothermal, with the default temperature T_0 = 300  mathrmK and the initial wind boldsymbolu_0 = left(10 0 0right)^mathrmT  mathrmm  s^- 1.","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"(Image: )","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"The damping coefficient of the sponge is given by","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"alpha_mathrmR left(x y zright) = fracalpha_mathrmR max3 leftexp left(fracleftxright - L_x  2Delta x_mathrmRright) + exp left(fracleftyright - L_y  2Delta y_mathrmRright) + exp left(fracz - L_zDelta z_mathrmRright)right","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"where alpha_mathrmR max = 00179  mathrms^- 1, Delta x_mathrmR = L_x  20, Delta y_mathrmR = L_y  20 and Delta z_mathrmR = L_z  10. In contrast to the sinusoidal sponge discussed in the first example, this sponge applies a damping everywhere in the domain (weakest at the center of the surface, strongest in the upper corners). Once again, the sponge relaxes the wind to its initial state.","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"MSGWaM is used with most of its parameters set to their default values. This means that the orographic source launches exactly one ray volume in each surface grid cell with a nonzero h_mathrmw. Thus, the number of ray volumes allowed per grid cell (before merging is triggered) is nray_fac (a parameter of the WKB namelist) cubed, which is 4^3 = 64.","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/#Visualization","page":"WKB mountain-wave simulation","title":"Visualization","text":"","category":"section"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"The script","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"# examples/visualization/wkb_mountain_wave.jl\n\nusing HDF5\nusing PythonPlot\nusing LaTeXStrings\nusing PinCFlow\n\nset_plot_style()\n\ninclude(\"style.jl\")\n\n# Import the data.\n@ivy if length(ARGS) == 0\n    data = h5open(\"./pincflow_output.h5\")\nelseif length(ARGS) == 1\n    data = h5open(ARGS[1] * \"/pincflow_output.h5\")\nelse\n    error(\"Too many arguments to the script!\")\nend\n\n# Set the grid.\nx = data[\"x\"][:] ./ 1000\ny = data[\"y\"][:] ./ 1000\nz = data[\"z\"][:, :, :] ./ 1000\nx = [xi for xi in x, j in 1:size(z)[2], k in 1:size(z)[3]]\ny = [yj for i in 1:size(z)[1], yj in y, k in 1:size(z)[3]]\n\n# Get the vertical wind.\nw = data[\"w\"][:, :, :, end]\n\n# Close the file.\nclose(data)\n\n# Create the figure.\nfigure(; figsize = (12, 3))\n\n# Plot in x-y plane.\nk = 10\nsubplot(131)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[:, :, k]), maximum(w[:, :, k]))\n@ivy contours = contourf(\n    x[:, :, k],\n    y[:, :, k],\n    w[:, :, k];\n    levels = levels,\n    cmap = colormap,\n)\nxlabel(L\"x\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"y\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"z\\approx 5\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Plot in x-z plane.\nj = 20\nsubplot(132)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[:, j, :]), maximum(w[:, j, :]))\n@ivy contours = contourf(\n    x[:, j, :],\n    z[:, j, :],\n    w[:, j, :];\n    levels = levels,\n    cmap = colormap,\n)\n@ivy plot(x[:, j, 1], z[:, j, 1]; color = \"black\", linewidth = 0.5)\nxlabel(L\"x\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"z\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"y\\approx 0\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Plot in y-z plane.\ni = 20\nsubplot(133)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[i, :, :]), maximum(w[i, :, :]))\n@ivy contours = contourf(\n    y[i, :, :],\n    z[i, :, :],\n    w[i, :, :];\n    levels = levels,\n    cmap = colormap,\n)\n@ivy plot(y[i, :, 1], z[i, :, 1]; color = \"black\", linewidth = 0.5)\nxlabel(L\"y\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"z\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"x\\approx 0\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Save the figure.\nsavefig(\"examples/results/wkb_mountain_wave.png\")\nclf()\n","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"visualizes the vertical wind at the end of the above simulation (i.e. after one hour) in three cross sections of the domain and saves the generated figure to a PNG file that is included below. Note that symmetric_contours returns a cropped colormap that is centered at w = 0  mathrmm  s^- 1.","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"(Image: )","category":"page"},{"location":"examples/wkb_mountain_wave_simulation/#See-also","page":"WKB mountain-wave simulation","title":"See also","text":"","category":"section"},{"location":"examples/wkb_mountain_wave_simulation/","page":"WKB mountain-wave simulation","title":"WKB mountain-wave simulation","text":"PinCFlow.Types.NamelistTypes.AtmosphereNamelist\nPinCFlow.Types.NamelistTypes.GridNamelist\nPinCFlow.Types.NamelistTypes.SpongeNamelist\nPinCFlow.Types.NamelistTypes.WKBNamelist\nPinCFlow.Types.FoundationalTypes.compute_topography\nPinCFlow.Types.FoundationalTypes.Sponge\nPinCFlow.Types.WKBTypes.WKB\nPinCFlow.Update.compute_sponges!\nPinCFlow.Update.apply_lhs_sponge!\nPinCFlow.MSGWaM.RaySources.activate_orographic_source!\nPinCFlow.set_plot_style\nPinCFlow.symmetric_contours","category":"page"},{"location":"reference/update/#Update","page":"Update","title":"Update","text":"","category":"section"},{"location":"reference/update/#PinCFlow.Update","page":"Update","title":"PinCFlow.Update","text":"Update\n\nModule for integrating the prognostic equations.\n\nProvides functions for updating the prognostic variables at the various stages of the semi-implicit time scheme.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\n\n\n\n\n\n","category":"module"},{"location":"reference/update/#PinCFlow.Update.Cartesian","page":"Update","title":"PinCFlow.Update.Cartesian","text":"Cartesian\n\nSingleton for transformations from the terrain-following system to the Cartesian one.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.LHS","page":"Update","title":"PinCFlow.Update.LHS","text":"LHS\n\nSingleton for the integration of the left-hand side of an equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.RHS","page":"Update","title":"PinCFlow.Update.RHS","text":"RHS\n\nSingleton for the integration of the right-hand side of an equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Transformed","page":"Update","title":"PinCFlow.Update.Transformed","text":"Transformed\n\nSingleton for transformations from the Cartesian system to the terrain-following one.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.X","page":"Update","title":"PinCFlow.Update.X","text":"X\n\nSingleton for widehatx-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Y","page":"Update","title":"PinCFlow.Update.Y","text":"Y\n\nSingleton for widehaty-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Z","page":"Update","title":"PinCFlow.Update.Z","text":"Z\n\nSingleton for widehatz-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.apply_lhs_sponge!","page":"Update","title":"PinCFlow.Update.apply_lhs_sponge!","text":"apply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::AbstractVariable,\n)\n\nPerform an implicit substep to integrate the Rayleigh-damping term that represents the LHS sponge in the prognostic equation for variable by dispatching to the appropriate model-specific method.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::Rho,\n    model::Boussinesq,\n)\n\nReturn in Boussinesq mode (constant density).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::Rho,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the continuity equation.\n\nThe update is given by\n\nrho rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 left(rho + alpha_mathrmR Delta t overlinerhoright)\n\nwhere alpha_mathrmR is the Rayleigh-damping coefficient computed by PinCFlow.Update.compute_sponges! and Delta t is the time step given as input to this method.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::RhoP,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the auxiliary equation.\n\nThe update is given by\n\nrho rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 leftrho + alpha_mathrmR Delta t overlinerho left(1 - fracPrho overlinethetaright)right\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::U,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the zonal-momentum equation.\n\nThe update is given by\n\nu_i + 1  2 rightarrow left(1 + alpha_mathrmR i + 1  2 Delta tright)^- 1 leftu_i + 1  2 + alpha_mathrmR i + 1  2 Delta t u_mathrmr left1 + a_mathrmr sin left(frac2 pi tt_mathrmrright)rightright\n\nIf state.namelists.sponge.relax_to_mean is false, u_mathrmr, a_mathrmr and t_mathrmr are given by the sponge-namelist parameters relaxation_wind[1], perturbation_amplitude and perturbation_period, respectively. Otherwise, u_mathrmr is the average of u_i + 1  2 across the terrain-following coordinate surface and a_mathrmr = 0.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::V,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the meridional-momentum equation.\n\nThe update is given by\n\nv_j + 1  2 rightarrow left(1 + alpha_mathrmR j + 1  2 Delta tright)^- 1 leftv_j + 1  2 + alpha_mathrmR j + 1  2 Delta t v_mathrmr left1 + a_mathrmr sin left(frac2 pi tt_mathrmrright)rightright\n\nThe computation of the relaxation wind is analogous to that in the method for the zonal momentum, with v_mathrmr given by state.namelists.sponge.relaxation_wind[2].\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::W,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the transformed-vertical-momentum equation.\n\nThe update is given by\n\nwidehatw_k + 1  2 rightarrow left(1 + alpha_mathrmR k + 1  2 Delta tright)^- 1 leftwidehatw_k + 1  2 + alpha_mathrmR k + 1  2 Delta t widehatw_mathrmr left1 + a_mathrmr sin left(frac2 pi tt_mathrmrright)rightright\n\nThe computation of the relaxation wind is analogous to that in the methods for the zonal and meridional momenta, with widehatw_mathrmr given by state.namelists.sponge.relaxation_wind[3].\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::PiP,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes (Exner-pressure fluctuations are only updated in the corrector step).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::PiP,\n    model::Compressible,\n)\n\nUpdate the Exner-pressure fluctuations to account for the Rayleigh damping applied to the mass-weighted potential temperature.\n\nThe update is given by\n\npi rightarrow pi - alpha_mathrmR Delta t P fracpartial pipartial P left(1 - fracoverlinerhorhoright)\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::P,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes (mass-weighted potential temperature is constant in time).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::P,\n    model::Compressible,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the thermodynamic-energy equation.\n\nThe update is given by\n\nP rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 P left(1 + alpha_mathrmR Delta t fracoverlinerhorhoright)\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    tracersetup::AbstractTracer,\n)\n\nIntegrate the Rayleigh-damping terms that represent the LHS sponge in the tracer equations.\n\nIn each tracer equation, the update is given by\n\nchi rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 left(chi + alpha_mathrmR Delta t chi_0right)\n\nwhere chi_0 is the initial distribution of the tracer.\n\nArguments\n\nstate: Model state.\ndt: Time step.\ntime: Simulation time.\nvariable: Variable to apply Rayleigh damping to.\nmodel: Dynamic equations.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_buoyancy_factor","page":"Update","title":"PinCFlow.Update.compute_buoyancy_factor","text":"compute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::AbstractVariable,\n)::AbstractFloat\n\nCompute the factor by which the buoyancy term should be multiplied at left(i j kright) or left(i j k + 1  2right), by dispatching to a method specific for the dynamic equations and variable, and return the result.\n\nIn pseudo-incompressible mode, rho are deviations of the total density from overlinerho, which describes the reference atmosphere. However, in compressible mode, rho = rho - P  overlinetheta does not reduce to this, i.e. the density background has a spatiotemporal dependence. As a consequence, the right-hand side of the prognostic equation for rho is given by\n\nleft(fracpartial rhopartial tright)_N^2 = f_rho fracN^2 rho wg\n\nwith f_rho = overlinerho  rho in pseudo-incompressible mode and f_rho = P  left(rho overlinethetaright) in compressible mode. This method returns either f_rho at left(i j kright) or f_w, which is the interpolation of f_rho to left(i j k + 1  2right), based on the type of variable.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::RhoP,\n    model::Compressible,\n)::AbstractFloat\n\nReturn f_rho = P  left(rho overlinethetaright) as the factor by which the buoyancy term should be multiplied at left(i j kright) in compressible mode.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::RhoP,\n    model::AbstractModel,\n)::AbstractFloat\n\nReturn f_rho = overlinerho  rho as the factor by which the buoyancy term should be multiplied at left(i j kright) in pseudo-incompressible mode (this method is also used in Boussinesq mode).\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::Compressible,\n)::AbstractFloat\n\nReturn f_w = left(P  overlinethetaright)_k + 1  2  rho_k + 1  2 as the factor by which the buoyancy term should be multiplied in compressible mode.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::AbstractModel,\n)::AbstractFloat\n\nReturn f_w = overlinerho_k + 1  2  rho_k + 1  2 as the factor by which the buoyancy term should be multiplied at left(i j k + 1  2right) in pseudo-incompressible mode (this method is also used in Boussinesq mode).\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable for which the factor is needed.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_compressible_wind_factor","page":"Update","title":"PinCFlow.Update.compute_compressible_wind_factor","text":"compute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::AbstractVariable,\n)::AbstractFloat\n\nCompute the factor by which the wind should be multiplied at left(i + 1  2 j kright), left(i j + 1  2 kright) or left(i j k + 1  2right), by dispatching to a method specific for the dynamic equations and the component indicated by variable, and return the result.\n\nIn compressible mode, the Euler steps that are used to integrate the right-hand side of the momentum equation update left(J Pright)_i + 1  2 u_i + 1  2, left(J Pright)_j + 1  2 v_j + 1  2 and left(J Pright)_k + 1  2 widehatw_k + 1  2 instead of u_i + 1  2, v_j + 1  2 and widehatw_k + 1  2.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::AbstractVariable,\n    model::AbstractModel,\n)::AbstractFloat\n\nReturn 1 as the factor by which the wind should be multiplied in non-compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_i + 1  2 as the factor by which the zonal wind should be multiplied in compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_j + 1  2 as the factor by which the meridional wind should be multiplied in compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_k + 1  2 as the factor by which the transformed vertical wind should be multiplied in compressible mode.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable for which the factor is needed.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_momentum_diffusion_terms","page":"Update","title":"PinCFlow.Update.compute_momentum_diffusion_terms","text":"compute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehatx-direction, i.e.\n\nXi^u_widehatx = fracu_i+12 - u_i-12Delta widehatx + G^13fracu_k+1 - u_k-12Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehaty-direction, i.e.\n\nXi^u_widehaty = fracu_j+1-u_j-12Delta widehaty + G^23fracu_k+1-u_k-12Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehatz-direction, i.e.\n\nXi^u_widehatz = G^13fracu_i+12-u_i-12Delta widehatx + G^23fracu_j+1-u_j-12 Delta widehaty + G^33fracu_k+1-u_k-12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehatx-direction, i.e.\n\nXi^v_widehatx = fracv_i+1 - v_i-12 Delta widehatx + G^13fracv_k+1-v_k-12Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehaty-direction, i.e.\n\nXi^v_widehaty = fracv_j+12 - v_j-12Delta widehaty + G^23fracv_k+1-v_k-12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehatz-direction, i.e.\n\nXi^v_widehatz = G^13fracv_i+1 - v_i-12Deltawidehatx + G^23fracv_j+12-v_j-12Delta widehaty + G^33fracv_k+1-v_k-12Deltawidehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehatx-direction, i.e.\n\nXi^widehatw_widehatx = fracwidehatw_i+1 - widehatw_i-12Deltawidehatx + G^13fracw_k+12-w_k-12Deltawidehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehaty-direction, i.e.\n\nXi^widehatw_widehaty = fracwidehatw_j+1-widehatw_j-12Deltawidehaty + G^23fracw_k+12-w_k-12Deltawidehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehatz-direction, i.e.\n\nXi^widehatw_widehatz = G^13fracwidehatw_i+1-widehatw_i-12Deltawidehatx + G^23fracwidehatw_j+1-widehatw_j-12Deltawidehaty + G^33fracw_k+12-w_k-12Deltawidehatz\n\nArguments\n\nstate: Model state.\ni: Grid-cell index on the widehatx-axis.\nj: Grid-cell index on the widehaty-axis.\nk: Grid-cell index on the widehatz-axis.\nvariable: Wind direction.\ndirection: Direction of the flux.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_pressure_gradient","page":"Update","title":"PinCFlow.Update.compute_pressure_gradient","text":"compute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n)::AbstractFloat\n\nCompute and return the pressure(-difference)-gradient term in the zonal-wind equation at left(i + 1  2 j kright), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nmathcalP^u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 fracpi_i + 1  2 k + 1 - pi_i + 1  2 k - 12 Delta widehatz\n\nSince the Exner-pressure is not known in the vertical ghost cells, a different discretization is needed at the vertical boundaries. At k = k_0 (in the first process in widehatz), the alternative second-order-accurate approximation\n\nmathcalP^u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 frac- pi_i + 1  2 k + 2 + 4 pi_i + 1  2 k + 1 - 3 pi_i + 1  22 Delta widehatz\n\nis used and, in a similar manner, one has\n\nmathcalP^u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 fracpi_i + 1  2 k - 2 - 4 pi_i + 1  2 k - 1 + 3 pi_i + 1  22 Delta widehatz\n\nat k = k_1 (in the last process in widehatz). The corresponding pressure-difference-gradient component mathcalD^u_i + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_i + 1  2  rho_i + 1  2right).\n\ncompute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n)::AbstractFloat\n\nCompute and return the pressure-gradient term in the meridional-wind equation at left(i j + 1  2 kright), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nmathcalP^v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 fracpi_j + 1  2 k + 1 - pi_j + 1  2 k - 12 Delta widehatz\n\nAnalogous to the component in the zonal-wind equation, one has\n\nmathcalP^v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 frac- pi_j + 1  2 k + 2 + 4 pi_j + 1  2 k + 1 - 3 pi_j + 1  22 Delta widehatz\n\nat k = k_0 (in the first process in widehatz) and\n\nmathcalP^v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 fracpi_j + 1  2 k - 2 - 4 pi_j + 1  2 k - 1 + 3 pi_j + 1  22 Delta widehatz\n\nat k = k_1 (in the last process in widehatz). The corresponding pressure-difference-gradient component mathcalD^v_j + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_j + 1  2  rho_j + 1  2right).\n\ncompute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n)::AbstractFloat\n\nCompute and return the pressure(-difference)-gradient term in the transformed-vertical-wind equation at left(i j k + 1  2right), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nbeginalign*\n    mathcalP^widehatw_k + 1  2  = G^13_k + 1  2 fracpi_i + 1 k + 1  2 - pi_i - 1 k + 1  22 Delta widehatx + G^23_k + 1  2 fracpi_j + 1 k + 1  2 - pi_j - 1 k + 1  22 Delta widehaty\n     quad + G^33_k + 1  2 fracpi_k + 1 - piDelta widehatz\n endalign*\n\nAt k = k_0 - 1 (in the first process in widehatz) and k = k_1 (in the last process in widehatz), it is set to zero. The corresponding pressure-difference-gradient component mathcalD^widehatw_k + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_k + 1  2  rho_k + 1  2right).\n\nArguments\n\nstate: Model state.\npip: Pressure field.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Equation in which the respective pressure-gradient component is needed.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_sponges!","page":"Update","title":"PinCFlow.Update.compute_sponges!","text":"compute_sponges!(state::State, dt::AbstractFloat)\n\nCompute the Rayleigh-damping coefficients of the two sponges.\n\nThis method directly computes the Rayleigh-damping coefficients\n\nbeta_mathrmR^uv = beta_mathrmR^widehatw left(zright) = begincases\n    fracbeta_mathrmR maxDelta t sin^2 leftfracpi left(z - z_mathrmRright)2 left(L_z - z_mathrmRright)right  mathrmif quad z geq z_mathrmR\n    0  mathrmelse\nendcases\n\nwhere beta_mathrmR max and z_mathrmR are given by state.namelists.sponge.betarmax and state.sponge.zsponge, respectively. These coefficients are only used in the prognostic equations for the horizontal wind (beta_mathrmR^uv, only if state.namelists.sponge.sponge_uv is true) and the transformed vertical wind (beta_mathrmR^widehatw). The corresponding damping terms are integrated on the right-hand sides.\n\nThis method also dispatches to a specific method that computes the Rayleigh damping coefficient of the RHS sponge defined for state.namelists.sponge.spongetype.\n\ncompute_sponges!(state::State, dt::AbstractFloat, spongetype::ExponentialSponge)\n\nCompute the Rayleigh-damping coefficient of an exponential sponge.\n\nIf state.namelists.sponge.lateralsponge is true, the Rayleigh-damping coefficient is\n\nalpha_mathrmR left(x y zright) = fracalpha_mathrmR max3 leftexp left(fracleftxright - L_x  2Delta x_mathrmRright) + exp left(fracleftyright - L_y  2Delta y_mathrmRright) + exp left(fracz - L_zDelta z_mathrmRright)right\n\nand otherwise, it is\n\nalpha_mathrmR left(zright) = alpha_mathrmR max leftexp left(fracz - L_zDelta z_mathrmRright)right\n\nwhere alpha_mathrmR max, Delta x_mathrmR, Delta y_mathrmR and Delta z_mathrmR are given by state.namelists.sponge.alpharmax, state.sponge.dxsponge, state.sponge.dysponge and state.sponge.dzsponge, respectively. If the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.\n\ncompute_sponges!(state::State, dt::AbstractFloat, spongetype::COSMOSponge)\n\nCompute the Rayleigh-damping coefficient of a sponge similar to that used by the COSMO model.\n\nIf state.namelists.sponge.lateralsponge is true, the Rayleigh-damping coefficient is\n\nalpha_mathrmR left(x y zright) = alpha_mathrmR x left(xright) + alpha_mathrmR y left(yright) + alpha_mathrmR z left(zright)\n\nwith\n\nbeginalign*\n    alpha_mathrmR x left(xright)  = begincases\n        left(2 N_mathrmR Delta tright)^- 1 left1 - cos leftfracpi left(x_mathrmR 0 - xright)Delta x_mathrmRrightright  mathrmif quad x leq x_mathrmR 0\n        left(2 N_mathrmR Delta tright)^- 1 left1 - cos leftfracpi left(x - x_mathrmR 1right)Delta x_mathrmRrightright  mathrmif quad x geq x_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR y left(yright)  = begincases\n        left(2 N_mathrmR Delta tright)^- 1 left1 - cos leftfracpi left(y_mathrmR 0 - yright)Delta y_mathrmRrightright  mathrmif quad y leq y_mathrmR 0\n        left(2 N_mathrmR Delta tright)^- 1 left1 - cos leftfracpi left(y - y_mathrmR 1right)Delta y_mathrmRrightright  mathrmif quad y geq y_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR z left(zright)  = begincases\n        left(2 N_mathrmR Delta tright)^- 1 left1 - cos leftfracpi left(z - z_mathrmRright)Delta z_mathrmRrightright  mathrmif quad z geq z_mathrmR\n        0  mathrmelse\n    endcases\nendalign*\n\nand otherwise, it is\n\nalpha_mathrmR left(zright) = alpha_mathrmR z left(zright)\n\nwhere N_mathrmR, x_mathrmR 0, x_mathrmR 1, y_mathrmR 0, y_mathrmR 1, z_mathrmR 0 and z_mathrmR 1 are given by state.namelists.sponge.cosmosteps and the properties xsponge0, xsponge1, ysponge0, ysponge1, zsponge0 and zsponge1 of state.sponge, respectively.\n\ncompute_sponges!(state::State, dt::AbstractFloat, spongetype::PolynomialSponge)\n\nCompute the Rayleigh-damping coefficient of a polynomial sponge.\n\nIf state.namelists.sponge.lateralsponge is true, the Rayleigh-damping coefficient is\n\nalpha_mathrmR left(x y zright) = fracalpha_mathrmR x left(xright) + alpha_mathrmR y left(yright) + alpha_mathrmR z left(zright)3\n\nwith\n\nbeginalign*\n    alpha_mathrmR x left(xright)  = begincases\n        alpha_mathrmR max left(fracx_mathrmR 0 - xDelta x_mathrmRright)^n_mathrmR  mathrmif quad x leq x_mathrmR 0\n        alpha_mathrmR max left(fracx - x_mathrmR 1Delta x_mathrmRright)^n_mathrmR  mathrmif quad x geq x_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR y left(yright)  = begincases\n        alpha_mathrmR max left(fracy_mathrmR 0 - yDelta y_mathrmRright)^n_mathrmR  mathrmif quad y leq y_mathrmR 0\n        alpha_mathrmR max left(fracy - y_mathrmR 1Delta y_mathrmRright)^n_mathrmR  mathrmif quad y geq y_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR z left(zright)  = begincases\n        alpha_mathrmR max left(fracz - z_mathrmRDelta z_mathrmRright)^n_mathrmR  mathrmif quad z geq z_mathrmR\n        0  mathrmelse\n    endcases\nendalign*\n\nand otherwise, it is\n\nalpha_mathrmR left(zright) = alpha_mathrmR z left(zright)\n\nwhere n_mathrmR is given by state.namelists.sponge.spongeorder. If the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.\n\ncompute_sponges!(state::State, dt::AbstractFloat, spongetype::SinusoidalSponge)\n\nCompute the Rayleigh-damping coefficient of a sinusoidal sponge.\n\nIf state.namelists.sponge.lateralsponge is true, the Rayleigh-damping coefficient is\n\nalpha_mathrmR left(x y zright) = fracalpha_mathrmR x left(xright) + alpha_mathrmR y left(yright) + alpha_mathrmR z left(zright)3\n\nwith\n\nbeginalign*\n    alpha_mathrmR x left(xright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(x_mathrmR 0 - xright)2 Delta x_mathrmRright  mathrmif quad x leq x_mathrmR 0\n        alpha_mathrmR max sin^2 leftfracpi left(x - x_mathrmR 1right)2 Delta x_mathrmRright  mathrmif quad x geq x_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR y left(yright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(y_mathrmR 0 - yright)2 Delta y_mathrmRright  mathrmif quad y leq y_mathrmR 0\n        alpha_mathrmR max sin^2 leftfracpi left(y - y_mathrmR 1right)2 Delta y_mathrmRright  mathrmif quad y geq y_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR z left(zright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(z - z_mathrmRright)2 Delta z_mathrmRright  mathrmif quad z geq z_mathrmR\n        0  mathrmelse\n    endcases\nendalign*\n\nand otherwise, it is\n\nalpha_mathrmR left(zright) = alpha_mathrmR z left(zright)\n\nIf the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nspongetype: Specification of the spatial dependence of the  Rayleigh-damping coefficient.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_stress_tensor","page":"Update","title":"PinCFlow.Update.compute_stress_tensor","text":"compute_stress_tensor(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    mu::Integer,\n    nu::Integer,\n    state::State,\n)::AbstractFloat\n\nCompute and return the element left(mu nuright) of the Cartesian viscous stress tensor at the grid point left(i j kright), divided by the dynamic viscosity.\n\nThe discretized elements of the Cartesian viscous stress tensor are given by\n\nbeginalign*\n    Pi^1 1  = eta leftfrac2Delta widehatx left(u_i + 1  2 - u_i - 1  2right) + fracG^1 3Delta widehatz left(u_k + 1 - u_k - 1right) - frac23 deltaright\n    Pi^1 2  = eta leftfrac12 Delta widehaty left(u_j + 1 - u_j - 1right) + fracG^2 32 Delta widehatz left(u_k + 1 - u_k - 1right) + frac12 Delta widehatx left(v_i + 1 - v_i - 1right) + fracG^1 32 Delta widehatz left(v_k + 1 - v_k - 1right)right\n    Pi^1 3  = eta leftfrac12 J Delta widehatz left(u_k + 1 - u_k - 1right) + frac12 Delta widehatx left(w_i + 1 - w_i - 1right) + fracG^1 3Delta widehatz left(w_k + 1  2 - w_k - 1  2right)right\n    Pi^2 2  = eta leftfrac2Delta widehaty left(v_j + 1  2 - v_j - 1  2right) + fracG^2 3Delta widehatz left(v_k + 1 - v_k - 1right) - frac23 deltaright\n    Pi^2 3  = eta leftfrac12 J Delta widehatz left(v_k + 1 - v_k - 1right) + frac12 Delta widehaty left(w_j + 1 - w_j - 1right) + fracG^2 3Delta widehatz left(w_k + 1  2 - w_k - 1  2right)right\n    Pi^3 3  = eta leftfrac2J Delta widehatz left(w_k + 1  2 - w_k - 1  2right) - frac23 deltaright\nendalign*\n\nwhere\n\nbeginalign*\n    delta  = frac1J leftfrac1Delta widehatx left(J_i + 1  2 u_i + 1  2 - J_i - 1  2 u_i - 1  2right) + frac1Delta widehaty left(J_j + 1  2 v_j + 1  2 - J_j - 1  2 v_j - 1  2right)right\n     qquad quad + leftfrac1Delta widehatz left(J_k + 1  2 widehatw_k + 1  2 - J_k - 1  2 widehatw_k - 1  2right)right\nendalign*\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nmu: First contravariant tensor index.\nnu: Second contravariant tensor index.\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_vertical_wind","page":"Update","title":"PinCFlow.Update.compute_vertical_wind","text":"compute_vertical_wind(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    state::State,\n)::AbstractFloat\n\nCompute and return the Cartesian vertical wind at the grid point left(i j k + 1  2right).\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.transform\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_volume_force","page":"Update","title":"PinCFlow.Update.compute_volume_force","text":"compute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::AbstractVariable,\n)::AbstractFloat\n\nReturn the volume force in the equation specified by variable.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::AbstractVariable,\n    testcase::AbstractTestCase,\n)::AbstractFloat\n\nReturn 0 as the volume force in non-WKB test cases (for all variables except the mass-weighted potential temperature).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    testcase::AbstractWKBTestCase,\n)::AbstractFloat\n\nReturn the gravity-wave drag on the zonal momentum, interpolated to left(i + 1  2 j kright).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    testcase::AbstractWKBTestCase,\n)::AbstractFloat\n\nReturn the gravity-wave drag on the meridional momentum, interpolated to left(i j + 1  2 kright).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    testcase::AbstractWKBTestCase,\n)::AbstractFloat\n\nReturn the gravity-wave drag on the transformed vertical momentum, interpolated to left(i j k + 1  2right), as given by\n\nleft(fracpartial widehatwpartial tright)_mathrmw = leftG^1 3 left(fracpartial upartial tright)_mathrmwright_k + 1  2 + leftG^2 3 left(fracpartial vpartial tright)_mathrmwright_k + 1  2\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::P,\n    testcase::AbstractTestCase,\n)::AbstractFloat\n\nReturn the conductive heating.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::P,\n    testcase::AbstractWKBTestCase,\n)::AbstractFloat\n\nReturn the sum of gravity-wave impact on the mass-weighted potential temperature and conductive heating.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variables::Chi,\n    testcase::AbstractWKBTestCase,\n)::AbstractFloat\n\nReturn the tracer flux convergence due to gravity waves.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable (equation) of choice.\ntestcase: Test case on which the current simulation is based.\n\nSee also\n\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.conductive_heating","page":"Update","title":"PinCFlow.Update.conductive_heating","text":"conductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::AbstractFloat\n\nCompute and return the conductive heating by dispatching to specialized methods dependent on the model.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::Boussinesq,\n)::AbstractFloat\n\nReturn 0 as conductive heating in Boussinesq mode.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::PseudoIncompressible,\n)::AbstractFloat\n\nReturn 0 as conductive heating in PseudoIncompressible mode.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::Compressible,\n)::AbstractFloat\n\nCompute and return the conductive heating as the divergence of potential temperature fluxes.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.transform","page":"Update","title":"PinCFlow.Update.transform","text":"transform(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    uedger::AbstractFloat,\n    uuedger::AbstractFloat,\n    uedgel::AbstractFloat,\n    uuedgel::AbstractFloat,\n    vedgef::AbstractFloat,\n    vuedgef::AbstractFloat,\n    vedgeb::AbstractFloat,\n    vuedgeb::AbstractFloat,\n    wedgeu::AbstractFloat,\n    coordinate::Cartesian,\n    state::State,\n)::AbstractFloat\n\nPerform the transformation of a vertical-wind-like variable from the transformed system to the Cartesian one, given the wind-like components at the grid points surrounding left(i j k + 1  2right), and return the result.\n\nThe discretized transformation rule for the vertical wind is given by\n\nw_k + 1  2 = J_k + 1  2 left- left(G^1 3 uright)_k + 1  2 - left(G^2 3 vright)_k + 1  2 + widehatw_k + 1  2right\n\ntransform(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    uedger::AbstractFloat,\n    uuedger::AbstractFloat,\n    uedgel::AbstractFloat,\n    uuedgel::AbstractFloat,\n    vedgef::AbstractFloat,\n    vuedgef::AbstractFloat,\n    vedgeb::AbstractFloat,\n    vuedgeb::AbstractFloat,\n    wedgeu::AbstractFloat,\n    coordinate::Transformed,\n    state::State,\n)::AbstractFloat\n\nPerform the transformation of a vertical-wind-like variable from the Cartesian system to the transformed one, given the wind-like components at the grid points surrounding left(i j k + 1  2right), and return the result.\n\nThe discretized transformation rule for the vertical wind is given by\n\nwidehatw_k + 1  2 = left(G^1 3 uright)_k + 1  2 + left(G^2 3 vright)_k + 1  2 + fracw_k + 1  2J_k + 1  2\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nuedger: Zonal-wind equivalent at left(i + 1  2 j kright).\nuuedger: Zonal-wind equivalent at left(i + 1  2 j k + 1right).\nuedgel: Zonal-wind equivalent at left(i - 1  2 j kright).\nuuedgel: Zonal-wind equivalent at left(i - 1  2 j k + 1right).\nvedgef: Meridional-wind equivalent at left(i j + 1  2 kright).\nvuedgef: Meridional-wind equivalent at left(i j + 1  2 k + 1right).\nvedgeb: Meridional-wind equivalent at left(i j - 1  2 kright).\nvuedgeb: Meridional-wind equivalent at left(i j - 1  2 k + 1right).\nwedgeu: Transformed-vertical-wind equivalent at left(i j k + 1  2right)\ncoordinate: Coordinate system to transform to.\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.update!","page":"Update","title":"PinCFlow.Update.update!","text":"update!(state::State, dt::AbstractFloat, m::Integer, variable::Rho)\n\nUpdate the density if the atmosphere is not Boussinesq by dispatching to the appropriate method.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::Rho,\n    model::Boussinesq,\n)\n\nReturn in Boussinesq mode (the density is constant).\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::Rho,\n    model::AbstractModel,\n)\n\nUpdate the density with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::RhoP, side::LHS)\n\nUpdate the density fluctuations with a Runge-Kutta step on the left-hand-side of the equation.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the density fluctuations with an explicit Euler step the on right-hand side of the equation, without the Rayleigh-damping term.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the density fluctuations with an implicit Euler step on the right-hand side of the equation.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::U, side::LHS)\n\nUpdate the zonal momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the zonal wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the zonal wind with an implicit Euler step on the right-hand side of the equation.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::V, side::LHS)\n\nUpdate the meridional momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the meridional wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the meridional wind with an implicit Euler step on the right-hand side of the equation.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::W, side::LHS)\n\nUpdate the transformed vertical momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the transformed vertical wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the transformed vertical wind with an implicit Euler step on the right-hand side of the equation.\n\nupdate!(state::State, dt::AbstractFloat, variable::PiP)\n\nUpdate the Exner-pressure if the atmosphere is compressible by dispatching to the appropriate method.\n\nupdate!(state::State, dt::AbstractFloat, variable::PiP, model::AbstractModel)\n\nReturn in non-compressible modes.\n\nupdate!(state::State, dt::AbstractFloat, variable::PiP, model::Compressible)\n\nUpdate the Exner-pressure such that it is synchronized with the updated mass-weighted potential temperature.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::P)\n\nUpdate the mass-weighted potential temperature if the atmosphere is compressible by dispatching to the appropriate method.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::P,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::P,\n    model::Compressible,\n)\n\nUpdate the mass-weighted potential temperature with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, tracersetup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    tracersetup::AbstractTracer,\n)\n\nUpdate the tracers with a Runge-Kutta step on the left-hand sides of the equations with WKB right-hand side terms according to namelists configuration.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nm: Runge-Kutta-stage index.\nvariable: Variable to update.\nmodel: Dynamic equations.\nside: Side of the equation.\nintegration: Type of the Euler step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\ntracersetup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.Update.compute_volume_force\nPinCFlow.Update.compute_compressible_wind_factor\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.Update.compute_buoyancy_factor\nPinCFlow.Update.compute_pressure_gradient\nPinCFlow.Update.transform\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#Boundaries","page":"Boundaries","title":"Boundaries","text":"","category":"section"},{"location":"reference/boundaries/#PinCFlow.Boundaries","page":"Boundaries","title":"PinCFlow.Boundaries","text":"Boundaries\n\nModule for enforcing boundary conditions for different variable types and field dimensions.\n\nHandles periodic boundaries in the horizontal and solid-wall boundaries in the vertical, as well as MPI communication in all dimensions.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/boundaries/#PinCFlow.Boundaries.AbstractBoundaryVariables","page":"Boundaries","title":"PinCFlow.Boundaries.AbstractBoundaryVariables","text":"AbstractBoundaryVariables\n\nAbstract type for boundary-variable categories.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryFluxes","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryFluxes","text":"BoundaryFluxes <: AbstractBoundaryVariables\n\nBoundary-variable category for flux fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryPredictands","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryPredictands","text":"BoundaryPredictands <: AbstractBoundaryVariables\n\nBoundary-variable category for predictand fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryReconstructions","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryReconstructions","text":"BoundaryReconstructions <: AbstractBoundaryVariables\n\nBoundary-variable category for reconstruction fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryWKBIntegrals","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryWKBIntegrals","text":"BoundaryWKBIntegrals <: AbstractBoundaryVariables\n\nBoundary-variable category for gravity-wave-integral fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryWKBTendencies","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryWKBTendencies","text":"BoundaryWKBTendencies <: AbstractBoundaryVariables\n\nBoundary-variable category for gravity-wave-tendency fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_boundaries!","text":"set_boundaries!(state::State, variables::BoundaryPredictands)\n\nEnforce all boundary conditions for predictand fields.\n\nset_boundaries!(state::State, variables::BoundaryReconstructions)\n\nEnforce all boundary conditions for reconstruction fields.\n\nset_boundaries!(state::State, variables::BoundaryFluxes)\n\nEnforce vertical boundary conditions for flux fields (horizontal boundaries are taken care of at the reconstruction stage).\n\nset_boundaries!(state::State, variables::BoundaryWKBIntegrals)\n\nEnforce all boundary conditions for gravity-wave-integral fields.\n\nset_boundaries!(state::State, variables::BoundaryWKBTendencies)\n\nEnforce all boundary conditions for gravity-wave-tendency fields.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries!\nPinCFlow.Boundaries.set_meridional_boundaries!\nPinCFlow.Boundaries.set_vertical_boundaries!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_compressible_meridional_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_compressible_meridional_boundaries!","text":"set_compressible_meridional_boundaries!(state::State)\n\nEnforce meridional boundary conditions for the mass-weighted potential temperature in compressible mode by dispatching to a model-specific method.\n\nset_compressible_meridional_boundaries!(state::State, model::AbstractModel)\n\nReturn in non-compressible modes.\n\nset_compressible_meridional_boundaries!(state::State, model::Compressible)\n\nEnforce meridional boundary conditions for the mass-weighted potential temperature in compressible mode.\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_compressible_vertical_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_compressible_vertical_boundaries!","text":"set_compressible_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n)\n\nEnforce vertical boundary conditions for the specified variables in compressible mode by dispatching to a model-specific method.\n\nset_compressible_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes.\n\nset_compressible_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Compressible,\n)\n\nEnforce vertical boundary conditions for the mass-weighted potential temperature in compressible mode (line reflection).\n\nset_compressible_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    model::Compressible,\n)\n\nEnforce vertical boundary conditions for the vertical mass-weighted potential-temperature flux (no flux through boundaries).\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nmodel: Dynamic equations.\n\nSee also\n\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_compressible_zonal_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_compressible_zonal_boundaries!","text":"set_compressible_zonal_boundaries!(state::State)\n\nEnforce zonal boundary conditions for the mass-weighted potential temperature in compressible mode by dispatching to a model-specific method.\n\nset_compressible_zonal_boundaries!(state::State, model::AbstractModel)\n\nReturn in non-compressible modes.\n\nset_compressible_zonal_boundaries!(state, model::Compressible)\n\nEnforce zonal boundary conditions for the mass-weighted potential temperature in compressible mode.\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_meridional_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_meridional_boundaries!","text":"set_meridional_boundaries!(state::State, variables::BoundaryPredictands)\n\nEnforce meridional boundary conditions for all predictand fields.\n\nset_meridional_boundaries!(state::State, variables::BoundaryReconstructions)\n\nEnforce meridional boundary conditions for all reconstruction fields.\n\nset_meridional_boundaries!(state::State, variables::BoundaryWKBIntegrals)\n\nEnforce meridional boundary conditions for gravity-wave-integral fields by dispatching to a WKB-mode-specific method.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce meridional boundary conditions for gravity-wave-integral fields needed in SingleColumn and SteadyState configurations.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce meridional boundary conditions for gravity-wave-integral fields needed in MultiColumn configurations.\n\nset_meridional_boundaries!(state::State, variables::BoundaryWKBTendencies)\n\nEnforce meridional boundary conditions for gravity-wave-tendency fields by dispatching to a WKB-mode-specific method.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce meridional boundary conditions for gravity-wave-tendency fields needed in SingleColumn and SteadyState configurations.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce meridional boundary conditions for gravity-wave-tendency fields needed in MultiColumn configurations.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.Boundaries.set_compressible_meridional_boundaries!\nPinCFlow.Boundaries.set_tracer_meridional_boundaries!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_meridional_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_meridional_boundaries_of_field!","text":"set_meridional_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce meridional boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npy > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_meridional_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_meridional_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_meridional_boundaries!","text":"set_tracer_meridional_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n)\n\nEnforce meridional boundary conditions for tracers by dispatching to a tracer-configuration-specific method.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::AbstractTracer,\n)\n\nEnforce meridional boundary conditions for tracers.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::AbstractTracer,\n)\n\nEnforce meridional boundary conditions for reconstructions of tracers.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_model::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce meridional boundary conditions for tracer-gravity-wave-integral fields.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce meridional boundary conditions for tracer-gravity-wave-tendency fields.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracersetup: General tracer-transport configuration.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_vertical_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_vertical_boundaries!","text":"set_tracer_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n)\n\nEnforce vertical boundary conditions for tracers by dispatching to a tracer-configuration-specific method.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::AbstractTracer,\n)\n\nEnforce vertical boundary conditions for tracers.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::AbstractTracer,\n)\n\nEnforce vertical boundary conditions for reconstructions of tracers.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    tracersetup::AbstractTracer,\n)\n\nSet the vertical tracer fluxes at the vertical boundaries to zero.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce vertical boundary conditions for tracer-gravity-wave-integral fields.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce vertical boundary conditions for tracer-gravity-wave-tendency fields.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracersetup: General tracer-transport configuration.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_zonal_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_zonal_boundaries!","text":"set_tracer_zonal_boundaries!(state::State, variables::AbstractBoundaryVariables)\n\nEnforce zonal boundary conditions for tracers by dispatching to a tracer-configuration-specific method.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracersetup::AbstractTracer,\n)\n\nEnforce zonal boundary conditions for tracers.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracersetup::AbstractTracer,\n)\n\nEnforce zonal boundary conditions for reconstructions of tracers.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce zonal boundary conditions for tracer-gravity-wave-integral fields.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n    tracersetup::AbstractTracer,\n)\n\nEnforce zonal boundary conditions for tracer-gravity-wave-tendency fields.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracersetup: General tracer-transport configuration.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_vertical_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_vertical_boundaries!","text":"set_vertical_boundaries!(state::State, variables::BoundaryPredictands)\n\nEnforce vertical boundary conditions for all predictand fields.\n\nThe symmetry conditions are as follows:\n\nDensity-fluctuations fields (rho, rhop): point reflection (-)\nVertical velocity (w): point reflection (-) on the staggered grid\nHorizontal velocities (u, v): line reflection (+)\nExner-pressure fluctuations (pip): line reflection (+)\n\nset_vertical_boundaries!(state::State, variables::BoundaryReconstructions)\n\nEnforce vertical boundary conditions for all reconstruction fields.\n\nset_vertical_boundaries!(state::State, variables::BoundaryFluxes)\n\nSet the vertical fluxes at the vertical boundaries to zero.\n\nset_vertical_boundaries!(state::State, variables::BoundaryWKBIntegrals)\n\nEnforce vertical boundary conditions for gravity-wave-integral fields by dispatching to a WKB-mode-specific method.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce vertical boundary conditions for gravity-wave-integral fields needed in SingleColumn and SteadyState configurations, using line reflection.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce vertical boundary conditions for gravity-wave-integral fields needed in MultiColumn configurations, using line reflection.\n\nset_vertical_boundaries!(state::State, variables::BoundaryWKBTendencies)\n\nEnforce vertical boundary conditions for gravity-wave-tendency fields by dispatching to a WKB-mode-specific method.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce vertical boundary conditions for gravity-wave-tendency fields needed in SingleColumn and SteadyState configurations, using line reflection.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce vertical boundary conditions for gravity-wave-tendency fields needed in MultiColumn configurations, using line reflection.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\nPinCFlow.Boundaries.set_compressible_vertical_boundaries!\nPinCFlow.Boundaries.set_tracer_vertical_boundaries!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_vertical_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_vertical_boundaries_of_field!","text":"set_vertical_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain,\n    mode::Function;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n    staggered = false,\n)\n\nEnforce vertical boundary conditions for a 3D array (assuming solid-wall boundaries).\n\nHalo exchange is used for multi-process domains (npz > 1). Use mode = + (mode = -) for line-reflected (point-reflected) ghost-cell values.\n\nset_vertical_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange halo values of a 5D array if multiple processes are used in the vertical (npz > 1).\n\nThis method is applied to reconstruction arrays. Vertical boundary conditions are not enforced for these but for the fluxes determined from them.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmode: Method used for setting the boundary-cell values.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\nstaggered: A switch for whether or not the field is on the staggered vertical grid.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_zonal_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_zonal_boundaries!","text":"set_zonal_boundaries!(state::State, variables::BoundaryPredictands)\n\nEnforce zonal boundary conditions for all predictand fields.\n\nset_zonal_boundaries!(state::State, variables::BoundaryReconstructions)\n\nEnforce zonal boundary conditions for all reconstruction fields.\n\nset_zonal_boundaries!(state::State, variables::BoundaryWKBIntegrals)\n\nEnforce zonal boundary conditions for gravity-wave-integral fields by dispatching to a WKB-mode-specific method.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce zonal boundary conditions for gravity-wave-integral fields needed in SingleColumn and SteadyState configurations.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce zonal boundary conditions for gravity-wave-integral fields needed in MultiColumn configurations.\n\nset_zonal_boundaries!(state::State, variables::BoundaryWKBTendencies)\n\nEnforce zonal boundary conditions for gravity-wave-tendency fields by dispatching to a WKB-mode-specific method.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::AbstractWKBMode,\n)\n\nEnforce zonal boundary conditions for gravity-wave-tendency fields needed in SingleColumn and SteadyState configurations.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce zonal boundary conditions for gravity-wave-tendency fields needed in MultiColumn configurations.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_compressible_zonal_boundaries!\nPinCFlow.Boundaries.set_tracer_zonal_boundaries!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_zonal_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_zonal_boundaries_of_field!","text":"set_zonal_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce zonal boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npx > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_zonal_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"examples/mountain_wave_simulation/#Mountain-wave-simulation","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"","category":"section"},{"location":"examples/mountain_wave_simulation/#Simulation","page":"Mountain-wave simulation","title":"Simulation","text":"","category":"section"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"The script","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"# examples/submit/mountain_wave.jl\n\nusing PinCFlow\n\n@ivy if length(ARGS) == 0\n    output_file = \"./pincflow_output.h5\"\nelseif length(ARGS) == 1\n    output_file = ARGS[1] * \"/pincflow_output.h5\"\nelse\n    error(\"Too many arguments to the script!\")\nend\n\natmosphere = AtmosphereNamelist(; backgroundflow_dim = (1.0E+1, 0.0E+0, 0.0E+0))\ndomain = DomainNamelist(;\n    sizex = 40,\n    sizey = 40,\n    sizez = 40,\n    lx_dim = 2.0E+4,\n    ly_dim = 2.0E+4,\n    lz_dim = 2.0E+4,\n    npx = 8,\n    npy = 8,\n)\ngrid = GridNamelist(; mountain_case = 4)\noutput = OutputNamelist(; output_variables = (:w,), output_file = output_file)\nsponge = SpongeNamelist(;\n    spongelayer = true,\n    alpharmax = 1.79E-2,\n    betarmax = 0.0E+0,\n    lateralsponge = true,\n    spongetype = SinusoidalSponge(),\n    relax_to_mean = false,\n    relaxation_wind = (1.0E+1, 0.0E+0, 0.0E+0),\n)\n\nintegrate(Namelists(; atmosphere, domain, grid, output, sponge))\n","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"performs a 3D mountain-wave simulation with parallelization in the zonal and meridional dimensions, and writes the vertical wind to pincflow_output.h5, if executed with","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"mpiexec=$(julia --project -e 'using MPICH_jll; println(MPICH_jll.mpiexec_path)')\n${mpiexec} -n 64 julia --project examples/submit/mountain_wave.jl","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"from the root directory of the repository (provided MPI.jl and HDF5.jl are configured to use their default backends). The surface topography is given by","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"h left(x yright) = frach_01 + left(x^2 + y^2right)  l_0^2","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"where the default values h_0 = 100  mathrmm and l_0 = 1  mathrmkm are being used. The atmosphere is isothermal, with the default temperature T_0 = 300  mathrmK and the initial wind boldsymbolu_0 = left(10 0 0right)^mathrmT  mathrmm  s^- 1.","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"Reflections at the upper boundary are prevented by damping the generated mountain waves in a sponge defined by","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"alpha_mathrmR left(x y zright) = fracalpha_mathrmR x left(xright) + alpha_mathrmR y left(yright) + alpha_mathrmR z left(zright)3","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"with","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"beginalign*\n    alpha_mathrmR x left(xright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(x_mathrmR 0 - xright)2 Delta x_mathrmRright  mathrmif quad x leq x_mathrmR 0\n        alpha_mathrmR max sin^2 leftfracpi left(x - x_mathrmR 1right)2 Delta x_mathrmRright  mathrmif quad x geq x_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR y left(yright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(y_mathrmR 0 - yright)2 Delta y_mathrmRright  mathrmif quad y leq y_mathrmR 0\n        alpha_mathrmR max sin^2 leftfracpi left(y - y_mathrmR 1right)2 Delta y_mathrmRright  mathrmif quad y geq y_mathrmR 1\n        0  mathrmelse\n    endcases\n    alpha_mathrmR z left(zright)  = begincases\n        alpha_mathrmR max sin^2 leftfracpi left(z - z_mathrmRright)2 Delta z_mathrmRright  mathrmif quad z geq z_mathrmR\n        0  mathrmelse\n    endcases\nendalign*","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"where the maximum of the damping coefficient is alpha_mathrmR max = 00179  mathrms^- 1, which corresponds to the buoyancy frequency. Since the simulation uses the default setting spongeheight = 0.5, the parameter Delta z_mathrmR is given by half of the domain's vertical extent, whereas Delta x_mathrmR and Delta y_mathrmR are each given by a quarter of the domain's extent in the respective dimension. The edges of the sponge are such that it is horizontally centered at left(- 10 - 10right)^mathrmT  mathrmkm and has an extent of left(Delta x_mathrmR Delta y_mathrmRright)^mathrmT below z_mathrmR = 10  mathrmkm, whereas it covers the entire horizontal plane above that altitude (see below for plots of alpha_mathrmR in three cross sections of the domain). This means that the sponge not only prevents wave reflections at the model top but also provides a damping at the horizontal boundaries. Moreover, it is configured such that the wind is relaxed towards its initial state, so that (in the ideal case) the periodicity in x and y is effectively eliminated by enforcing a constant wind at the domain edges.","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"(Image: )","category":"page"},{"location":"examples/mountain_wave_simulation/#Visualization","page":"Mountain-wave simulation","title":"Visualization","text":"","category":"section"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"The script","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"# examples/visualization/mountain_wave.jl\n\nusing HDF5\nusing PythonPlot\nusing LaTeXStrings\nusing PinCFlow\n\nset_plot_style()\n\n# Import the data.\n@ivy if length(ARGS) == 0\n    data = h5open(\"./pincflow_output.h5\")\nelseif length(ARGS) == 1\n    data = h5open(ARGS[1] * \"/pincflow_output.h5\")\nelse\n    error(\"Too many arguments to the script!\")\nend\n\n# Set the grid.\nx = data[\"x\"][:] ./ 1000\ny = data[\"y\"][:] ./ 1000\nz = data[\"z\"][:, :, :] ./ 1000\nx = [xi for xi in x, j in 1:size(z)[2], k in 1:size(z)[3]]\ny = [yj for i in 1:size(z)[1], yj in y, k in 1:size(z)[3]]\n\n# Get the vertical wind.\nw = data[\"w\"][:, :, :, end]\n\n# Close the file.\nclose(data)\n\n# Create the figure.\nfigure(; figsize = (12, 3))\n\n# Plot in x-y plane.\nk = 10\nsubplot(131)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[:, :, k]), maximum(w[:, :, k]))\n@ivy contours = contourf(\n    x[:, :, k],\n    y[:, :, k],\n    w[:, :, k];\n    levels = levels,\n    cmap = colormap,\n)\nxlabel(L\"x\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"y\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"z\\approx 5\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Plot in x-z plane.\nj = 20\nsubplot(132)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[:, j, :]), maximum(w[:, j, :]))\n@ivy contours = contourf(\n    x[:, j, :],\n    z[:, j, :],\n    w[:, j, :];\n    levels = levels,\n    cmap = colormap,\n)\n@ivy plot(x[:, j, 1], z[:, j, 1]; color = \"black\", linewidth = 0.5)\nxlabel(L\"x\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"z\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"y\\approx 0\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Plot in y-z plane.\ni = 20\nsubplot(133)\n@ivy (levels, colormap) =\n    symmetric_contours(minimum(w[i, :, :]), maximum(w[i, :, :]))\n@ivy contours = contourf(\n    y[i, :, :],\n    z[i, :, :],\n    w[i, :, :];\n    levels = levels,\n    cmap = colormap,\n)\n@ivy plot(y[i, :, 1], z[i, :, 1]; color = \"black\", linewidth = 0.5)\nxlabel(L\"y\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"z\\,\\left[\\mathrm{km}\\right]\")\ntitle(L\"x\\approx 0\\,\\mathrm{km}\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\n\n# Save the figure.\nsavefig(\"examples/results/mountain_wave.png\")\nclf()\n","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"visualizes the vertical wind at the end of the above simulation (i.e. after one hour) in three cross sections of the domain and saves the generated figure to a PNG file that is included below. Note that symmetric_contours returns a cropped colormap that is centered at w = 0  mathrmm  s^- 1.","category":"page"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"(Image: )","category":"page"},{"location":"examples/mountain_wave_simulation/#See-also","page":"Mountain-wave simulation","title":"See also","text":"","category":"section"},{"location":"examples/mountain_wave_simulation/","page":"Mountain-wave simulation","title":"Mountain-wave simulation","text":"PinCFlow.Types.NamelistTypes.AtmosphereNamelist\nPinCFlow.Types.NamelistTypes.GridNamelist\nPinCFlow.Types.NamelistTypes.SpongeNamelist\nPinCFlow.Types.FoundationalTypes.compute_topography\nPinCFlow.Types.FoundationalTypes.Sponge\nPinCFlow.Update.compute_sponges!\nPinCFlow.Update.apply_lhs_sponge!\nPinCFlow.set_plot_style\nPinCFlow.symmetric_contours","category":"page"},{"location":"reference/mpi_operations/#MPIOperations","page":"MPIOperations","title":"MPIOperations","text":"","category":"section"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations","page":"MPIOperations","title":"PinCFlow.MPIOperations","text":"MPIOperations\n\nModule for operations that require communication between MPI processes.\n\nProvides halo exchange functions for maintaining field continuity across process boundaries, as well as global reduction operations.\n\nSee also\n\nPinCFlow.Types\n\n\n\n\n\n","category":"module"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.compute_global_dot_product","page":"MPIOperations","title":"PinCFlow.MPIOperations.compute_global_dot_product","text":"compute_global_dot_product(\n    a::AbstractArray{<:AbstractFloat, 3},\n    b::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n)::AbstractFloat\n\nCompute and return the dot product boldsymbola cdot boldsymbolb = sum_i a_i cdot b_i of two 3D arrays distributed across MPI processes.\n\nArguments\n\na: First input array.\nb: Second input array (must have the same shape as a).\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_meridional_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_meridional_halos_of_field!","text":"set_meridional_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all meridional halo values of a matrix by performing bidirectional MPI communication between backward and forward neighbor processes.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_vertical_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_vertical_halos_of_field!","text":"set_vertical_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 3D array by performing MPI communication between downward and upward neighbor processes.\n\nSolid walls are assumed at the vertical boundaries of the domain. The corresponding ghost-cell values are not changed.\n\nset_vertical_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 5D array with an algorithm similar to that implemented in the above method.\n\nThe vertical domain boundaries are treated as described above. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_zonal_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_zonal_halos_of_field!","text":"set_zonal_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all zonal halo values of a matrix by performing bidirectional MPI communication between left and right neighbor processes.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PoissonSolver","page":"PoissonSolver","title":"PoissonSolver","text":"","category":"section"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver","page":"PoissonSolver","title":"PinCFlow.PoissonSolver","text":"PoissonSolver\n\nModule for solving the Poisson equation and performing a corrector step.\n\nProvides the functions needed to solve the Poisson equation of the semi-implicit time scheme, using a preconditioned BicGStab algorithm, and correcting the Exner-pressure, momentum and density fluctuations accordingly.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\nPinCFlow.Boundaries\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.Horizontal","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.Horizontal","text":"Horizontal\n\nSingleton for dispatch to application of the horizontal part of the linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.Total","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.Total","text":"Total\n\nSingleton for dispatch to application of the full linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_bicgstab!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_bicgstab!","text":"apply_bicgstab!(state::State, tolref::AbstractFloat)::Tuple{Bool, <:Integer}\n\nSolve the Poisson equation using a preconditioned BicGStab algorithm and return a tuple containing an error flag and the number of iterations.\n\nArguments\n\nstate: Model state.\ntolref: Reference tolerance for convergence criterion.\n\nSee also\n\nPinCFlow.PoissonSolver.apply_operator!\nPinCFlow.PoissonSolver.apply_preconditioner!\nPinCFlow.MPIOperations.compute_global_dot_product\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_corrector!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_corrector!","text":"apply_corrector!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n)::Tuple{Bool, <:Integer}\n\nPerform the corrector step and return a tuple containing an error flag and the number of BicGStab iterations.\n\nThe left-hand side and the linear operator of the discrete Poisson equation are calculated. The equation is then solved for Exner-pressure differences, using a preconditioned BicGStab algorithm. Finally, the Exner-pressure, wind and density fluctuations are corrected accordingly.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.PoissonSolver.compute_lhs!\nPinCFlow.PoissonSolver.solve_poisson!\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\nPinCFlow.PoissonSolver.correct!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_operator!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_operator!","text":"apply_operator!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    ls::AbstractArray{<:AbstractFloat, 3},\n    hortot::Total,\n    state::State,\n)\n\nApply the total linear operator to the solution array sin.\n\nBefore the operator is applied, the boundary/halo values of sin are set, using set_zonal_boundaries_of_field!, set_meridional_boundaries_of_field! and set_vertical_halos_of_field!. Note that in the vertical, only halo values need to be set (if the domain is paralellized in that direction), due to the solid-wall boundaries.\n\napply_operator!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    ls::AbstractArray{<:AbstractFloat, 3},\n    hortot::Horizontal,\n    state::State,\n)\n\nApply the \"horizontal part\" of the linear operator (excluding the lower, center and upper diagonal) to the solution array sin.\n\nBefore the operator is applied, the boundary/halo values of sin are set, in the same way as in the method applying the total operator.\n\nArguments\n\nsin: Solution array.\nls: Result of applying the operator to the solution array.\nhortot: Linear-operator mode.\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_preconditioner!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_preconditioner!","text":"apply_preconditioner!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    sout::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n)\n\nApply a preconditioner to the Poisson problem.\n\nThis preconditioner integrates the auxiliary equation\n\nfracmathrmd smathrmd eta = mathcalL_mathrmh left(sright) + mathcalL_mathrmv left(sright) - b\n\nwhere s is the iterative solution, eta is a pseudo-time variable, mathcalL_mathrmv contains the lower, center and upper diagonals of the linear operator, mathcalL_mathrmh contains all remaining elements, and b is the left-hand side. The integration is performed in a semi-implicit manner, following\n\nleft(1 - Delta eta mathcalL_mathrmvright) left(s^left(m + 1right)right) = left(1 + Delta eta mathcalL_mathrmhright) left(s^left(mright)right) - Delta eta b\n\nwhere Delta eta = Delta tau  2 leftleft(Delta widehatxright)^- 2 + left(Delta widehatyright)^- 2right^- 1, with Delta tau being a namelist parameter (state.namelist.poisson.dtau). Therein, the implicit problem is solved with the Thomas algorithm for tridiagonal matrices. The number of iterations is given by state.namelist.poisson.maxiteradi. Since the Thomas algorithm consists of an upward elimination sweep and a downward pass, this method performs sequential one-way MPI communication if the domain is paralellized in the vertical.\n\nArguments\n\nsin: Residual array.\nsout: Solution of the preconditioner.\nstate: Model state.\n\nSee also\n\nPinCFlow.PoissonSolver.apply_operator!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.compute_lhs!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.compute_lhs!","text":"compute_lhs!(state::State)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation and return a reference tolerance for the convergence criterion by dispatching to a model-specific method.\n\ncompute_lhs!(state::State, model::AbstractModel)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation in pseudo-incompressible/Boussinesq mode and return a reference tolerance for the convergence criterion.\n\nThe scaled left-hand side is given by\n\nbeginalign*\n    b  = fracsqrtoverlinerhoP frac1J c_p leftfrac1Delta widehatx leftleft(J Pright)_i + 1  2 u_i + 1  2 - left(J Pright)_i - 1  2 u_i - 1  2rightright\n     qquad qquad quad + frac1Delta widehaty leftleft(J Pright)_j + 1  2 v_j + 1  2 - left(J Pright)_j - 1  2 v_j - 1  2right\n     qquad qquad quad + leftfrac1Delta widehatz leftleft(J Pright)_k + 1  2 widehatw_k + 1  2 - left(J Pright)_k - 1  2 widehatw_k - 1  2rightright\nendalign*\n\nand the reference tolerance is given by\n\ntau_mathrmref = fracsum_i j k b_i j k^2sum_i j k left(b_u i j k^2 + b_v i j k^2 + b_widehatw i j k^2right)\n\nwhere b_u, b_v and b_widehatw are the zonal, meridional and vertical parts of b, respectively. Note that in Boussinesq mode, P = P_0 will cancel out, so that the appropriate divergence constraint remains.\n\ncompute_lhs!(state::State, model::Compressible)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation in compressible mode and return a reference tolerance for the convergence criterion.\n\nThe scaled left-hand side is given by\n\nbeginalign*\n    b  = fracsqrtoverlinerhoP frac1J c_p leftfrac1Delta widehatx leftleft(J Pright)_i + 1  2 u_i + 1  2 - left(J Pright)_i - 1  2 u_i - 1  2rightright\n     qquad qquad quad + frac1Delta widehaty leftleft(J Pright)_j + 1  2 v_j + 1  2 - left(J Pright)_j - 1  2 v_j - 1  2right\n     qquad qquad quad + leftfrac1Delta widehatz leftleft(J Pright)_k + 1  2 widehatw_k + 1  2 - left(J Pright)_k - 1  2 widehatw_k - 1  2rightright - fracsqrtoverlinerhoP F^P\nendalign*\n\nwhere F^P is the diabatic heating, as computed by compute_volume_force, and the reference tolerance is computed in the same way as in the method for pseudo-incompressible/Boussinesq mode, with b_F i j k^2 added to the sum in the denominator, representing the heating term.\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\nSee also\n\nPinCFlow.Update.compute_volume_force\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.compute_operator!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.compute_operator!","text":"compute_operator!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n)\n\nCompute the tensor elements of the linear operator on the right-hand side of the Poisson equation.\n\nThe operator is obtained by rewriting the scaled Poisson equation\n\nfracsqrtoverlinerhoP mathrmLHS = fracsqrtoverlinerhoP mathrmRHS left(fracsqrtoverlinerhoP sright)\n\nas\n\nfracsqrtoverlinerhoP mathrmLHS = sum_lambda mu nu A_i + lambda j + mu k + nu s_i + lambda j + mu k + nu\n\nwhere the Exner-pressure differences are given by Delta pi = left(sqrtoverlinerho  Pright) left(s  Delta tright).\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.Update.compute_buoyancy_factor\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.correct!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.correct!","text":"correct!(state::State, dt::AbstractFloat, rayleigh_factor::AbstractFloat)\n\nCorrect the Exner-pressure, wind and density fluctuations such that the divergence constraint is satisfied, using the Exner-pressure differences obtained from the solution to the Poisson problem.\n\nThis method calls specific methods for the correction of each individual variable.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the zonal wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nu_i + 1  2 rightarrow u_i + 1  2 - mathcalC_i + 1  2^u\n\nin Boussinesq/pseudo-incompressible mode and\n\nU_i + 1  2 rightarrow U_i + 1  2 - left(J Pright)_i + 1  2 mathcalC_i + 1  2^u\n\nin compressible mode, with\n\nmathcalC_i + 1  2^u = left(1 + beta_mathrmR i + 1  2^uv Delta tright)^- 1 Delta t c_p fracP_i + 1  2rho_i + 1  2 mathcalD_i + 1  2^u\n\nTherein, U_i + 1  2 = left(J Pright)_i + 1  2 u_i + 1  2, Delta t is the fractional time step given as input to this method and c_p left(P_i + 1  2  rho_i + 1  2right) mathcalD_i + 1  2^u is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the meridional wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nv_j + 1  2 rightarrow v_j + 1  2 - mathcalC_j + 1  2^v\n\nin Boussinesq/pseudo-incompressible mode and\n\nV_j + 1  2 rightarrow V_j + 1  2 - left(J Pright)_j + 1  2 mathcalC_j + 1  2^v\n\nin compressible mode, with\n\nmathcalC_j + 1  2^v = left(1 + beta_mathrmR j + 1  2^uv Delta tright)^- 1 Delta t c_p fracP_j + 1  2rho_j + 1  2 mathcalD_j + 1  2^v\n\nwhere V_j + 1  2 = left(J Pright)_j + 1  2 v_j + 1  2 and c_p left(P_j + 1  2  rho_j + 1  2right) mathcalD_j + 1  2^v is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the transformed vertical wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nbeginalign*\n    widehatw_k + 1  2  rightarrow widehatw_k + 1  2 - left1 + beta_mathrmR k + 1  2^widehatw Delta t + fracoverlinerho_k + 1  2rho_k + 1  2 left(N Delta tright)^2right^- 1\n     quad times leftDelta t c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^widehatw + fracoverlinerho_k + 1  2rho_k + 1  2 left(N Delta tright)^2 leftleft(G^1 3 mathcalC^uright)_k + 1  2 + left(G^23 mathcalC^vright)_k + 1  2rightright\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    widehatW_k + 1  2  rightarrow widehatW_k + 1  2 - left1 + beta_mathrmR k + 1  2^widehatw Delta t + fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 left(N Delta tright)^2right^- 1\n     quad times leftDelta t c_p left(J Pright)_k + 1  2 fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^widehatw vphantomfracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2right\n     qquad quad + leftleft(J Pright)_k + 1  2 fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 left(N Delta tright)^2 leftleft(G^1 3 mathcalC^uright)_k + 1  2 + left(G^23 mathcalC^vright)_k + 1  2rightright\nendalign*\n\nin compressible mode, where widehatW_k + 1  2 = left(J Pright)_k + 1  2 widehatw_k + 1  2 and c_p left(P_k + 1  2  rho_k + 1  2right) mathcalD_k + 1  2^widehatw is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the density fluctuations to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nbeginalign*\n    rho  rightarrow rho + fracrhog left1 + beta_mathrmR^widehatw Delta t + fracoverlinerhorho left(N Delta tright)^2right^- 1\n     quad times left- fracoverlinerhorho left(N Delta tright)^2 J left(c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^widehatwright)right\n     qquad quad + leftfracoverlinerhorho N^2 Delta t J left(1 + beta_mathrmR^widehatw Delta tright) left(G^1 3 mathcalC^u + G^2 3 mathcalC^vright)right\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    rho  rightarrow rho + fracrhog left1 + beta_mathrmR^widehatw Delta t + fracP  overlinethetarho left(N Delta tright)^2right^- 1\n     quad times left- fracP  overlinethetarho left(N Delta tright)^2 J left(c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^widehatwright)right\n     qquad quad + leftfracP  overlinethetarho N^2 Delta t J left(1 + beta_mathrmR^widehatw Delta tright) left(G^1 3 mathcalC^u + G^2 3 mathcalC^vright)right\nendalign*\n\nin compressible mode, where c_p left(P_k + 1  2  rho_k + 1  2right) mathcalD_k + 1  2^widehatw and c_p left(P_k - 1  2  rho_k - 1  2right) mathcalD_k - 1  2^widehatw are computed with compute_pressure_gradient, and used to interpolate to left(i j kright).\n\ncorrect!(state::State, variable::PiP)\n\nUpdate the Exner-pressure fluctuations with the differences obtained from the solution to the Poisson problem.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nvariable: Variable to correct.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.Update.compute_pressure_gradient\nPinCFlow.Update.compute_compressible_wind_factor\nPinCFlow.Update.compute_buoyancy_factor\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.solve_poisson!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.solve_poisson!","text":"solve_poisson!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n    tolref::AbstractFloat,\n)::Tuple{Bool, <:Integer}\n\nSolve the Poisson equation and return a tuple containing an error flag and the number of iterations.\n\nGiven a left-hand side and reference tolerance, this method computes the elements of the linear operator and solves the Poisson equation, using a preconditioned BicGStab algorithm. Both the Exner-pressure differences and the entire equation are scaled with sqrtoverlinerho  P in advance (the left-hand side has already been scaled at this point), so that the equation\n\nfracsqrtoverlinerhoP mathrmLHS = fracsqrtoverlinerhoP mathrmRHS left(fracsqrtoverlinerhoP sright)\n\nis solved for s. The Exner-pressure differences are then given by Delta pi = left(sqrtoverlinerho  Pright) left(s  Delta tright).\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\ntolref: Reference tolerance for convergence criterion.\n\nSee also\n\nPinCFlow.PoissonSolver.compute_operator!\nPinCFlow.PoissonSolver.apply_bicgstab!\n\n\n\n\n\n","category":"function"},{"location":"reference/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"reference/output/#PinCFlow.Output","page":"Output","title":"PinCFlow.Output","text":"Output\n\nModule for I/O of PinCFlow simulation data.\n\nProvides functions for writing the model state and initializing the model with data from a previous simulation.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/output/#PinCFlow.Output.create_output","page":"Output","title":"PinCFlow.Output.create_output","text":"create_output(state::State)\n\nCreate an HDF5 output file with one dataset for each variable.\n\nThe dimensions of the datasets are set to those of the domain, whereas the chunks are set to the dimensions of the MPI subdomains, in preparation for parallel output. Datasets for the grid, i.e. the fields x, y and ztfc of state.grid, the time and the fields of state.atmosphere are always created, regardless of the specifications in state.namelists.output. The one exception to this is the Boussinesq mode, in which no datasets are created for the fields of state.atmosphere, since they do not have a spatial dependence.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/output/#PinCFlow.Output.read_input!","page":"Output","title":"PinCFlow.Output.read_input!","text":"read_input!(state::State)\n\nRead initial values for all prognostic variables from an HDF5 input file.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/output/#PinCFlow.Output.write_output","page":"Output","title":"PinCFlow.Output.write_output","text":"write_output(\n    state::State,\n    time::AbstractFloat,\n    iout::Integer,\n    machine_start_time::DateTime,\n)::Integer\n\nWrite the current simulation state to a previously created HDF5 output file and return the advanced output counter iout.\n\nThe output is written in parallel, using the chunking prepared by create_output. The grid, i.e. the fields x, y and ztfc of state.grid, as well as the fields of state.atmosphere are only written if iout == 1 (which should only be the case for the initial output). In Boussinesq mode, the fields of state.atmosphere do not have a spatial dependence and are therefore not written at all. In compressible mode, the mass-weighted potential temperature and squared buoyancy frequency have a temporal dependence and are therefore written even if iout != 1. Any other field is only written if it is listed in state.namelists.output.output_variables or if it is essential for restarts and state.namelists.output.prepare_restart == true.\n\nThe list of available output variables (as specified in state.namelists.output.output_variables) is as follows.\n\n:rhop: Density fluctuations (restart variable).\n:u: Zonal wind.\n:us: Staggered zonal wind (restart variable).\n:v: Meridional wind.\n:vs: Staggered meridional wind (restart variable).\n:w: Vertical wind (computed with compute_vertical_wind).\n:ws: Staggered vertical wind (computed with compute_vertical_wind).\n:wtfc: Transformed vertical wind.\n:wstfc: Staggered transformed vertical wind (restart variable).\n:thetap: Potential-temperature fluctuations.\n:pip: Exner-pressure fluctuations (restart variable).\n:dudt: Zonal-momentum drag due to unresolved gravity waves.\n:dvdt: Meridional-momentum drag due to unresolved gravity waves.\n:dthetadt: Mass-weighted potential-temperature tendency due to unresolved gravity waves.\n:dchidt: Leading-order tracer impact of unresolved gravity waves.\n:uchi: Zonal tracer fluxes due to unresolved gravity waves.\n:vchi: Meridional tracer fluxes due to unresolved gravity waves.\n:wchi: Vertical tracer fluxes due to unresolved gravity waves.\n\nAn output of all ray-volume properties is provided if state.namelists.output.save_ray_volumes == true and/or state.namelists.output.prepare_restart == true.\n\nAll output variables are re-dimensionalized with the scale parameters stored in state.constants.\n\nArguments\n\nstate: Model state.\ntime: Simulation time.\niout: Output counter. This is the temporal index of the output. It is advanced before the output is written, so that the first call of write_output should receive iout = 0.\nmachine_start_time: Wall-clock start time.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#FluxCalculator","page":"FluxCalculator","title":"FluxCalculator","text":"","category":"section"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator","page":"FluxCalculator","title":"PinCFlow.FluxCalculator","text":"FluxCalculator\n\nModule for flux calculation.\n\nProvides functions for MUSCL reconstruction and flux computation.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.apply_1d_muscl!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.apply_1d_muscl!","text":"apply_1d_muscl!(\n    phi::AbstractVector{<:AbstractFloat},\n    phitilde::AbstractMatrix{<:AbstractFloat},\n    phisize::Integer,\n    limitertype::MCVariant,\n)\n\nApply the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) for reconstruction in one dimension.\n\nThe reconstruction to the left is given by\n\nwidetildephi^mathrmL = begincases\n    phi  mathrmif quad phi = phi_i - 1 quad mathrmor quad phi = phi_i + 1\n    phi - frac12 eta left(fracphi_i + 1 - phiphi - phi_i - 1right) left(phi - phi_i - 1right)  mathrmelse\nendcases\n\nand that to the right is given by\n\nwidetildephi^mathrmR = begincases\n    phi  mathrmif quad phi = phi_i - 1 quad mathrmor quad phi = phi_i + 1\n    phi + frac12 eta left(fracphi - phi_i - 1phi_i + 1 - phiright) left(phi_i + 1 - phiright)  mathrmelse\nendcases\n\nwhere\n\neta left(xiright) = max left0 min left(2 xi frac2 + xi3 2right)right\n\nis the monotonized-centered variant limiter.\n\nArguments\n\nphi: Input vector.\nphitilde: Output matrix with reconstructed values. The two columns of phitilde contain the reconstructions to the left and right. No reconstruction is computed for the first and last row of phitilde.\nphisize: Length of the input vector phi.\nlimitertype: Type of flux limiter to use.\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.apply_3d_muscl!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.apply_3d_muscl!","text":"apply_3d_muscl!(\n    phi::AbstractArray{<:AbstractFloat, 3},\n    phitilde::AbstractArray{<:AbstractFloat, 5},\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n    limitertype::AbstractLimiter,\n)\n\nApply the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) for reconstruction in three dimensions.\n\nArguments\n\nphi: Input array.\nphitilde: Output array with reconstructed values. The fourth dimension represents the directions in which the input was reconstructed and the fifth dimension the reconstructions to the left and right.\nnxx: Size of phi in widehatx-direction.\nnyy: Size of phi in widehaty-direction.\nnzz: Size of phi in widehatz-direction.\nlimitertype: Type of flux limiter to use.\n\nSee also\n\nPinCFlow.FluxCalculator.apply_1d_muscl!\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.compute_flux","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.compute_flux","text":"compute_flux(\n    usurf::AbstractFloat,\n    phiup::AbstractFloat,\n    phidown::AbstractFloat,\n)::AbstractFloat\n\nCompute and return the upstream flux from reconstructed values, based on the sign of the transporting velocity.\n\nArguments\n\nusurf: Transporting velocity.\nphiup: Upstream reconstruction for usurf > 0.\nphidown: Downstream reconstruction for usurf > 0.\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.compute_fluxes!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.compute_fluxes!","text":"compute_fluxes!(state::State, predictands::Predictands)\n\nCompute fluxes by dispatching to specialized methods for each prognostic variable.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::Rho)\n\nCompute the density fluxes in all three directions.\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^rho widehatx_i + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1^mathrmLright\n    mathcalF^rho widehaty_j + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 1^mathrmBright\n    mathcalF^rho widehatz_k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_k + 1^mathrmDright\nendalign*\n\nwhere\n\nbeginalign*\n    tau_widehatx  = left(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2\n    tau_widehaty  = left(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2\n    tau_widehatz  = left(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2\nendalign*\n\nare the transporting velocities (weighted by the Jacobian) and widetildephi is the reconstruction of rho  P_mathrmold. More specifically, the superscripts mathrmR, mathrmL, mathrmF, mathrmB, mathrmU and mathrmD indicate reconstructions at the right, left, forward, backward, upward and downward cell interfaces of the respective grid points, respectively. Quantities with the subscript mathrmold are obtained from a previous state, which is partially passed to the method via predictands.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::RhoP)\n\nCompute the density-fluctuations fluxes in all three directions.\n\nThe computation is analogous to that of the density fluxes.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    model::AbstractModel,\n    variable::P,\n)\n\nReturn in non-compressible modes.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    model::Compressible,\n    variable::P,\n)\n\nCompute the mass-weighted potential-temperature fluxes in all three directions.\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^P widehatx_i + 1  2  = left(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2\n    mathcalF^P widehaty_j + 1  2  = left(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2\n    mathcalF^P widehatz_k + 1  2  = left(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::U)\n\nCompute the zonal-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho u widehatx_i + 1  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_i + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 3  2^mathrmLright\n    mathcalF^rho u widehaty_i + 1  2 j + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_i + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_i + 1  2 j + 1^mathrmBright\n    mathcalF^rho u widehatz_i + 1  2 k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_i + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_i + 1  2 k + 1^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_i + 1  2 j + 1  2\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_i + 1  2 k + 1  2\nendalign*\n\nand widetildephi being the reconstruction of rho_i + 1  2 u_i + 1  2  P_mathrmold i + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho u widehatx_i + 1  rightarrow mathcalF^rho u widehatx_i + 1 - left(J widehatPi^11right)_i + 1\n    mathcalF^rho u widehaty_i + 1  2 j + 1  2  rightarrow mathcalF^rho u widehaty_i + 1  2 j + 1  2 - left(J widehatPi^12right)_i + 1  2 j + 1  2\n    mathcalF^rho u widehatz_i + 1  2 k + 1  2  rightarrow mathcalF^rho u widehatz_i + 1  2 k + 1  2 - left(J widehatPi^13right)_i + 1  2 k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::V)\n\nCompute the meridional-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho v widehatx_i + 1  2 j + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_j + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1 j + 1  2^mathrmLright\n    mathcalF^rho v widehaty_j + 1  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_j + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 3  2^mathrmBright\n    mathcalF^rho v widehatz_j + 1  2 k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_j + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_j + 1  2 k + 1^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1  2 j + 1  2\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_j + 1\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_j + 1  2 k + 1  2\nendalign*\n\nand widetildephi being the reconstruction of rho_j + 1  2 v_j + 1  2  P_mathrmold j + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho v widehatx_i + 1  2 j + 1  2  rightarrow mathcalF^rho v widehatx_i + 1  2 j + 1  2 - left(J widehatPi^12right)_i + 1  2 j + 1  2\n    mathcalF^rho v widehaty_j + 1  rightarrow mathcalF^rho v widehaty_j + 1 - left(J widehatPi^22right)_j + 1\n    mathcalF^rho v widehatz_j + 1  2 k + 1  2  rightarrow mathcalF^rho v widehatz_j + 1  2 k + 1  2 - left(J widehatPi^23right)_j + 1  2 k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::W)\n\nCompute the vertical-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho w widehatx_i + 1  2 k + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_k + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1 k + 1  2^mathrmLright\n    mathcalF^rho w widehaty_j + 1  2 k + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_k + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 1 k + 1  2^mathrmBright\n    mathcalF^rho w widehatz_k + 1  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_k + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_k + 3  2^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1  2 k + 1  2\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_j + 1  2 k + 1  2\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_k + 1\nendalign*\n\nand widetildephi being the reconstruction of rho_k + 1  2 w_k + 1  2  P_mathrmold k + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho w widehatx_i + 1  2 k + 1  2  rightarrow mathcalF^rho w widehatx_i + 1  2 k + 1  2 - left(J Pi^13right)_i + 1  2 k + 1  2\n    mathcalF^rho w widehaty_j + 1  2 k + 1  2  rightarrow mathcalF^rho w widehaty_j + 1  2 k + 1  2 - left(J Pi^23right)_j + 1  2 k + 1  2\n    mathcalF^rho w widehatz_k + 1  rightarrow mathcalF^rho w widehatz_k + 1 - left(J G^13 Pi^13right)_k + 1 - left(J G^23 Pi^23right)_k + 1 - Pi^33_k + 1\nendalign*\n\ncompute_fluxes!(state::State, predictands::Predictands, tracersetup::NoTracer)\n\nReturn for configurations without tracer transport.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    tracersetup::AbstractTracer,\n)\n\nCompute the tracer fluxes in all three directions.\n\nThe computation is analogous to that of the density fluxes.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::Theta)\n\nCompute the potential temperature fluxes due to heat conduction (weighted by the Jacobian).\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^theta widehatx_i + 1  2  = - mu_i + 1  2 leftfracJ_i + 1  2Delta widehatx leftleft(fracPrhoright)_i + 1 - fracPrhorightright\n     qquad qquad qquad + leftfracleft(J G^13right)_i + 1  22 Delta widehatz leftleft(fracPrhoright)_i + 1  2 k + 1 - left(fracPrhoright)_i + 1  2 k - 1rightright\n    mathcalF^theta widehaty_j + 1  2  = - mu_j + 1  2 leftfracJ_j + 1  2Delta widehaty leftleft(fracPrhoright)_j + 1 - fracPrhorightright\n     qquad qquad qquad + leftfracleft(J G^23right)_j + 1  22 Delta widehatz leftleft(fracPrhoright)_j + 1  2 k + 1 - left(fracPrhoright)_j + 1  2 k - 1rightright\n    mathcalF^theta widehatz_k + 1  2  = - mu_k + 1  2 leftfracleft(J G^13right)_k + 1  22 Delta widehatx leftleft(fracPrhoright)_i + 1 k + 1  2 - left(fracPrhoright)_i - 1 k + 1  2rightright\n     qquad qquad qquad + fracleft(J G^23right)_k + 1  22 Delta widehaty leftleft(fracPrhoright)_j + 1 k + 1  2 - left(fracPrhoright)_j - 1 k + 1  2right\n     qquad qquad qquad + leftfracleft(J G^33right)_k + 1  2Delta widehatz leftleft(fracPrhoright)_k + 1 - fracPrhorightright\nendalign*\n\nwhere mu is the thermal conductivity (computed from state.namelists.atmosphere.mu_conduct_dim).\n\nArguments\n\nstate: Model state.\npredictands/old_predictands: The predictands that are used to compute the transporting velocities.\nmodel: Dynamic equations.\nvariable: Flux variable.\ntracersetup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.FluxCalculator.compute_flux\nPinCFlow.Update.compute_stress_tensor\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.reconstruct!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.reconstruct!","text":"reconstruct!(state::State)\n\nReconstruct the prognostic variables at the cell interfaces of their respective grids, using the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL).\n\nThis method calls specialized methods for each prognostic variable.\n\nreconstruct!(state::State, variable::Rho)\n\nReconstruct the density.\n\nSince the transporting velocity is P widehatboldsymbolu, the density is divided by P before reconstruction.\n\nreconstruct!(state::State, variable::RhoP)\n\nReconstruct the density fluctuations.\n\nSimilar to the density, the density fluctuations are divided by P before reconstruction.\n\nreconstruct!(state::State, variable::U)\n\nReconstruct the zonal momentum.\n\nSince the transporting velocity is P widehatboldsymbolu, the zonal momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, variable::V)\n\nReconstruct the meridional momentum.\n\nSimilar to the zonal momentum, the meridional momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, variable::W)\n\nReconstruct the vertical momentum.\n\nThe vertical momentum is computed with compute_vertical_wind, set_zonal_boundaries_of_field! and set_meridional_boundaries_of_field!. Similar to the zonal and meridional momenta, the vertical momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, tracersetup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nreconstruct!(state::State, tracersetup::AbstractTracer)\n\nReconstruct the tracers.\n\nSimilar to the density, the tracers are divided by P before reconstruction.\n\nArguments\n\nstate: Model state.\nvariable: The reconstructed variable.\ntracersetup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.FluxCalculator.apply_3d_muscl!\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"theory/numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"theory/numerics/#Temporal-discretization","page":"Numerics","title":"Temporal discretization","text":"","category":"section"},{"location":"theory/numerics/#Pseudo-incompressible-mode","page":"Numerics","title":"Pseudo-incompressible mode","text":"","category":"section"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"The pseudo-incompressible equations are integrated with the semi-implicit time scheme","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"beginalign*\n    1  rho^n  = rho^n - overlinerho\n    2  left(rho^ rho^ widehatboldsymbolu^right)  = mathrmL_Delta t  2 left(rho^n rho^n widehatboldsymbolu^n widehatboldsymbolu^n alpha_mathrmR^n + 1right)\n    3  left(rho^n + 1  2 widehatboldsymbolu^n + 1  2 pi^n + 1  2right)  = mathrmRI_Delta t  2 left(rho^ rho^ widehatboldsymbolu^ pi^n beta_mathrmR^uv n + 1 beta_mathrmR^widehatw n + 1right)\n    4  left(rho^* widehatboldsymbolu^*right)  = mathrmRE_Delta t  2 left(rho^n rho^n widehatboldsymbolu^n pi^n + 1  2right)\n    5  left(rho^** rho^** widehatboldsymbolu^**right)  = mathrmL_Delta t left(rho^n rho^* widehatboldsymbolu^* widehatboldsymbolu^n + 1  2 alpha_mathrmR^n + 1right)\n    6  left(rho^n + 1 widehatboldsymbolu^n + 1 pi^n + 1right)  = mathrmRI_Delta t  2 left(rho^** rho^** widehatboldsymbolu^** pi^n + 1  2 2 beta_mathrmR^uv n + 1 2 beta_mathrmR^widehatw n + 1right)\nendalign*","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"where the operators mathrmL, mathrmRI and mathrmRE perform an explicit integration of the left-hand sides, an implicit integration of the right-hand sides and an explicit integration of the right-hand sides, each over the time step indicated in its subscript, respectively. The superscripts represent various time levels between those before (n) and after (n + 1) the current time step Delta t = t^n + 1 - t^n. In mathrmL, the fourth argument is the velocity by which the prognostic variables are transported (Benacchio & Klein, 2019; Schmid et al., 2021). A complete description of the exact implementation of these steps follows here.","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"The density fluctuations are synchronized with the full density, i.e.\nrho^n = rho^n - overlinerho\nThe left-hand sides are integrated over Delta t  2 with a low-storage RK3 scheme (Williamson, 1980). Fractional implicit Euler steps are used to integrate the Rayleigh-damping terms of the LHS sponge. At every RK3 stage m, the following updates are performed.\nDensity update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(rho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerhoright)\nendalign*\nDensity-fluctuations update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 rho^m + 1\nendalign*\nWind update:\nbeginalign*\n    q^rho u m + 1  = fracDelta t2 left- mathcalA^u m n + mathcalV^u m + f left(rho vright)^mright + left(alpha_mathrmRK q^rho uright)^m\n    u^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho uright)^m + beta_mathrmRK^m q^rho u m + 1right\n    q^rho v m + 1  = fracDelta t2 left- mathcalA^v m n + mathcalV^v m - f left(rho uright)^mright + left(alpha_mathrmRK q^rho vright)^m\n    v^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho vright)^m + beta_mathrmRK^m q^rho v m + 1right\n    q^rho widehatw m + 1  = fracDelta t2 left- mathcalA^widehatw m n + mathcalV^widehatw m + G^13 f left(rho vright)^m - G^23 f left(rho uright)^mright + left(alpha_mathrmRK q^rho widehatwright)^m\n    widehatw^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho widehatwright)^m + beta_mathrmRK^m q^rho widehatw m + 1right\n    widehatboldsymbolu^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(widehatboldsymbolu^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 widehatboldsymbolu_mathrmR^m + 1right)\nendalign*\nTherein, alpha_mathrmRK^m and beta_mathrmRK^m are the RK3 coefficients, with alpha_mathrmRK^m = 0 at the first stage, and f_mathrmRK^m are the ratios between the sizes of the full time step and the RK3 substeps. The advective momentum-flux divergences are given by\nbeginalign*\n    mathcalA^u m n  = frac1J leftfracpartial J left(rho uright)^m u^npartial widehatx + fracpartial J left(rho uright)^m v^npartial widehaty + fracpartial J left(rho uright)^m widehatw^npartial widehatzright\n    mathcalA^v m n  = frac1J leftfracpartial J left(rho vright)^m u^npartial widehatx + fracpartial J left(rho vright)^m v^npartial widehaty + fracpartial J left(rho vright)^m widehatw^npartial widehatzright\n    mathcalA^widehatw m n  = G^13 mathcalA^u m n + G^23 mathcalA^v m n + frac1J^2 leftfracpartial J left(rho wright)^m u^npartial widehatx + fracpartial J left(rho wright)^m v^npartial widehaty + fracpartial J left(rho wright)^m widehatw^npartial widehatzright\nendalign*\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step. The divergence constraint is then enforced by solving a Poisson equation for Exner-pressure differences Delta pi, which are used to correct the wind, the density fluctuations and the Exner-pressure itself. The details of these substeps are as follows.\nPredictor step:\nbeginalign*\n    u^n + 1  2  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 leftu^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^u n + fracF^u n + 1rho^right)right\n    v^n + 1  2  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 leftv^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^v n + fracF^v n + 1rho^right)right\n    widehatw^n + 1  2  = left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times leftwidehatw^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^widehatw n + fracb^J + fracF^widehatw n + 1rho^right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right\n     qquad quad + leftfracoverlinerhorho^ fracleft(N Delta tright)^24 left(G^1 3 u^n + 1  2 + G^2 3 v^n + 1  2right)right\n    rho^n + 1  2  = - fracrho^g left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times left- fracoverlinerhorho^ N^2 fracDelta t2 J leftwidehatw^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^widehatw n + fracF^widehatw n + 1rho^right)rightright\n     qquad quad + left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right) b^ + fracoverlinerhorho^ N^2 fracDelta t2 J left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right)\n     qquad quad times leftleft(G^1 3 u^n + 1  2 + G^2 3 v^n + 1  2right) vphantomfracoverlinerhorho^ N^2 fracDelta t2right\nendalign*\nPoisson equation:\nbeginalign*\n     frac1J left(fracpartial J P u^n + 1  2partial widehatx + fracpartial J P v^n + 1  2partial widehaty + fracpartial J P widehatw^n + 1  2partial widehatzright)\n     quad = frac1J leftfracpartial J P C^u  n + 1partial widehatx + fracpartial J P C^v  n + 1partial widehaty vphantomleft(fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad + fracpartialpartial widehatz leftleft(1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad qquad quad times left(fracDelta t2 c_p fracJ P^2rho^ mathcalD^widehatw + J P fracoverlinerhorho^ fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad quad times leftleftleftleft(G^13 mathcalC^u  n + 1 + G^23 mathcalC^v  n + 1right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right) vphantomleft(fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1rightright\nendalign*\nCorrector step:\nbeginalign*\n    u^n + 1  2  rightarrow u^n + 1  2 - mathcalC^u  n + 1\n    v^n + 1  2  rightarrow v^n + 1  2 - mathcalC^v  n + 1\n    widehatw^n + 1  2  rightarrow widehatw^n + 1  2 - left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times leftfracDelta t2 c_p fracPrho^ mathcalD^widehatw + fracoverlinerhorho^ fracleft(N Delta tright)^24 left(G^1 3 mathcalC^u  n + 1 + G^23 mathcalC^v  n + 1right)right\n    rho^n + 1  2  rightarrow rho^n + 1  2 + fracrho^g left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times left- fracoverlinerhorho^ fracleft(N Delta tright)^24 J c_p fracPrho^ mathcalD^widehatw + fracoverlinerhorho^ N^2 fracDelta t2 J left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right)right\n     qquad quad times leftleft(G^1 3 mathcalC^u  n + 1 + G^2 3 mathcalC^v  n + 1right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right\n    pi^n + 1  2  = pi^n + Delta pi\nendalign*\nTherein, b = - g rho  rho, the pressure-difference gradient is given by\nbeginalign*\n    mathcalD^u  = left(fracpartial Delta pipartial widehatx + G^13 fracpartial Delta pipartial widehatzright)\n    mathcalD^v  = left(fracpartial Delta pipartial widehaty + G^23 fracpartial Delta pipartial widehatzright)\n    mathcalD^widehatw  = left(G^13 fracpartial Delta pipartial widehatx + G^23 fracpartial Delta pipartial widehaty + G^33 fracpartial Delta pipartial widehatzright)\nendalign*\nand the horizontal-wind correction terms are\nbeginalign*\n    mathcalC^u  n + 1  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p fracPrho^ mathcalD^u\n    mathcalC^v  n + 1  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p fracPrho^ mathcalD^v\nendalign*\nThe right-hand sides (without the Rayleigh-damping terms) are integrated over Delta t  2 with an explicit Euler step. Therein, the Exner-pressure fluctuations pi^n + 1  2 are used to compute the pressure gradient. The exact updates are\nbeginalign*\n    u^*  = u^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^u n + 1  2 + fracF^u n + 1rho^nright)\n    v^*  = v^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^v n + 1  2 + fracF^v n + 1rho^nright)\n    widehatw^*  = widehatw^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^widehatw n + 1  2 + fracb^nJ + fracF^widehatw n + 1rho^nright)\n    rho^*  = - fracrho^ng leftb^n - fracDelta t2 overlinerho N^2 left(fracwrhoright)^nright\nendalign*\nThe left-hand sides are integrated over Delta t with the low-storage RK3 scheme. Fractional implicit Euler steps are once again used to integrate the Rayleigh-damping terms of the LHS sponge. This step is equivalent to the first one, except for the differences indicated in the compact description above.\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step, followed by the Poisson equation being solved and a correction step being performed. The Rayleigh-damping terms are doubled, since they were left out in the explicit Euler step. This step is equivalent to the second one, except for the differences indicated in the compact description above.","category":"page"},{"location":"theory/numerics/#Boussinesq-mode","page":"Numerics","title":"Boussinesq mode","text":"","category":"section"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"In Boussinesq mode, the time scheme remains mostly unchanged. As has been mentioned in the description of the physics, the continuity equation is removed, as are the density fluctuations everywhere except in the auxiliary equation and the buoyancy term of the transformed-vertical-momentum equation. Furthermore, overlinerho, overlinetheta, P and N^2 are replaced with rho_0, theta_0, P_0 and N_0^2, respectively.","category":"page"},{"location":"theory/numerics/#Compressible-mode","page":"Numerics","title":"Compressible mode","text":"","category":"section"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"In compressible mode, the time scheme is changed in several ways, due to the mass-weighted potential temperature having a spatiotemporal dependence and being directly coupled to the Exner-pressure. It may be summarized by","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"beginalign*\n    1  rho^n  = rho^n - fracP^noverlinetheta\n    2  left(rho^ rho^ P^ widehatboldsymbolu^ pi^right)  = mathrmL_Delta t  2 left(rho^n rho^n P^n widehatboldsymbolu^n pi^n P^n widehatboldsymbolu^n alpha_mathrmR^n + 1right)\n    3  left(rho^n + 1  2 widehatboldsymbolu^n + 1  2 pi^n + 1  2right)  = mathrmRI_Delta t  2 left(rho^ rho^ P^ widehatboldsymbolu^ pi^ beta_mathrmR^uv n + 1 beta_mathrmR^widehatw n + 1right)\n    4  left(rho^* widehatboldsymbolu^* pi^*right)  = mathrmRE_Delta t  2 left(rho^n rho^n P^n widehatboldsymbolu^n pi^nright)\n    5  left(rho^** rho^** P^** widehatboldsymbolu^** pi^**right)  = mathrmL_Delta t left(rho^n rho^* P^n widehatboldsymbolu^* pi^n + 1  2 P^ widehatboldsymbolu^n + 1  2 alpha_mathrmR^n + 1right)\n    6  left(rho^n + 1 widehatboldsymbolu^n + 1 pi^n + 1right)  = mathrmRI_Delta t  2 left(rho^** rho^** P^** widehatboldsymbolu^** pi^** 2 beta_mathrmR^uv n + 1 2 beta_mathrmR^widehatw n + 1right)\nendalign*","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"(see Benacchio & Klein, 2019; Chew et al., 2022). Another detailed description follows here.","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"The density fluctuations are synchronized with the full density, i.e.\nrho^n = rho^n - fracP^noverlinetheta\nThe left-hand sides are integrated over Delta t  2 with the low-storage RK3 scheme. Fractional implicit Euler steps are used to integrate the Rayleigh-damping terms of the LHS sponge. The updates at every RK3 stage are as follows.\nDensity update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(rho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerhoright)\nendalign*\nDensity-fluctuations update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 leftfrac1J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + fracF^P n + 1overlinethetaright + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 leftrho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerho left1 - fracleft(P  rhoright)^m + 1overlinethetarightright\nendalign*\nMass-weighted potential-temperature update:\nbeginalign*\n    q^P m + 1  = - fracDelta t2 leftfrac1J leftfracpartial J left(P uright)^npartial widehatx + fracpartial J left(P vright)^npartial widehaty + fracpartial J left(P widehatwright)^npartial widehatzright - F^P n + 1right\n     quad + left(alpha_mathrmRK q^Pright)^m\n    P^m + 1  = P^m + beta_mathrmRK^m q^P m + 1\n    P^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 P^m + 1 left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 fracoverlinerhorho^m + 1right)\nendalign*\nWind update:\nbeginalign*\n    q^rho u m + 1  = fracDelta t2 left- mathcalA^u m n + mathcalV^u m + f left(rho vright)^mright + left(alpha_mathrmRK q^rho uright)^m\n    u^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho uright)^m + beta_mathrmRK^m q^rho u m + 1right\n    q^rho v m + 1  = fracDelta t2 left- mathcalA^v m n + mathcalV^v m - f left(rho uright)^mright + left(alpha_mathrmRK q^rho vright)^m\n    v^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho vright)^m + beta_mathrmRK^m q^rho v m + 1right\n    q^rho widehatw m + 1  = fracDelta t2 left- mathcalA^widehatw m n + mathcalV^widehatw m + G^13 f left(rho vright)^m - G^23 f left(rho uright)^mright + left(alpha_mathrmRK q^rho widehatwright)^m\n    widehatw^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho widehatwright)^m + beta_mathrmRK^m q^rho widehatw m + 1right\n    widehatboldsymbolu^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(widehatboldsymbolu^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 widehatboldsymbolu_mathrmR^m + 1right)\nendalign*\nAfter the last RK3 step, the Exner-pressure fluctuations are updated according to the Rayleigh damping applied to the mass-weighted potential temperature, i.e.\nbeginalign*\n    pi^ = pi^n - alpha_mathrmR fracDelta t2 left(P fracpartial pipartial Pright)^ left(1 - fracoverlinerhorho^right)\nendalign*\nwhere left(partial P  partial piright)^ = left(gamma - 1right)^- 1 left(R  p_mathrmrefright)^1 - gamma left(P^2 - gammaright)^, with gamma being the ratio between the specific heat capacities and constant pressure and volume, R being the specific gas constant and p_mathrmref being the reference (ground) pressure.\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step. The divergence constraint is then enforced by solving a Poisson equation for Exner-pressure differences Delta pi, which are used to correct the wind, the density fluctuations and the Exner-pressure itself. In principle, this is the same as in pseudo-incompressible mode, however, instead of widehatboldsymbolu^n + 1  2, the predictor step calculates widehatboldsymbolU^n + 1  2, which is obtained by multiplying the equation with P^. The details are as follows.\nPredictor step:\nbeginalign*\n    U^n + 1  2  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 leftleft(P uright)^ + fracDelta t2 left- c_p left(fracP^2rhoright)^ mathcalP^u n + left(fracPrhoright)^ F^u n + 1rightright\n    V^n + 1  2  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 leftleft(P vright)^ + fracDelta t2 left- c_p left(fracP^2rhoright)^ mathcalP^v n + left(fracPrhoright)^ F^v n + 1rightright\n    widehatW^n + 1  2  = left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times leftleft(P widehatwright)^ + fracDelta t2 left- c_p left(fracP^2rhoright)^ mathcalP^widehatw n + fracleft(P bright)^J + left(fracPrhoright)^ F^widehatw n + 1rightright\n     qquad quad + leftfracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24 leftG^1 3 U^n + 1  2 + G^2 3 V^n + 1  2rightright\n    rho^n + 1  2  = - fracrho^g left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times left- fracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J leftwidehatw^ + fracDelta t2 left(- c_p left(fracPrhoright)^ mathcalP^widehatw n + fracF^widehatw n + 1rho^right)rightright\n     qquad quad  + left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right) b^ + fracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right)\n     qquad quad times leftleft(G^1 3 fracU^n + 1  2P^ + G^2 3 fracV^n + 1  2P^right) vphantomleftleft(left(fracPrhoright)^right)rightright\nendalign*\nPoisson equation:\nbeginalign*\n     frac1J leftfracpartial J U^n + 1  2partial widehatx + fracpartial J V^n + 1  2partial widehaty + fracpartial J widehatW^n + 1  2partial widehatzright - F^P n + 1\n     quad = - left(fracpartial Ppartial piright)^ frac2 Delta piDelta t\n     qquad + frac1J leftfracpartial J P^ C^u  n + 1partial widehatx + fracpartial J P^ C^v  n + 1partial widehaty vphantomleftleft(fracleft(P   rhoright)^overlinethetaright)^- 1rightright\n     qquad qquad quad + fracpartialpartial widehatz leftleft(1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad qquad qquad times left(fracDelta t2 J c_p left(fracP^2rhoright)^ mathcalD^widehatw + J fracleft(P^2   rhoright)^overlinetheta fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad qquad times leftleftleftleft(G^13 mathcalC^u  n + 1 + G^23 mathcalC^v  n + 1right)vphantomleft(fracP^2rhoright)^right) vphantomleft(fracleft(P   rhoright)^overlinethetaright)^- 1rightright\nendalign*\nCorrector step:\nbeginalign*\n    u^n + 1  2  = left(P^- 1right)^ left(U^n + 1  2 - P^ mathcalC^u  n + 1right)\n    v^n + 1  2  = left(P^- 1right)^ left(V^n + 1  2 - P^ mathcalC^v  n + 1right)\n    widehatw^n + 1  2  = left(P^- 1right)^ leftwidehatW^n + 1  2 - left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1right\n     qquad qquad qquad times leftfracDelta t2 c_p left(fracP^2rhoright)^ mathcalD^widehatw + fracleft(P^2   rhoright)^overlinetheta fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad times leftleftleft(G^1 3 mathcalC^u  n + 1 + G^23 mathcalC^v  n + 1right) vphantomleft(fracP^2rhoright)^right vphantomleftfracleft(P   rhoright)^overlinethetaright^- 1right\n    rho^n + 1  2  rightarrow rho^n + 1  2 + fracrho^g left1 + beta_mathrmR^widehatw n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times left- fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24 J c_p left(fracPrhoright)^ mathcalD^widehatwright\n     qquad quad + leftfracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J left(1 + beta_mathrmR^widehatw n + 1 fracDelta t2right)  left(G^1 3 mathcalC^u  n + 1 + G^2 3 mathcalC^v  n + 1right)right\n    pi^n + 1  2  = pi^n + Delta pi\nendalign*\nThe horizontal-wind correction terms are given by\nbeginalign*\n    mathcalC^u  n + 1  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p left(fracPrhoright)^ mathcalD^u\n    mathcalC^v  n + 1  = left(1 + beta_mathrmR^uv n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p left(fracPrhoright)^ mathcalD^v\nendalign*\nThe right-hand sides (without the Rayleigh-damping terms) are integrated over Delta t  2 with an explicit Euler step. In contrast to the pseudo-incompressible mode, the Exner-pressure fluctuations pi^n are used to compute the pressure gradient. They are themselves also updated with the left-hand side of the prognostic equation for P. Thus, one has\nbeginalign*\n    u^*  = left(P^- 1right)^n leftleft(P uright)^n + fracDelta t2 left- c_p left(fracP^2rhoright)^n mathcalP^u n + left(fracPrhoright)^n F^u n + 1rightright\n    v^*  = left(P^- 1right)^n leftleft(P vright)^n + fracDelta t2 left- c_p left(fracP^2rhoright)^n mathcalP^v n + left(fracPrhoright)^n F^v n + 1rightright\n    widehatw^*  = left(P^- 1right)^n leftleft(P widehatwright)^n + fracDelta t2 left- c_p left(fracP^2rhoright)^n mathcalP^widehatw n + fracleft(P bright)^nJ + left(fracPrhoright)^n F^widehatw n + 1rightright\n    rho^*  = - fracrho^ng leftb^n - fracDelta t2 N^2 fracleft(P w  rhoright)^noverlinethetaright\n    pi^*  = pi^n - fracDelta t2 left(fracpartial pipartial Pright)^n leftfrac1J leftfracpartial J left(P uright)^npartial widehatx + fracpartial J left(P vright)^npartial widehaty + fracpartial J left(P widehatwright)^npartial widehatzright - F^P n + 1right\nendalign*\nThe left-hand sides are integrated over Delta t with the low-storage RK3 scheme. Fractional implicit Euler steps are once again used to integrate the Rayleigh-damping terms of the LHS sponge. This step is equivalent to the first one, except for the differences indicated in the compact description above.\nThe right-hand sides are integrated over over Delta t  2 with an implicit Euler step, followed by the Poisson equation being solved and a correction step being performed. The Rayleigh-damping terms are doubled, since they were left out in the explicit Euler step. This step is equivalent to the second one, except for the differences indicated in the compact description above.","category":"page"},{"location":"theory/numerics/#MSGWaM","page":"Numerics","title":"MSGWaM","text":"","category":"section"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"At the beginning of each time step, the saturation scheme is applied via integration of the respective term in the phase-space wave-action density equation with an explicit Euler step. i.e.","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"mathcalN^n + 1 = mathcalN^n + Delta t mathcalS_s^n","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"The ray equations are then integrated with the low-storage RK3 scheme, following","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"beginalign*\n    q^x m + 1  = Delta t fracpartial Omega^m npartial k + alpha_mathrmRK^m q^x m  x^m + 1  = x^m + beta_mathrmRK^m q^x m + 1\n    q^y m + 1  = Delta t fracpartial Omega^m npartial l  + alpha_mathrmRK^m q^y m  y^m + 1  = y^m + beta_mathrmRK^m q^y m + 1\n    q^z m + 1  = Delta t fracpartial Omega^m npartial m + alpha_mathrmRK^m q^z m  z^m + 1  = z^m + beta_mathrmRK^m q^z m + 1\n    q^k m + 1  = Delta t left(fracpartial Omega^m npartial widehatx + G^13 fracpartial Omega^m npartial widehatzright) + alpha_mathrmRK^m q^k m  k^m + 1  = k^m + beta_mathrmRK^m q^k m + 1\n    q^l m + 1  = Delta t left(fracpartial Omega^m npartial widehaty + G^23 fracpartial Omega^m npartial widehatzright) + alpha_mathrmRK^m q^l m  l^m + 1  = l^m + beta_mathrmRK^m q^l m + 1\n    q^m m + 1  = fracDelta tJ fracpartial Omega^m npartial widehatz + alpha_mathrmRK^m q^m m  m^m + 1  = m^m + beta_mathrmRK^m q^m m + 1\nendalign*","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"where Omega^m n = Omega left(boldsymbolx^m boldsymbolk^m widehatboldsymbolu^nright). At the end of every RK3 stage, the Rayleigh damping of the LHS sponge is applied to the phase-space wave-action density with a fractional implicit Euler step, i.e.","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"mathcalN^n + 1 rightarrow left(1 + 2 alpha_mathrmR^n + 1 f_mathrmRK^m Delta tright)^- 1 mathcalN^n + 1","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"Note that the intrinsic frequency does not need to be updated since it is completely determined the other variables. Finally, the mean-flow tendencies for the current time step are calculated from the updated wave-property fields (Jochum et al., 2025).","category":"page"},{"location":"theory/numerics/#Spatial-discretization","page":"Numerics","title":"Spatial discretization","text":"","category":"section"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"PinCFlow is a finite-volume code that operates on a three-dimensional staggered C-grid (Arakawa & Lamb, 1977), with scalar fields defined at the cell centers and velocity components defined at the respective interfaces (Rieper et al., 2013). Advective-flux divergences are discretized with a monotone upwind scheme for conservation laws (van Leer, 2003) and a monotonized-centered variant limiter (e.g. Kemm, 2010). More specifically, the implementation is such that P widehatboldsymbolu is the carrier flux (based on Klein, 2009; Benacchio et al., 2014; Smolarkiewicz et al., 2014 and Benacchio & Klein, 2019). All other terms are discretized with centered differences (e.g. Durran, 2010). A Cartesian version of this is described in Rieper et al. (2013) and Schmid et al. (2021).","category":"page"},{"location":"theory/numerics/","page":"Numerics","title":"Numerics","text":"The spatial discretization of MSGWaM is based on the definition of ray volumes, six-dimensional cubes in phase space. The ray equations are integrated at the center points and surface midpoints, using trilinear interpolation to get mean-flow information at the locations of interest. To prevent uninhibited growing, ray volumes are split when their extent in any dimension of physical space exceeds the corresponding grid spacing. This is counteracted by merging in spectral space to keep the number of ray volumes below a user-defined threshold. In the computation of the mean-flow impact, the contribution of each ray volume is weighted by the fraction of the local grid cell covered by it. A more detailed description of the algorithm can be found in Muraschko et al. (2014), Boeloeni et al. (2016), Wilhelm et al. (2018), Wei et al. (2019) and Jochum et al. (2025).","category":"page"},{"location":"reference/pincflow/#PinCFlow","page":"PinCFlow","title":"PinCFlow","text":"","category":"section"},{"location":"reference/pincflow/#PinCFlow.PinCFlow","page":"PinCFlow","title":"PinCFlow.PinCFlow","text":"PinCFlow\n\nMain module of PinCFlow.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Integration\n\n\n\n\n\n","category":"module"},{"location":"reference/pincflow/#PinCFlow.set_plot_style","page":"PinCFlow","title":"PinCFlow.set_plot_style","text":"set_plot_style()\n\nConfigure PythonPlot.jl to use a preset plot style.\n\n\n\n\n\n","category":"function"},{"location":"reference/pincflow/#PinCFlow.symmetric_contours","page":"PinCFlow","title":"PinCFlow.symmetric_contours","text":"symmetric_contours(\n    minimum::AbstractFloat,\n    maximum::AbstractFloat;\n    number::Integer = 10,\n    colormap_name::String = \"seismic\",\n)::Tuple{<:LinRange{<:AbstractFloat, <:Integer}, <:Any}\n\nCompute symmetric contours levels and return them and a correspondingly cropped colormap.\n\nArguments\n\nminimum: Smallest value to be plotted.\nmaximum: Largest value to be plotted.\n\nKeywords\n\nnumber: Number of contour levels.\ncolormap_name: Name under which the chosen colormap is registered.\n\n\n\n\n\n","category":"function"},{"location":"reference/pincflow/#PinCFlow.@ivy","page":"PinCFlow","title":"PinCFlow.@ivy","text":"@ivy(x::Expr)\n\nReturn the expression x with @inbounds and @views in front of it.\n\n\n\n\n\n","category":"macro"},{"location":"reference/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"reference/integration/#PinCFlow.Integration","page":"Integration","title":"PinCFlow.Integration","text":"Integration\n\nModule for integration of the full system.\n\nProvides helper functions for computing the time step, managing time levels and synchronizing fields, as well as the main function for running PinCFlow.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.Update\nPinCFlow.PoissonSolver\nPinCFlow.FluxCalculator\nPinCFlow.Output\nPinCFlow.MSGWaM\n\n\n\n\n\n","category":"module"},{"location":"reference/integration/#PinCFlow.Integration.backup_predictands","page":"Integration","title":"PinCFlow.Integration.backup_predictands","text":"backup_predictands(state::State)::Tuple{<:Predictands, <:TracerPredictands}\n\nReturn a tuple with a copy of the predictands and tracer predictands.\n\nArguments\n\nstate: Model state\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.compute_time_step","page":"Integration","title":"PinCFlow.Integration.compute_time_step","text":"compute_time_step(state::State)::AbstractFloat\n\nCompute and return an adaptive time step based on several stability criteria.\n\nIf state.namelists.discretization.adaptive_time_step is set to true, the returned time step is given by\n\nDelta t = min left(Delta t_mathrmCFL Delta t_mathrmWKB Delta t_mathrmviscous Delta t_maxright)\n\nwhere Delta t_mathrmCFL and Delta t_mathrmWKB are computed from CFL conditions with respect to the resolved flow and unresolved gravity waves, respectively, Delta t_mathrmviscous is determined from a von Neumann condition that takes the viscosity into account and Delta t_max is an upper limit specified in state.namelists.discretization. Otherwise, the returned time step is equal to Delta t_max. If Delta t is smaller than Delta t_min (also specified in state.namelists.discretization), an error is thrown.\n\nThe individual stability criteria are as follows.\n\nCFL condition with respect to the resolved flow (where w is computed with compute_vertical_wind):\nDelta t_mathrmCFL = mu_mathrmCFL minlimits_mathrmglobal leftfracDelta widehatxu_max fracDelta widehatyv_max min left(fracJ Delta widehatzwright)right\nCFL condition with respect to the group velocities of unresolved gravity waves (where J_min is the minimum Jacobian in a one-grid-cell radius and c_mathrmg z is the maximum vertical group velocity within a grid cell):\nDelta t_mathrmWKB = mu_mathrmWKB minlimits_mathrmglobal leftfracDelta widehatxc_mathrmg x max fracDelta widehatyc_mathrmg y max min left(fracJ_min Delta widehatzc_mathrmg zright)right\nVon Neumann condition (with mathrmRe being the Reynolds number):\nDelta t_mathrmviscous = fracmathrmRe2 minlimits_mathrmglobal leftleft(Delta widehatxright)^2 left(Delta widehatyright)^2 left(J Delta widehatzright)^2right\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.explicit_integration!","page":"Integration","title":"PinCFlow.Integration.explicit_integration!","text":"explicit_integration!(\n    state::State,\n    p0::Predictands,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    side::LHS,\n)\n\nIntegrate the left-hand sides of the prognostic equations with a Runge-Kutta time step.\n\nAt each Runge-Kutta stage, the prognostic variables are first reconstructed and their advective and diffusive fluxes are calculated. Subsequently, each variable is updated with its integrated left-hand side, followed immediately by an implicit Euler step (the size of which is the fractional time step at the current Runge-Kutta stage) that accounts for the Rayleigh-damping imposed by the LHS sponge. After the Runge-Kutta loop, if the atmosphere is compressible, the Exner-pressure is updated with a full implicit Euler step to account for it being impacted by the Rayleigh damping of the mass-weighted potential temperature.\n\nexplicit_integration!(\n    state::State,\n    p0::Predictands,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    side::RHS,\n)\n\nPerform an explicit Euler step on the right-hand sides of the prognostic equations and, if the atmosphere is compressible, update the Exner-pressure such that it is synchronized with the mass-weighted potential temperature.\n\nArguments\n\nstate: Model state.\np0: The predictands that are used to compute the transporting velocities in the computation of the fluxes.\ndtstage: Fractional time step.\ntime: Simulation time.\nside: Side of the equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.implicit_integration!","page":"Integration","title":"PinCFlow.Integration.implicit_integration!","text":"implicit_integration!(\n    state::State,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    ntotalbicg::Integer,\n    side::RHS,\n    rayleigh_factor::AbstractFloat,\n    iout::Integer,\n    machine_start_time::DateTime,\n)\n\nPerform an implicit Euler step on the right-hand sides of the prognostic equations, solve the Poisson equation and correct the Exner-pressure, momentum and density fluctuations accordingly.\n\nArguments\n\nstate: Model state.\ndtstage: Fractional time step.\ntime: Simulation time.\nntotalbicg: BicGStab-iterations counter.\nside: Side of the equations.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\niout: Output counter.\nmachine_start_time: Wall-clock start time.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.integrate","page":"Integration","title":"PinCFlow.Integration.integrate","text":"integrate(namelists::Namelists)\n\nInitialize the model state and integrate it in time.\n\nThis method performs the complete time integration of the governing equations, using a semi-implicit time stepping scheme. It handles initialization, time stepping and output of the simulation data.\n\nThe initialization begins with the construction of the model state (an instance of the composite type State), which involves the setup of the MPI parallelization and the definition of all arrays that are needed repeatedly during the simulation. This is followed by an (optional) initial cleaning, in which the Poisson solver is called to ensure that the initial dynamic fields satisfy the divergence constraint imposed by the thermodynamic energy equation. Afterwards, the initialization of MSGWaM is completed by adding ray volumes to the previously defined arrays. If the simulation is supposed to start from a previous model state, the fields are then overwritten with the data in the corresponding input file. Finally, the output file is created and the initial state is written into it.\n\nAt the beginning of each time-loop iteration, the time step is determined from several stability criteria, using compute_time_step. In case the updated simulation time is later than the next output time, the time step is corrected accordingly. Subsequently, the damping coefficients of the sponges (which may depend on the time step) are calculated. Following this, MSGWaM updates the unresolved gravity-wave field and computes the corresponding mean-flow impact. Afterwards, the resolved flow is updated in a semi-implicit time step, comprised of the following stages.\n\nExplicit RK3 integration of LHS over Delta t  2.\nImplicit Euler integration of RHS over Delta t  2.\nExplicit Euler integration of RHS over Delta t  2.\nExplicit RK3 integration of LHS over Delta t.\nImplicit Euler integration of RHS over Delta t  2.\n\nTherein, the left-hand sides of the equations include advective fluxes, diffusion terms, rotation and heating, whereas the pressure gradient, buoyancy term and momentum-flux divergence due to unresolved gravity waves are on the right-hand sides. Boundary conditions are enforced continuously. At the end of the time step, the updated fields are written into the output file if the next output time has been reached.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\nSee also\n\nPinCFlow.Types.State\nPinCFlow.Integration.modify_compressible_wind!\nPinCFlow.Boundaries.set_boundaries!\nPinCFlow.PoissonSolver.apply_corrector!\nPinCFlow.Output.create_output\nPinCFlow.Output.write_output\nPinCFlow.MSGWaM.RayUpdate.initialize_rays!\nPinCFlow.Output.read_input!\nPinCFlow.Integration.synchronize_compressible_atmosphere!\nPinCFlow.Integration.compute_time_step\nPinCFlow.Update.compute_sponges!\nPinCFlow.Integration.wkb_integration!\nPinCFlow.Integration.synchronize_density_fluctuations!\nPinCFlow.Integration.explicit_integration!\nPinCFlow.Integration.implicit_integration!\nPinCFlow.Integration.reset_predictands!\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.modify_compressible_wind!","page":"Integration","title":"PinCFlow.Integration.modify_compressible_wind!","text":"modify_compressible_wind!(state::State, operation::Function)\n\nModify the wind with J P if the atmosphere is compressible by dispatching to the appropriate method.\n\nmodify_compressible_wind!(\n    state::State,\n    operation::Function,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes.\n\nmodify_compressible_wind!(\n    state::State,\n    operation::Function,\n    model::Compressible,\n)\n\nInterpolate J P to the wind grids and replace the wind components with the result of applying operation to them and the interpolations.\n\nArguments\n\nstate: Model state.\noperation: Binary operation used for modification.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.reset_predictands!","page":"Integration","title":"PinCFlow.Integration.reset_predictands!","text":"reset_predictands!(\n    state::State,\n    predictands::Predictands,\n    tracerpredictands::TracerPredictands,\n)\n\nReset fields in state to those in predictands and tracerpredictands by dispatching to specific methods.\n\nreset_predictands!(state::State, tracerpredictands::TracerPredictands)\n\nReset fields in state.tracer.tracerpredictands to those in tracerpredictands.\n\nreset_predictands!(state::State, predictands::Predictands, model::AbstractModel)\n\nReset the density, density fluctuations and wind components in state.variables.predictands to those in predictands.\n\nreset_predictands!(state::State, predictands::Predictands, model::Compressible)\n\nReset the density, density fluctuations, wind components, Exner pressure and mass-weighted potential temperature (i.e. all fields) in state.variables.predictands to those in predictands.\n\nArguments\n\nstate: Model state.\npredictands: Fields to reset to.\ntracerpredictands: Tracer fields to reset to.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.save_backups!","page":"Integration","title":"PinCFlow.Integration.save_backups!","text":"save_backups!(state::State, variables::Vararg{Symbol})\n\nCopy the specified fields in state.variables.predictands to their counterparts in state.variables.backups.\n\nArguments\n\nstate: Model state.\nvariables: Names of the fields to create backups of.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.synchronize_compressible_atmosphere!","page":"Integration","title":"PinCFlow.Integration.synchronize_compressible_atmosphere!","text":"synchronize_compressible_atmosphere!(state::State, predictands::Predictands)\n\nSynchronize state.atmosphere.pstrattfc with predictands.p if the atmosphere is compressible by dispatching to the appropriate method.\n\nsynchronize_compressible_atmosphere!(\n    state::State,\n    predictands::Predictands,\n    model::AbstractModel,\n)\n\nReturn in non-compressible modes.\n\nsynchronize_compressible_atmosphere!(\n    state::State,\n    predictands::Predictands,\n    model::Compressible,\n)\n\nSynchronize state.atmosphere.pstrattfc with predictands.p.\n\nIn compressible mode, P is time-dependent. In the update of P, only state.variables.predictands.p is changed, so that the old values of P are retained in the respective field of state.atmosphere. When these are no longer needed, this method is used to update the field accordingly.\n\nArguments\n\nstate: Model state.\npredictands: Predictands to use for the synchronization of the mass-weighted potential temperature.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.synchronize_density_fluctuations!","page":"Integration","title":"PinCFlow.Integration.synchronize_density_fluctuations!","text":"synchronize_density_fluctuations!(state::State)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho by dispatching to a model-specific method.\n\nsynchronize_density_fluctuations!(state::State, model::Boussinesq)\n\nReturn in Boussinesq mode.\n\nIn Boussinesq mode, density fluctuations don't require synchronization, since the density is assumed constant except in the buoyancy equation.\n\nsynchronize_density_fluctuations!(state::State, model::PseudoIncompressible)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho.\n\nThe density fluctuations are defined as the product of the mass-weighted potential temperature and the fluctuations of the inverse potential temperature. In pseudo-incompressible mode, P is constant, so that this is reduced to the difference between rho and overlinerho, i.e.\n\nrho = fracPtheta - fracPoverlinetheta = rho - overlinerho\n\nsynchronize_density_fluctuations!(state::State, model::Compressible)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho.\n\nIn compressible mode, P is time-dependent, so that the density fluctuations are not reduced to the difference between rho and overlinerho, i.e.\n\nrho = fracPtheta - fracPoverlinetheta = rho - fracPoverlinetheta\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.wkb_integration!","page":"Integration","title":"PinCFlow.Integration.wkb_integration!","text":"wkb_integration!(state::State, dtstage::AbstractFloat)\n\nUse MSGWaM to update the properties of the unresolved gravity-wave field and compute its impact on the resolved flow.\n\nIn the first step, MSGWaM's saturation scheme is applied to account for the impact of wave breaking on the wave-action field. Next, the ray volumes are propagated via integration of the ray equations with a Runge-Kutta time step. Ray volumes that have grown larger than the cells of the model grid are then split before their array positions are shifted such that they are attributed to the correct grid cells. Afterwards, ray volumes are merged in cells where their count exceeds a specified threshold. Finally, the ray volumes in boundary and halo cells are updated and the mean-flow impact is calculated.\n\nArguments\n\nstate: Model state.\ndtstage: Time step.\n\n\n\n\n\n","category":"function"},{"location":"theory/physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"theory/physics/#Coordinate-system","page":"Physics","title":"Coordinate system","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"PinCFlow uses a height-based terrain-following coordinate system (Gal-Chen & Somerville, 1975) with vertical stretching. The transformation from the Cartesian system boldsymbolx = left(x y zright)^mathrmT to the model's system widehatboldsymbolx = left(widehatx widehaty widehatzright)^mathrmT is given by","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    widehatz  = widehatz left(widetildezright)  left(widehatx widehaty widetildezright)  = left(x y L_z fracz - hL_z - hright)   left(x y zright)  = left(widehatx widehaty fracL_z - hL_zwidetildez + hright)\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where L_z is the vertical extent of the model domain and h is the surface topography. The contravariant basis vectors of the transformed system are","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    boldsymbolepsilon^widehatx  = boldsymbole^x  boldsymbolepsilon^widehaty  = boldsymbole^y  boldsymbolepsilon^widehatz = fracpartial hpartial widehatx fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez boldsymbole^x + fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez boldsymbole^y + fracL_zL_z - h fracpartial widehatzpartial widetildezboldsymbole^z\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The scalar products of these yield the metric tensor","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"G^mu nu = beginpmatrix\n    1  0  fracpartial hpartial x fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez\n    0  1  fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez\n    fracpartial hpartial x fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez  fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez  leftleft(fracL_zL_z - hright)^2 + left(fracwidetildez - L_zL_z - hright)^2 leftleft(fracpartial hpartial xright)^2 + left(fracpartial hpartial yright)^2rightright left(fracpartial widehatzpartial widetildezright)^2\nendpmatrix","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"from which the Jacobian","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"J = fracL_z - h L_z fracpartial widetildezpartial widehatz","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"can be determined. Finally, the transformation rule for the wind reads","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"left(widehatu widehatv widehatwright) = left(u v G^13 u + G^23 v + J^- 1 wright)","category":"page"},{"location":"theory/physics/#Pseudo-incompressible-equations","page":"Physics","title":"Pseudo-incompressible equations","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The atmosphere is decomposed into a hydrostatic background and deviations from it, specifically","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    pi left(boldsymbolx tright)  = overlinepi left(zright) + pi left(boldsymbolx tright)\n    theta left(boldsymbolx tright)  = overlinetheta left(zright) + theta left(boldsymbolx tright)\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where pi, theta and t denote the Exner-pressure, potential temperature and time, respectively, and the background satisfies","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    overlinepi left(0right) = 1  fracmathrmd overlinepimathrmd z = - fracgc_p overlinetheta^- 1\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"with g and c_p being the gravitational acceleration and specific heat capacity at constant presssure, respectively (Benacchio & Klein, 2019). Using this decomposition, the model equations in pseudo-incompressible mode are written as","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    fracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + alpha_mathrmR left(rho - overlinerhoright)  = 0\n    fracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + alpha_mathrmR rho  = fracN^2 overlinerho wg\n    frac1J left(fracpartial J P upartial widehatx + fracpartial J P vpartial widehaty + fracpartial J P widehatwpartial widehatzright)  = 0\n    fracpartial rho upartial t + mathcalA^u - mathcalV^u - f rho v + alpha_mathrmR left(u - u_mathrmRright)  = - c_p P mathcalP^u - beta_mathrmR^uv rho u + F^u\n    fracpartial rho vpartial t + mathcalA^v - mathcalV^v + f rho u + alpha_mathrmR left(v - v_mathrmRright)  = - c_p P mathcalP^v - beta_mathrmR^uv rho v + F^v\n    fracpartial rho widehatwpartial t + mathcalA^widehatw - mathcalV^widehatw - G^13 f rho v + G^23 f rho u + alpha_mathrmR left(widehatw - widehatw_mathrmRright)  = - c_p P mathcalP^widehatw - fracg rhoJ - beta_mathrmR^widehatw rho widehatw + F^widehatw\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where rho left(boldsymbolx tright) = overlinerho left(zright) + rho left(boldsymbolx tright) is the density, P = rho theta = overlinerho overlinetheta is the mass-weighted potential temperature, N^2 = left(g  overlinethetaright) left(mathrmd overlinetheta  mathrmd zright) is the squared buoyancy frequency and f = f_0 is the Coriolis frequency. On the left-hand sides, alpha_mathrmR and left(u_mathrmR v_mathrmR widehatw_mathrmRright)^mathrmR represent the Rayleigh-damping coefficient of a customizable sponge and the transformed wind that is to be obtained via the relaxation in it. In contrast, the Rayleigh-damping coefficients beta_mathrmR^uv and beta_mathrmR^widehatw on the right-hand side implement a preset sponge. The terms left(F^u F^v F^widehatwright)^mathrmT represent volume forces in the momentum equation, e.g. drag imposed by unresolved gravity waves. The advective momentum-flux divergences are given by","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    mathcalA^u  = frac1J left(fracpartial J rho u upartial widehatx + fracpartial J rho u vpartial widehaty + fracpartial J rho u widehatwpartial widehatzright)\n    mathcalA^v  = frac1J left(fracpartial J rho v upartial widehatx + fracpartial J rho v vpartial widehaty + fracpartial J rho v widehatwpartial widehatzright)\n    mathcalA^widehatw  = G^13 mathcalA^u + G^23 mathcalA^v + frac1J^2 left(fracpartial J rho w upartial widehatx + fracpartial J rho w vpartial widehaty + fracpartial J rho w widehatwpartial widehatzright)\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"and the viscous-flux divergences are","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    mathcalV^u  = frac1J left(fracpartial J widehatPi^11partial widehatx + fracpartial J widehatPi^12partial widehaty + fracpartial J widehatPi^13partial widehatzright)\n    mathcalV^v  = frac1J left(fracpartial J widehatPi^21partial widehatx + fracpartial J widehatPi^22partial widehaty + fracpartial J widehatPi^23partial widehatzright)\n    mathcalV^widehatw  = G^13 mathcalV^u + G^23 mathcalV^v + frac1J^2 leftfracpartial J Pi^31partial widehatx + fracpartial J Pi^32partial widehaty + fracpartialpartial widehatz left(J G^13 Pi^13 + J G^23 Pi^23 + Pi^33right)right\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"Therein, the elements of the (symmetric) transformed viscous-stress tensor are","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    widehatPi^11  = Pi^11\n    widehatPi^12  = Pi^12\n    widehatPi^22  = Pi^22\n    widehatPi^13  = G^13 Pi^11 + G^23 Pi^12 + frac1J Pi^13\n    widehatPi^23  = G^13 Pi^12 + G^23 Pi^22 + frac1J Pi^23\n    widehatPi^33  = left(G^13right)^2 Pi^11 + left(G^23right)^2 Pi^22 + frac1J^2 Pi^33 + 2 left(G^13 G^23 Pi^12 + fracG^13J Pi^13 + fracG^23J Pi^23right)\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"and those of its Cartesian counterpart are","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    Pi^11  = eta left2 left(fracpartial upartial widehatx + G^13 fracpartial upartial widehatzright) - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)right\n    Pi^12  = eta left(fracpartial upartial widehaty + G^23 fracpartial upartial widehatz + fracpartial vpartial widehatx + G^13 fracpartial vpartial widehatzright)\n    Pi^13  = eta left(frac1J fracpartial upartial widehatz + fracpartial wpartial widehatx + G^13 fracpartial wpartial widehatzright)\n    Pi^22  = eta left2 left(fracpartial vpartial widehaty + G^23 fracpartial vpartial widehatzright) - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)right\n    Pi^23  = eta left(frac1J fracpartial vpartial widehatz + fracpartial wpartial widehaty + G^23 fracpartial wpartial widehatzright)\n    Pi^33  = eta leftfrac2J fracpartial wpartial widehatz - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)right\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where eta is the dynamic shear viscosity. Finally, the components of the pressure gradient are given by","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    mathcalP^u  = left(fracpartial pipartial widehatx + G^13 fracpartial pipartial widehatzright)\n    mathcalP^v  = left(fracpartial pipartial widehaty + G^23 fracpartial pipartial widehatzright)\n    mathcalP^widehatw  = left(G^13 fracpartial pipartial widehatx + G^23 fracpartial pipartial widehaty + G^33 fracpartial pipartial widehatzright)\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"(see Rieper et al., 2013; Schmid et al., 2021).","category":"page"},{"location":"theory/physics/#Boussinesq-equations","page":"Physics","title":"Boussinesq equations","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"In Boussinesq mode, the continuity equation is removed and the density fluctuations are set to zero everywhere except in the auxiliary equation and the buoyancy term of the transformed-vertical-momentum equation. Moreover, overlinerho, overlinetheta, P and N^2 are replaced with the constant reference values rho_0, theta_0, P_0 and N_0^2.","category":"page"},{"location":"theory/physics/#Compressible-equations","page":"Physics","title":"Compressible equations","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"In compressible mode, the identity P = overlinerho overlinetheta no longer holds, i.e. the mass-weighted potential temperature has a spatiotemporal dependence. The divergence constraint is thus replaced with the prognostic equation","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"fracpartial Ppartial t + frac1J left(fracpartial J P upartial widehatx + fracpartial J P vpartial widehaty + fracpartial J P widehatwpartial widehatzright) - F^P + alpha_mathrmR P left(1 - fracoverlinerhorhoright) = 0","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where the volume force F^P represents a diabatic heating (e.g. due to unresolved gravity waves) that is not allowed in pseudo-incompressible mode. This term must also be represented in the auxiliary equation, which now reads","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"fracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + fracF^Poverlinetheta + alpha_mathrmR leftrho - overlinerho left(1 - fracPrho overlinethetaright)right = fracN^2 P wg overlinetheta","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"Note that in addition to the new volume-force term, overlinerho has been replaced with P  overlinetheta, which is due to the density fluctuations being defined as rho = rho - P  overlinetheta (Benacchio & Klein, 2019).","category":"page"},{"location":"theory/physics/#MSGWaM","page":"Physics","title":"MSGWaM","text":"","category":"section"},{"location":"theory/physics/#3D-transient-theory","page":"Physics","title":"3D transient theory","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The gravity-wave dispersion relation is written as omega left(boldsymbolx tright) = Omega leftboldsymbolx t boldsymbolk left(boldsymbolx tright)right, where in","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"Omega left(boldsymbolx t boldsymbolkright) = boldsymbolk cdot boldsymbolu_mathrmb pm sqrtfracN^2 left(zright) left(k^2 + l^2right) + f^2 m^2leftboldsymbolkright^2","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"the spatiotemporal dependence is split into an explicit part due to variations in the (resolved) background wind boldsymbolu_mathrmb = left(u_mathrmb v_mathrmb 0right)^mathrmT and the squared buoyancy frequency N^2, and an implicit part due to variations in the wavevector boldsymbolk = left(k l mright)^mathrmT. Using this decomposition, the eikonal equations are written as","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    dotomega  = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrixright omega = fracpartial Omegapartial t\ndotboldsymbolk  = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrixright boldsymbolk = beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrix Omega\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"They are integrated along rays defined by the group velocity","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    dotboldsymbolx = boldsymbolc_mathrmg = boldsymbolnabla_boldsymbolk Omega\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where boldsymbolnabla_boldsymbolk = left(partial_k partial_l partial_mright)^mathrmT. The gravity-wave energy is encoded in the phase-space wave-action density, which is governed by the equation","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"dotmathcalN = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrix + dotboldsymbolk cdot boldsymbolnabla_boldsymbolkright mathcalN = sumlimits_s mathcalS_s","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where mathcalS_s are sinks and sources. This latter equation is integrated along rays defined by left(dotboldsymbolx dotboldsymbolkright)^mathrmT, so that mathcalN is conserved if the right-hand side is zero. The impact of the unresolved gravity waves on the resolved flow is given by","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        J^- 1 partial_widehatz\n    endpmatrix cdot beginpmatrix\n        M_uu\n        M_uv\n        M_uw\n    endpmatrix + E_u\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        J^- 1 partial_widehatz\n    endpmatrix cdot beginpmatrix\n        M_uv\n        M_vv\n        M_vw\n    endpmatrix + E_v\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = - rho_mathrmb beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n    endpmatrix cdot beginpmatrix\n        T_u\n        T_v\n    endpmatrix\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where rho_mathrmb, widehatboldsymbolu_mathrmb = left(u_mathrmb v_mathrmb widehatw_mathrmbright)^mathrmT and P_mathrmb are the resolved density, transformed wind and mass-weighted potential temperature, respectively, and","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    M_uu  = overlinerho int leftk widehatc_mathrmg x - mathrmsgn left(leftfrightright) frack widehatc_mathrmg x + l widehatc_mathrmg y1 - left(widehatomega  fright)^2right mathcalN  mathrmd V_boldsymbolk\n    M_uv  = overlinerho int l widehatc_mathrmg x mathcalN  mathrmd V_boldsymbolk\n    M_uw  = overlinerho int frack widehatc_mathrmg z1 - left(f  widehatomegaright)^2 mathcalN  mathrmd V_boldsymbolk\n    M_vv  = overlinerho int leftl widehatc_mathrmg y - mathrmsgn left(leftfrightright) frack widehatc_mathrmg x + l widehatc_mathrmg y1 - left(widehatomega  fright)^2right mathcalN  mathrmd V_boldsymbolk\n    M_vw  = overlinerho int fracl widehatc_mathrmg z1 - left(f  widehatomegaright)^2 mathcalN  mathrmd V_boldsymbolk\n    T_u  = fracfg overlinetheta int fracl m N^2widehatomega leftboldsymbolkright^2 mathcalN  mathrmd V_boldsymbolk\n    T_v  = - fracfg overlinetheta int frack m N^2widehatomega leftboldsymbolkright^2 mathcalN  mathrmd V_boldsymbolk\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"with widehatomega = omega - boldsymbolk cdot boldsymbolu_mathrmb, widehatboldsymbolc_mathrmg = left(widehatc_mathrmg x widehatc_mathrmg y widehatc_mathrmg zright)^mathrmT = boldsymbolnabla_boldsymbolk widehatomega and mathrmd V_boldsymbolk = mathrmd k mathrmd l mathrmd m being the intrinsic frequency, intrinsic group velocity and spectral volume element, respectively (see Achatz et al., 2017; Achatz et al., 2023; Jochum et al., 2025).","category":"page"},{"location":"theory/physics/#Wave-breaking","page":"Physics","title":"Wave breaking","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"Wave breaking is captured with a saturation scheme. This scheme assumes that static instability leads to turbulent fluxes that may be described by a turbulent viscosity and diffusivity K in a flux-gradient ansatz (see Lindzen, 1981; Becker, 2004). The divergence of these fluxes has a damping effect on the phase-space wave-action density, which is represented by the sink","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"mathcalS_mathrms = - 2 K leftboldsymbolkright^2 mathcalN","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"This damping is assumed to be such that within one time step Delta t, the instability criterion is no longer fulfilled, which implies","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"K = fracoverlinerho4 Delta t leftint N^4 left(k^2 + l^2right) m^2 fracmathcalNwidehatomega  mathrmd V_boldsymbolkright^- 1 max left0 frac2overlinerho int fracN^4 left(k^2 + l^2right) m^2widehatomega leftboldsymbolkright^2 mathcalN mathrmd V_boldsymbolk - alpha_mathrms^2 N^4right","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where alpha_mathrms is a saturation coefficient that accounts for uncertainties of the criterion (Boeloeni et al., 2016; Boeloeni et al., 2021).","category":"page"},{"location":"theory/physics/#Rayleigh-damping","page":"Physics","title":"Rayleigh damping","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The Rayleigh damping in the LHS sponge introduced above is represented by the sink","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"mathcalS_mathrmR = - 2 alpha_mathrmR mathcalN","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"in the phase-space-wave-action-density equation (Jochum et al., 2025).","category":"page"},{"location":"theory/physics/#1D-transient-theory","page":"Physics","title":"1D transient theory","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The 3D transient theory can be reduced to a 1D transient one by removing all horizontal derivatives (in a Cartesian sense) and setting the horizontal components of the group velocity to zero. The eikonal equations then become","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    dotomega  = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatzright) omega = fracpartial Omegapartial t\n    dotm  = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatzright) m = J^- 1 fracpartial Omegapartial widehatz\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"and are integrated along rays defined by the vertical group velocity","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"dotz = c_mathrmg z = fracpartial Omegapartial m","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The phase-space wave-action density equation is reduced to","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"dotmathcalN = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatz + dotm fracpartialpartial mright) mathcalN = sumlimits_s mathcalS_s","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"and integrated along rays defined by left(dotz dotmright)^mathrmT. Finally, the impact on the resolved flow becomes","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmbJ overlinerho fracpartial M_uwpartial widehatz + E_u\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmbJ overlinerho fracpartial M_vwpartial widehatz + E_v\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = 0\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"(e.g. Boeloeni et al., 2016; Boeloeni et al., 2021).","category":"page"},{"location":"theory/physics/#1D-steady-state-theory","page":"Physics","title":"1D steady-state theory","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"In the 1D steady-state theory, the phase-space-wave-action-density equation from the previous section is integrated over spectral space, the temporal derivative is removed and the quasilinear approximation is used to express the result in terms of the physical-space wave-action densities of individual spectral modes (mathcalA_alpha). This yields","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"J^- 1 fracpartialpartial widehatz left(c_mathrmg z alpha mathcalA_alpharight) = sumlimits_s mathcalQ_s alpha","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where mathcalN = sum_alpha mathcalA_alpha delta left(boldsymbolk - boldsymbolk_alpharight) and mathcalS_s = sum_alpha mathcalQ_s alpha delta left(boldsymbolk - boldsymbolk_alpharight). Similarly, the eikonal equations become","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    fracc_mathrmg z alphaJ fracpartial omegapartial widehatz  = 0\n    fracc_mathrmg z alphaJ fracpartial m_alphapartial widehatz  = J^- 1 fracpartial Omegapartial widehatz\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"Thus, the intrinsic frequency and vertical wavenumber can be determined from","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"beginalign*\n    widehatomega_alpha  = omega_alpha - boldsymbolk_alpha cdot boldsymbolu_mathrmb\n    m_alpha  = - mathrmsgn left(widehatomega_alpharight) sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2\nendalign*","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"where omega_alpha is a constant. Since the wave-action-density equation is solved by vertical integration, the saturation scheme must be amended. Specifically, the saturation sink term mathcalQ_mathrms alpha is integrated over a pseudo-time step J Delta widehatz  c_mathrmg z alpha. Therein, the turbulent viscosity and diffusivity is given by","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"K = fracoverlinerho4 leftsumlimits_alpha fracJ Delta widehatzc_mathrmg z alpha N^4 left(k_alpha^2 + l_alpha^2right) m_alpha^2 fracmathcalA_alphawidehatomega_alpharight^- 1 max left0 frac2overlinerho sumlimits_alpha fracN^4 left(k_alpha^2 + l_alpha^2right) m_alpha^2widehatomega_alpha leftboldsymbolk_alpharight^2 mathcalA_alpha - alpha_mathrms^2 N^4right","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"(see Boeloeni et al., 2021; Jochum et al., 2025).","category":"page"},{"location":"theory/physics/#Orographic-source","page":"Physics","title":"Orographic source","text":"","category":"section"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The orographic source is a lower-boundary condition for the wave-property fields. Its formulation uses the decomposition","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"h left(x yright) = h_mathrmb + sumlimits_alpha Re lefth_mathrmw alpha exp lefti varphi_alpha left(x yright)rightright","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"of the surface topography h, where h_mathrmb and h_mathrmw vary slowly in x and y, as opposed to the quickly varying orographic phase varphi_alpha. By inserting this and the WKB ansatz for the wind into the no-normal-flow condition","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"0 = boldsymbolu cdot boldsymboln = - u fracpartial hpartial x - v fracpartial hpartial y + w qquad mathrmat quad z = h","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"one obtains","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"mathcalN = fracoverlinerho2 sumlimits_alpha fracwidehatomega_alpha leftboldsymbolk_alpharight^2k_alpha^2 + l_alpha^2 lefth_mathrmw alpharight^2 delta left(boldsymbolk - boldsymbolk_alpharight) qquad mathrmat quad z = h_mathrmb","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"The vertical wavenumber at the source is","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"m_alpha = - mathrmsgn left(widehatomega_alpharight) sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2","category":"page"},{"location":"theory/physics/","page":"Physics","title":"Physics","text":"(see Jochum et al., 2025).","category":"page"},{"location":"reference/msgwam/#MSGWaM","page":"MSGWaM","title":"MSGWaM","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM","page":"MSGWaM","title":"PinCFlow.MSGWaM","text":"MSGWaM\n\n3D transient implementation of MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays\nPinCFlow.MSGWaM.RayUpdate\nPinCFlow.MSGWaM.MeanFlowEffect\n\nExternal links\n\nMuraschko et al. (2014)\nBoeloeni et al. (2016)\nWilhelm et al. (2018)\nWei et al. (2019)\nJochum et al. (2025)\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#Interpolation","page":"MSGWaM","title":"Interpolation","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation","text":"Interpolation\n\nModule for interpolating mean-flow quantities to ray-volume positions.\n\nProvides functions that find the grid points closest to a given ray-volume position and perform trilinear interpolation of mean-flow quantities.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDX","text":"DChiDX <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDY","text":"DChiDY <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDZ","text":"DChiDZ <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DN2DZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DN2DZ","text":"DN2DZ <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial N^2  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDX","text":"DUDX <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDY","text":"DUDY <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDZ","text":"DUDZ <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDX","text":"DVDX <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDY","text":"DVDY <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDZ","text":"DVDZ <: AbstractVariable\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.N2","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.N2","text":"N2 <: AbstractVariable\n\nSingleton for dispatch to interpolation of N^2.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.compute_derivatives","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.compute_derivatives","text":"compute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the zonal wind (partial u_mathrmb  partial x) at left(i j k_mathrmDright) and left(i j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial u_mathrmbpartial xright) = fracu_mathrmb i + 1  2 - u_mathrmb i - 1  2Delta widehatx + G^13 fracu_mathrmb k + 1 - u_mathrmb k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the zonal wind (partial u_mathrmb  partial y) at left(i + 1  2 j + 1  2 k_mathrmDright) and left(i + 1  2 j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nbeginalign*\n    left(fracpartial u_mathrmbpartial yright)_i + 1  2 j + 1  2  = fracu_mathrmb i + 1  2 j + 1 - u_mathrmb i + 1  2Delta widehaty + G_i + 1  2 j + 1  2^23 fracu_mathrmb i + 1  2 j + 1  2 k + 1 - u_mathrmb i + 1  2 j + 1  2 k - 12 Delta widehatz\nendalign*\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the zonal wind (partial u_mathrmb  partial z) at left(i + 1  2 j k_mathrmD + 1  2right) and left(i + 1  2 j k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial u_mathrmbpartial zright)_i + 1  2 k + 1  2 = fracu_mathrmb i + 1  2 k + 1 - u_mathrmb i + 1  2J_i + 1  2 k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the meridional wind (partial v_mathrmb  partial x) at left(i + 1  2 j + 1  2 k_mathrmDright) and left(i + 1  2 j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial xright)_i + 1  2 j + 1  2 = fracv_mathrmb i + 1 j + 1  2 - v_mathrmb j + 1  2Delta widehatx + G_i + 1  2 j + 1  2^13 fracv_mathrmb i + 1  2 j + 1  2 k + 1 - v_mathrmb i + 1  2 j + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the meridional wind (partial v_mathrmb  partial y) at left(i j k_mathrmDright) and left(i j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial yright) = fracv_mathrmb j + 1  2 - v_mathrmb j - 1  2Delta widehaty + G^23 fracv_mathrmb k + 1 - v_mathrmb k - 1 2 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the meridional wind (partial v_mathrmb  partial z) at left(i j + 1  2 k_mathrmD + 1  2right) and left(i j + 1  2 k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial zright)_j + 1  2 k + 1  2 = fracv_mathrmb j + 1  2 k + 1 - v_mathrmb j + 1  2J_j + 1  2 k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the tracer field (partial chi_mathrmb  partial x) at left(i + 1  2 j k_mathrmDright) and left(i + 1  2 j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial xright)_i + 1  2 = fracchi_mathrmb i + 1 - chi_mathrmbDelta widehatx + G_i + 1  2^13 fracchi_mathrmb i + 1  2 k + 1 - chi_mathrmb i + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the tracer field (partial chi_mathrmb  partial y) at left(i j + 1  2 k_mathrmDright) and left(i j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial yright)_j + 1  2 = fracchi_mathrmb j + 1 - chi_mathrmbDelta widehaty + G_j + 1  2^23 fracchi_mathrmb j + 1  2 k + 1 - chi_mathrmb j + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the tracer field (partial chi_mathrmb  partial z) at left(i j k_mathrmD + 1  2right) and left(i j k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial zright)_k + 1  2 = fracchi_mathrmb k + 1 - chi_mathrmbJ_k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nkd: Lower vertical grid-cell index.\nku: Upper vertical grid-cell index.\nphitype: Type of derivative to compute.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.get_next_half_level","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.get_next_half_level","text":"get_next_half_level(\n    i::Integer,\n    j::Integer,\n    z::AbstractFloat,\n    state::State,\n)::Integer\n\nDetermine and return the index of the next half-level above z at the horizontal position left(i jright).\n\nThis method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.\n\nIn MPI processes at the lower boundary of the domain, the returned index cannot be smaller than state.domain.k0, in other processes, it cannot be smaller than 3.\nIn MPI processes at the upper boundary of the domain, the returned index cannot be larger than state.domain.k1, in other processes, it cannot be larger than state.domain.nzz - 1.\n\nArguments\n\ni: Zonal index.\nj: Meridional index.\nz: Vertical position.\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.get_next_level","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.get_next_level","text":"get_next_level(i::Integer, j::Integer, z::AbstractFloat, state::State)::Integer\n\nDetermine and return the index of the next level above z at the horizontal position left(i jright).\n\nThis method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.\n\nIn MPI processes at the lower boundary of the domain, the returned index cannot be smaller than state.domain.k0, in other processes, it cannot be smaller than 3.\nIn MPI processes at the upper boundary of the domain, the returned index cannot be larger than state.domain.k1 + 1, in other processes, it cannot be larger than state.domain.nzz - 1.\n\nArguments\n\ni: Zonal index.\nj: Meridional index.\nz: Vertical position.\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate","text":"interpolate(\n    state::State;\n    philbd::AbstractFloat = NaN,\n    philbu::AbstractFloat = NaN,\n    philfd::AbstractFloat = NaN,\n    philfu::AbstractFloat = NaN,\n    phirbd::AbstractFloat = NaN,\n    phirbu::AbstractFloat = NaN,\n    phirfd::AbstractFloat = NaN,\n    phirfu::AbstractFloat = NaN,\n    zlbd::AbstractFloat = NaN,\n    zlbu::AbstractFloat = NaN,\n    zlfd::AbstractFloat = NaN,\n    zlfu::AbstractFloat = NaN,\n    zrbd::AbstractFloat = NaN,\n    zrbu::AbstractFloat = NaN,\n    zrfd::AbstractFloat = NaN,\n    zrfu::AbstractFloat = NaN,\n    zlc::AbstractFloat = NaN,\n    yb::AbstractFloat = NaN,\n    yf::AbstractFloat = NaN,\n    ylc::AbstractFloat = NaN,\n    xl::AbstractFloat = NaN,\n    xr::AbstractFloat = NaN,\n    xlc::AbstractFloat = NaN,\n)::AbstractFloat\n\nPerform trilinear interpolation to (xlc, ylc, zlc), with values from eight surrounding grid points (two zonal positions, two meridional positions and eight vertical positions), and return the result.\n\nOut of the eight grid points, four each are assumed to be to the left, to the right, behind, in front of, below and above the location of interest. Due to the grid being terrain-following, this includes eight different vertical positions, but only two zonal and two meridional positions. This is handled by performing successive linear interpolations, where the vertical position is interpolated along with the field of interest.\n\nThe exact algorithm is as follows.\n\nInterpolation in x:\nbeginalign*\npsi_mathrmBD  = f_x psi_mathrmLBD + (1 - f_x) psi_mathrmRBD\npsi_mathrmBU  = f_x psi_mathrmLBU + (1 - f_x) psi_mathrmRBU\npsi_mathrmFD  = f_x psi_mathrmLFD + (1 - f_x) psi_mathrmRFD\npsi_mathrmFU  = f_x psi_mathrmLFU + (1 - f_x) psi_mathrmRFU\nendalign*\nInterpolation in y:\nbeginalign*\npsi_mathrmD  = f_y psi_mathrmBD + (1 - f_y) psi_mathrmFD\npsi_mathrmU  = f_y psi_mathrmBU + (1 - f_y) psi_mathrmFU\nendalign*\nInterpolation in z:\nphi_mathrmC = f_z phi_mathrmD + (1 - f_z) phi_mathrmU\n\nTherein, mathrmL, mathrmR, mathrmB, mathrmF, mathrmD and mathrmU denote grid points to the left, to the right, forward, backward, downward and upward of the location of interest (denoted by mathrmC), respectively, psi = left(phi zright) and\n\nf_alpha = begincases\n0  mathrmif quad alpha_beta = alpha_gamma\n1  mathrmif quad alpha_mathrmC  alpha_beta\nfracalpha_gamma - alpha_mathrmCalpha_gamma - alpha_beta  mathrmif quad alpha_beta leq alpha_mathrmC leq alpha_gamma\n0  mathrmif quad alpha_gamma  alpha_mathrmC\nendcases\n\nwhere left(alpha beta gammaright) in leftleft(x mathrmL mathrmRright) left(y mathrmB mathrmFright) left(z mathrmD mathrmUright)right.\n\nDue to their large number, the positions and values are given as keyword arguments with the default value NaN, so that their order does not matter and calls with missing arguments are easy to detect.\n\nArguments\n\nstate: Model state.\n\nKeywords\n\nphilbd: Value at the point to the left, behind and below.\nphilbu: Value at the point to the left, behind and above.\nphilfd: Value at the point to the left, in front and below.\nphilfu: Value at the point to the left, in front and above.\nphirbd: Value at the point to the right, behind and below.\nphirbu: Value at the point to the right, behind and above.\nphirfd: Value at the point to the right, in front and below.\nphirfu: Value at the point to the right, in front and above.\nzlbd: Vertical coordinate of the point to the left, behind and below.\nzlbu: Vertical coordinate of the point to the left, behind and above.\nzlfd: Vertical coordinate of the point to the left, in front and below.\nzlfu: Vertical coordinate of the point to the left, in front and above.\nzrbd: Vertical coordinate of the point to the right, behind and below.\nzrbu: Vertical coordinate of the point to the right, behind and above.\nzrfd: Vertical coordinate of the point to the right, in front and below.\nzrfu: Vertical coordinate of the point to the right, in front and above.\nzlc: Vertical position of interest.\nyb: Meridional coordinate of the points behind.\nyf: Meridional coordinate of the points in front.\nylc: Meridional position of interest.\nxl: Zonal coordinate of the points to the left.\nxr: Zonal coordinate of the points to the right.\nxlc: Zonal position of interest.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow","text":"interpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::U,\n)::AbstractFloat\n\nInterpolate the zonal wind (u_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate u_mathrmb to the location of interest, using interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::V,\n)::AbstractFloat\n\nInterpolate the meridional wind (v_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the zonal wind (u_mathrmb).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::W,\n)::AbstractFloat\n\nInterpolate the vertical wind (w_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate w_mathrmb to the location of interest, using compute_vertical_wind and interpolate. At grid points beyond the vertical boundaries, the values used in the interpolation are replaced with zeros.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the zonal wind (partial u_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial x to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the zonal wind (partial u_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial y to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the zonal wind (partial u_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial z to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the meridional wind (partial v_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the meridional derivative of the zonal wind (partial u_mathrmb  partial y).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the meridional wind (partial v_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the zonal derivative of the zonal wind (partial u_mathrmb  partial x).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the meridional wind (partial v_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the vertical derivative of the zonal wind (partial u_mathrmb  partial z).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the tracer mixing ratio (partial chi_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial x to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the tracer mixing ratio (partial chi_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial y to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the tracer mixing ratio (partial chi_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial z to the location of interest, using compute_derivatives and interpolate.\n\nArguments\n\nxlc: Zonal position of interest.\nylc: Meridional position of interest.\nzlc: Vertical position of interest.\nstate: Model state.\nphitype: Mean-flow quantity to interpolate.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.interpolate\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.MSGWaM.Interpolation.compute_derivatives\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_sponge","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_sponge","text":"interpolate_sponge(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n)::AbstractFloat\n\nInterpolate the Rayleigh-damping coefficient of the LHS sponge (alpha_mathrmR) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate alpha_mathrmR to the location of interest, using interpolate.\n\nArguments\n\nxlc: Zonal position of interest.\nylc: Meridional position of interest.\nzlc: Vertical position of interest.\nstate: Model state.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.interpolate\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_stratification","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_stratification","text":"interpolate_stratification(\n    zlc::AbstractFloat,\n    state::State,\n    strtype::N2,\n)::AbstractFloat\n\nInterpolate the squared buoyancy frequency (N^2) to zlc and return the result.\n\nThis method first determines the two points in z that are closest to zlc. As horizontal position, it uses (i0, j0), which is arbitrary, since N^2 has no horizontal dependence. Subsequently, simple linear interpolation is performed to find N^2 at zlc.\n\ninterpolate_stratification(\n    zlc::AbstractFloat,\n    state::State,\n    strtype::DN2DZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the squared buoyancy frequency (partial N^2  partial z) to zlc and return the result.\n\nThis method first determines the two points in z + J Delta widehatz  2 that are closest to zlc. As for N^2, (i0, j0) is used as the horizontal position, and simple linear interpolation is performed to find partial N^2  partial z at zlc.\n\nArguments\n\nzlc: Vertical position of interest.\nstate: Model state.\nstrtype: Stratification quantity to interpolate.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#RayOperations","page":"MSGWaM","title":"RayOperations","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations","text":"RayOperations\n\nModule for various ray-volume operations needed throughout MSGWaM.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.Interpolation\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.check_rays","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.check_rays","text":"check_rays(state::State)\n\nCheck if all ray volumes are assigned to the correct grid cells.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency","text":"compute_intrinsic_frequency(\n    state::State,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::AbstractFloat\n\nReturn the intrinsic frequency of the ray volume specified by left(r i j kright).\n\nThe intrinsic frequency is calculated from the dispersion relation\n\nwidehatomega_r = sigma sqrtfracN_r^2 left(k_r^2 + l_r^2right) + f^2 m_r^2leftboldsymbolk_rright^2\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray volume's vertical position and sigma is the frequency branch.\n\nArguments\n\nstate: Model state\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_merge_index","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_merge_index","text":"compute_merge_index(\n    wnr::AbstractFloat,\n    wnr_min_p::AbstractFloat,\n    wnr_max_p::AbstractFloat,\n    wnr_min_n::AbstractFloat,\n    wnr_max_n::AbstractFloat,\n    dwnr_mrg_p::AbstractFloat,\n    dwnr_mrg_n::AbstractFloat,\n    nray::Integer,\n)::Integer\n\nReturn the index of the wavenumber wnr on a 1D spectral grid specified by the other arguments.\n\nThis method is used by PinCFlow.MSGWaM.RayUpdate.merge_rays! to sort ray volumes into spectral bins.\n\nArguments\n\nwnr: Wavenumber value.\nwnr_min_p: Minimum positive wavenumber.\nwnr_max_p: Maximum positive wavenumber.\nwnr_min_n: Minimum negative wavenumber.\nwnr_max_n: Maximum negative wavenumber.\ndwnr_mrg_p: Logarithmic spacing of discrete positive wavenumbers.\ndwnr_mrg_n: Logarithmic spacing of discrete negative wavenumbers.\nnray: Number of spectral grid points.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals","text":"compute_saturation_integrals(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the two spectral integrals S_1 and S_2, as needed by the saturation scheme (in the grid cell left(i j kright)).\n\nComputes the sums\n\nbeginalign*\n    S_1  approx sumlimits_r left(m_r leftb_mathrmw rrightright)^2 f_r\n    S_2  approx sumlimits_r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_r\nendalign*\n\nwhere\n\nf_r = max left(1 fracDelta x_rDelta widehatxright) max left(1 fracDelta y_rDelta widehatyright) max left(1 fracDelta z_rJ Delta widehatzright)\n\nis the maximum grid-cell fraction that can be covered by each ray volume (with left(Delta x_r Delta y_r Delta z_rright) being the ray-volume extents in physical space) and\n\nleftb_mathrmw rright^2 = frac2overlinerho fracN_r^4 left(k_r^2 + l_r^2right)widehatomega_r leftboldsymbolk_rright^2 mathcalN_r Delta k_r Delta l_r Delta m_r\n\nis the squared gravity-wave amplitude of the buoyancy. Therein, N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position (using interpolate_stratification) and left(Delta k_r Delta l_r Delta m_rright) are the ray-volume extents in spectral space.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\nPinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds","text":"compute_spectral_bounds(\n    wavenumbers::AbstractVector{<:AbstractFloat},\n)::NTuple{4, <:AbstractFloat}\n\nCompute the minima and maxima of positive and negative entries in wavenumbers and return them (in the order positive minimum, positive maximum, negative minimum, negative maximum).\n\nThis method is used by PinCFlow.MSGWaM.RayUpdate.merge_rays! to create spectral bins.\n\nArguments\n\nwavenumbers: Vector of wavenumbers in the considered spectral dimension.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral","text":"compute_wave_action_integral(\n    merge_mode::ConstantWaveAction,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n)\n\nReturn the wave action obtained by multiplying the given phase-space wave-action density with the given phase-space volume.\n\nThis method is used to implement conservation of wave action in ray-volume merging.\n\ncompute_wave_action_integral(\n    merge_mode::ConstantWaveEnergy,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n)::AbstractFloat\n\nReturn the wave energy obtained by multiplying the given phase-space wave-action density with the given intrinsic frequency and phase-space volume.\n\nThis method is used to implement conservation of wave energy in ray-volume merging.\n\nArguments\n\nmerge_mode: Merging strategy.\nnr: Phase-space wave-action density.\nomegar: Intrinsic frequency.\nfxk: Phase space factor in the x-k subspace.\nfyl: Phase space factor in the y-l subspace.\nfzm: Phase space factor in the z-m subspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.copy_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.copy_rays!","text":"copy_rays!(\n    rays::Rays,\n    r::Pair{<:Integer, <:Integer},\n    i::Pair{<:Integer, <:Integer},\n    j::Pair{<:Integer, <:Integer},\n    k::Pair{<:Integer, <:Integer},\n)\n\nCopy all properties of the ray volume specified by the first components of the index pairs to that specified by the second components.\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume indices.\ni: Zonal grid-cell indices.\nj: Meridional grid-cell indices.\nk: Vertical grid-cell indices.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_physical_extent","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_physical_extent","text":"get_physical_extent(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the physical extents of the ray volume specified by left(r i j kright) as the tuple (dxr, dyr, dzr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_physical_position","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_physical_position","text":"get_physical_position(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the physical position of the ray volume specified by left(r i j kright) as the tuple (xr, yr, zr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_spectral_extent","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_spectral_extent","text":"get_spectral_extent(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the spectral extents of the ray volume specified by left(r i j kright) as the tuple (dkr, dlr, dmr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_spectral_position","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_spectral_position","text":"get_spectral_position(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the spectral position of the ray volume specified by left(r i j kright) as the tuple (kr, lr, mr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_surfaces","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_surfaces","text":"get_surfaces(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nCompute phase-space surface areas of the ray volume specified by left(r i j kright) and return them as the tuple (axk, ayl, azm).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.remove_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.remove_rays!","text":"remove_rays!(state::State)\n\nRemove gaps (i.e. zero-wave-action ray volumes between nonzero-wave-action ray volumes) in the ray-volume arrays.\n\nIn each grid cell, this method moves all ray volumes as far to the front of the arrays possible and updates nray accordingly, so that every ray volume in the range 1:nray[i, j, k] has nonzero wave action.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.update_merged_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.update_merged_rays!","text":"update_merged_rays!(\n    merge_mode::AbstractMergeMode,\n    merged_rays::MergedRays,\n    bin::Integer,\n    xr::AbstractFloat,\n    dxr::AbstractFloat,\n    yr::AbstractFloat,\n    dyr::AbstractFloat,\n    zr::AbstractFloat,\n    dzr::AbstractFloat,\n    kr::AbstractFloat,\n    dkr::AbstractFloat,\n    lr::AbstractFloat,\n    dlr::AbstractFloat,\n    mr::AbstractFloat,\n    dmr::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n)\n\nUpdate the fields of merged_rays at bin such that they contain the outermost bounds and total wave action/energy of all contributing ray volumes.\n\nThis method is used to compute the properties of merged ray volumes. It is called for every old ray volume that contributes to the new, merged volume and updates the outermost bounds in physical and spectral space, as well as the total wave action/energy, accordingly.\n\nArguments\n\nmerge_mode: Merging strategy.\nmerged_rays: Properties of merged ray volumes.\nbin: Index of the bin to update.\nxr: Position of the old ray volume in x.\ndxr: Extent of the old ray volume in x.\nyr: Position of the old ray volume in y.\ndyr: Extent of the old ray volume in y.\nzr: Position of the old ray volume in z.\ndzr: Extent of the old ray volume in z.\nkr: Position of the old ray volume in k.\ndkr: Extent of the old ray volume in k.\nlr: Position of the old ray volume in l.\ndlr: Extent of the old ray volume in k.\nmr: Position of the old ray volume in m.\ndmr: Extent of the old ray volume in m.\nfxk: Phase-space factor of the old ray volume in x-k subspace.\nfyl: Phase-space factor of the old ray volume in y-l subspace.\nfzm: Phase-space factor of the old ray volume in z-m subspace.\nnr: Phase-space wave-action density of the old ray volume.\nomegar: Intrinsic frequency of the old ray volume.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_wave_action_integral\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#RaySources","page":"MSGWaM","title":"RaySources","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources","text":"RaySources\n\nModule for ray-volume sources.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.RayOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources.activate_orographic_source!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources.activate_orographic_source!","text":"activate_orographic_source!(\n    state::State,\n    omi_ini::AbstractArray{<:AbstractFloat, 4},\n    wnk_ini::AbstractArray{<:AbstractFloat, 4},\n    wnl_ini::AbstractArray{<:AbstractFloat, 4},\n    wnm_ini::AbstractArray{<:AbstractFloat, 4},\n    wad_ini::AbstractArray{<:AbstractFloat, 4},\n)\n\nCompute ray-volume properties in the launch layer (i.e. at k = k0 - 1) for the initialization of MSGWaM.\n\nSets the launch-layer values of arrays for initial ray-volume properties (intrinsic frequencies, wavenumbers and wave-action densities). For this purpose, the horizontal components of the resolved wind, the background density and the squared buoyancy frequency are vertically averaged between the surface and an approximation for the summits of the unresolved orography. The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking is inferred (see below). Afterwards, the ray-volume properties are obtained by calling compute_orographic_mode with the correspondingly scaled mode of the orographic spectrum and the vertical averages as arguments.\n\nactivate_orographic_source!(state::State)\n\nLaunch ray volumes that represent unresolved orographic gravity waves.\n\nIn each column of MPI processes at the lower boundary, this method first computes vertical averages of the horizontal components of the resolved wind, the background density and the squared buoyancy frequency between h_mathrmb (the surface) and h_mathrmb + Delta h (an approximation for the summits of the unresolved orography, with Delta h = sum_alpha lefth_mathrmw alpharight). The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking, as well as the depth of the blocked layer, is inferred. A loop over the spectral modes of the unresolved orography follows, in which the properties of each mode are computed, using compute_orographic_mode with the scaled mode of the orographic spectrum and vertical averages as arguments, and corresponding ray volumes are launched at k = k0 - 1.\n\nThe parameterization of blocking is built around the non-dimensionalized mountain wave amplitude, or Long number,\n\nmathrmLo = fracN_h Delta hleftboldsymbolu_hright\n\nwhere N_h is the square root of the vertically averaged squared buoyancy frequency and boldsymbolu_h is the vertically averaged resolved horizontal wind. This number is used to estimate the depth of the blocked layer as\n\nDelta z_mathrmB = 2 Delta h max left(0 fracmathrmLo - CmathrmLoright)\n\nwhere C is a critical value represented by the model parameter state.namelists.wkb.long_threshold. The corresponding scaling of the orographic spectrum is given by\n\nr left(mathrmLoright) = frac2 Delta h - Delta z_mathrmB2 Delta h = min left(1 fracCmathrmLoright)\n\nso that Delta z_mathrmB = 2 Delta h left(1 - rright). In addition to the reduction of the mountain-wave amplitude, the present blocked-layer scheme adds a blocked-flow drag to the mean-flow impact. This is implemented in PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!.\n\nThe launch algorithm distinguishes between the following situations (regarding previously launched ray volumes).\n\nThere is no ray volume with nonzero wave-action density. A new ray volume is launched.\nThere is a ray volume with nonzero wave-action density that has at least partially passed through the lower boundary. The ray volume is either clipped or extended, such that its lower edge coincides with the surface, and the part below the surface is discarded. Then, it is assigned to the first model layer k0, i.e. its indices are changed from (r, i, j, k0 - 1) to (rray, i, j, k0), where rray is the new last ray-volume index at (i, j, k0). Finally, a new ray volume is launched.\nThere is a ray volume with nonzero wave-action density, which has not yet crossed the lower boundary. It is replaced with a new one.\n\nArguments\n\nstate: Model state.\nomi_ini: Array for intrinsic frequencies.\nwnk_ini: Array for zonal wavenumbers.\nwnl_ini: Array for meridional wavenumbers.\nwnm_ini: Array for vertical wavenumbers.\nwad_ini: Array for wave-action densities.\n\nSee also\n\nPinCFlow.MSGWaM.RaySources.compute_orographic_mode\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources.compute_orographic_mode","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources.compute_orographic_mode","text":"compute_orographic_mode(\n    displm::AbstractFloat,\n    wnk::AbstractFloat,\n    wnl::AbstractFloat,\n    uavg::AbstractFloat,\n    vavg::AbstractFloat,\n    rhoavg::AbstractFloat,\n    bvsavg::AbstractFloat,\n    fc::AbstractFloat,\n    branch::Integer,\n)::NTuple{5, <:AbstractFloat}\n\nCompute and return the properties of an orographic-gravity-wave mode.\n\nCalculates the intrinsic frequency, wavenumbers and wave-action density of a gravity-wave mode generated by flow over topography, using linear mountain-wave theory. The implemented formulas are as follows (where this method's arguments are represented by h_mathrmw alpha, k_h alpha, l_h alpha, u_h, v_h, overlinerho_h, N_h^2, f and sigma).\n\nIntrinsic frequency:\nwidehatomega_alpha = sigma left- k_h alpha u_h - l_h alpha v_hright\nHorizontal wavenumbers:\nbeginalign*\n    k_alpha  = sigma mathrmsgn left(- k_h alpha u_h - l_h alpha v_hright) k_h alpha\n    l_alpha  = sigma mathrmsgn left(- k_h alpha u_h - l_h alpha v_hright) l_h alpha\nendalign*\nVertical wavenumber:\nm_alpha = - sigma sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N_h^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2\nWave-action density:\nmathcalA_alpha = fracoverlinerho_h2 fracwidehatomega_alpha leftboldsymbolk_alpharight^2k_alpha^2 + l_alpha^2 lefth_mathrmw alpharight^2\n\nIf the squared intrinsic frequency is smaller than the squared Coriolis parameter or larger than the squared buoyancy frequency (and thus outside of the gravity-wave spectrum), the vertical wavenumber and wave-action density are set to zero.\n\nArguments\n\ndisplm: Topographic displacement.\nwnk: Zonal wavenumber from the topographic spectrum.\nwnl: Meridional wavenumber from the topographic spectrum.\nuavg: Vertically averaged resolved zonal wind.\nvavg: Vertically averaged resolved meridional wind.\nrhoavg: Vertically averaged background density.\nbvsavg: Vertically averaged squared buoyancy frequency.\nfc: Coriolis parameter.\nbranch: Frequency branch.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#BoundaryRays","page":"MSGWaM","title":"BoundaryRays","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays","text":"BoundaryRays\n\nModule for enforcing boundary conditions for ray volumes.\n\nProvides functions for configurations that are serial or parallel in any dimension of physical space. Assumes periodicity in the horizontal and solid-wall boundaries in the vertical.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\nPinCFlow.Boundaries\nPinCFlow.MSGWaM.RayOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!","text":"set_boundary_rays!(state::State)\n\nEnforce boundary conditions for ray volumes by dispatching to a test-case-specific method.\n\nset_boundary_rays!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\nset_boundary_rays!(state::State, testcase::AbstractWKBTestCase)\n\nEnforce boundary conditions for ray volumes by dispatching to a WKB-mode-specific method.\n\nset_boundary_rays!(state::State, wkb_mode::SteadyState)\n\nEnforce horizontal boundary conditions for \"ray volumes\" in steady-state mode.\n\nZonal (meridional) boundary conditions are only enforced if state.namelists.domain.sizex > 1 (state.namelists.domain.sizey > 1).\n\nset_boundary_rays!(state::State, wkb_mode::AbstractWKBMode)\n\nEnforce horizontal and vertical boundary conditions for ray volumes in single-column or multi-column mode.\n\nZonal (meridional) boundary conditions are only enforced if state.namelists.domain.sizex > 1 (state.namelists.domain.sizey > 1).\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!","text":"set_meridional_boundary_rays!(state::State)\n\nSet the ray volumes at the meridional boundaries.\n\nThis method first enforces meridional boundary conditions for state.wkb.nray (by applying set_meridional_boundaries_of_field! to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in widehaty, ray volumes are communicated between MPI processes, using set_meridional_halo_rays!. At the meridional boundaries of the domain, the y-coordinates of ray volumes are adjusted such that shifting works properly.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!","text":"set_meridional_halo_rays!(state::State)\n\nExchange ray volumes in meridional halo cells.\n\nPerforms bidirectional MPI communication between backward and forward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the backward and forward boundaries of the MPI subdomains.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!","text":"set_vertical_boundary_rays!(state::State)\n\nEnforce vertical boundary conditions for ray volumes.\n\nIf the domain is parallelized in widehatz, ray-volume counts and the ray volumes themselves are first communicated between MPI processes, using set_vertical_halos_of_field! and set_vertical_halo_rays!, respectively. The vertical boundary conditions are then enforced by cutting (removing) ray volumes that have partially (fully) crossed the upper boundary and reflecting ray volumes (by adjusting the vertical position and wavenumber) that have at least partially crossed the lower boundary from above.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!","text":"set_vertical_halo_rays!(state::State)\n\nExchange ray volumes in vertical halo cells.\n\nPerforms MPI communication between downward and upward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the downward and upward boundaries of the MPI subdomains. Solid walls are assumed at the vertical boundaries of the full domain. The corresponding ghost-cell ray volumes are not changed.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!","text":"set_zonal_boundary_rays!(state::State)\n\nSet the ray volumes at the zonal boundaries.\n\nThis method first enforces zonal boundary conditions for state.wkb.nray (by applying set_zonal_boundaries_of_field! to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in widehatx, ray volumes are communicated between MPI processes, using set_zonal_halo_rays!. At the zonal boundaries of the domain, the x-coordinates of ray volumes are adjusted such that shifting works properly.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!","text":"set_zonal_halo_rays!(state::State)\n\nExchange ray volumes in zonal halo cells.\n\nPerforms bidirectional MPI communication between left and right neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the left and right boundaries of the MPI subdomains.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#RayUpdate","page":"MSGWaM","title":"RayUpdate","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate","text":"RayUpdate\n\nModule for the integration of the ray equations.\n\nIn addition to ray-volume initialization and propagation, functions for tracking ray volumes on the model grid and controlling their count, as well as a saturation scheme for capturing wave breaking, are provided.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.BoundaryRays\nPinCFlow.MSGWaM.Interpolation\nPinCFlow.MSGWaM.RayOperations\nPinCFlow.MSGWaM.RaySources\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.X","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.X","text":"X\n\nSingleton for dispatch to operations in x-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.XYZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.XYZ","text":"XYZ\n\nSingleton for dispatch to operations in all directions.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.XZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.XZ","text":"XZ\n\nSingleton for dispatch to operations in x- and z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.Y","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.Y","text":"Y\n\nSingleton for dispatch to operations in y-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.YZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.YZ","text":"YZ\n\nSingleton for dispatch to operations in y- and z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.Z","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.Z","text":"Z\n\nSingleton for dispatch to operations in z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!","text":"apply_saturation_scheme!(state::State, dt::AbstractFloat)\n\nApply the saturation scheme by dispatching to a test-case-specific method.\n\napply_saturation_scheme!(\n    state::State,\n    dt::AbstractFloat,\n    testcase::AbstractTestCase,\n)\n\nReturn for non-WKB test cases.\n\napply_saturation_scheme!(\n    state::State,\n    dt::AbstractFloat,\n    testcase::AbstractWKBTestCase,\n)\n\nApply the saturation scheme by dispatching to a WKB-mode-specific method.\n\napply_saturation_scheme!(state::State, dt::AbstractFloat, wkb_mode::SteadyState)\n\nReturn for steady-state configurations.\n\nIn steady-state mode, saturation is handled by PinCFlow.MSGWaM.RayUpdate.propagate_rays!.\n\napply_saturation_scheme!(\n    state::State,\n    dt::AbstractFloat,\n    wkb_mode::AbstractWKBMode,\n)\n\nApply the saturation scheme.\n\nSaturation is assumed to occur when the static-instability criterion\n\nsumlimits_r left(m_r leftb_mathrmw rrightright)^2 f_r geq alpha_mathrms^2 N^4\n\nis locally fulfilled (i.e. within a grid cell). Therein, leftb_mathrmw rright^2 is the squared gravity-wave amplitude of the buoyancy, f_r is the maximum grid-cell fraction each ray volume can cover and alpha_mathrms is a saturation coefficient that represents the uncertainties of the criterion. The phase-space wave-action density is then reduced in accordance with\n\nfracDelta leftb_mathrmw rright^2Delta t = - 2 K leftboldsymbolk_rright^2 leftb_mathrmw rright^2\n\nwhich is based on the assumption that wave breaking leads to turbulent fluxes that may be parameterized with a flux-gradient ansatz. The turbulent viscosity and diffusivity\n\nK = left2 Delta tsumlimits_r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_rright^- 1 max left0 sum_r left(m_r leftb_mathrmw rrightright)^2 f_r - alpha_mathrms^2 N^4right\n\nis such that wave action is reduced exactly to the saturation threshold. The two sums involved in this scheme (discretizations of spectral integrals) are computed with compute_spectral_integrals.\n\nArguments\n\nstate: Model state.\ndt: Time step.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_saturation_integrals\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\nPinCFlow.MSGWaM.RayOperations.remove_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.initialize_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.initialize_rays!","text":"initialize_rays!(state::State)\n\nComplete the initialization of MSGWaM by dispatching to a test-case-specific method.\n\ninitialize_rays!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\ninitialize_rays!(state::State, testcase::AbstractWKBTestCase)\n\nComplete the initialization of MSGWaM for WKB test cases.\n\nIn each grid cell, nwm wave modes are computed, using e.g. activate_orographic_source! for mountain waves. For each of these modes, nrxl * nryl * nrzl * nrk * nrl * nrm ray volumes are then defined such that they evenly divide the volume one would get for nrxl = nryl = nrzl = nrk = nrl = nrm = 1 (the parameters are taken from state.namelists.wkb). Finally, the maximum group velocities are determined for the corresponding CFL condition that is used in the computation of the time step.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\n\nSee also\n\nPinCFlow.MSGWaM.RaySources.activate_orographic_source!\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.Interpolation.interpolate_mean_flow\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.merge_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.merge_rays!","text":"merge_rays!(state::State)\n\nMerge ray volumes by dispatching to a test-case-specific method.\n\nmerge_rays!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\nmerge_rays!(state::State, testcase::AbstractWKBTestCase)\n\nMerge ray volumes by dispatching to a WKB-mode-specific method.\n\nmerge_rays!(state::State, wkb_mode::SteadyState)\n\nReturn for steady-state WKB mode.\n\nmerge_rays!(state::State, wkb_mode::AbstractWKBMode)\n\nMerge ray volumes in grid cells in which their count exceeds a threshold.\n\nThis method checks in each grid cell if the number of ray volumes exceeds a maximum that was determined from namelist parameters (state.wkb.nray_max). If it does, the ray volumes in that cell are merged such that the new count is smaller or equal to the threshold. This is done by binning them on a spectral grid with logarithmic spacing, defined from the minima and maxima of the contributing negative and positive wavenumbers in all spectral dimensions. The merging is performed such that the bounds of the new ray volumes coincide with the outermost bounds of the old ray volumes and wave action (or wave energy, depending on the merging strategy) is conserved.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_spectral_bounds\nPinCFlow.MSGWaM.RayOperations.get_physical_position\nPinCFlow.MSGWaM.RayOperations.get_spectral_position\nPinCFlow.MSGWaM.RayOperations.get_physical_extent\nPinCFlow.MSGWaM.RayOperations.get_spectral_extent\nPinCFlow.MSGWaM.RayOperations.get_surfaces\nPinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency\nPinCFlow.MSGWaM.RayOperations.compute_merge_index\nPinCFlow.MSGWaM.RayOperations.update_merged_rays!\nPinCFlow.MSGWaM.RayOperations.compute_wave_action_integral\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.propagate_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.propagate_rays!","text":"propagate_rays!(state::State, dt::AbstractFloat, rkstage::Integer)\n\nIntegrate the wave-action-density and ray equations by dispatching to a test-case-specific method.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    testcase::AbstractTestCase,\n)\n\nReturn for non-WKB test cases.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    testcase::AbstractWKBTestCase,\n)\n\nIntegrate the wave-action-density and ray equations by dispatching to a WKB-mode-specific method.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    wkb_mode::AbstractWKBMode,\n)\n\nIntegrate the wave-action-density and ray equations derived from 1D or 3D transient WKB theory.\n\nThe ray equations are given by\n\nbeginalign*\n    fracmathrmd x_rmathrmd t  = c_mathrmg x r = u_mathrmb r + k_r fracN_r^2 - widehatomega_r^2widehatomega_r leftboldsymbolk_rright^2\n    fracmathrmd y_rmathrmd t  = c_mathrmg y r = v_mathrmb r + l_r fracN_r^2 - widehatomega_r^2widehatomega_r leftboldsymbolk_rright^2\n    fracmathrmd z_rmathrmd t  = c_mathrmg z r = - fracm_r left(widehatomega_r^2 - f^2right)widehatomega_r leftboldsymbolk_rright^2\n    fracmathrmd k_rmathrmd t  = dotk_r = - k_r left(fracpartial u_mathrmbpartial xright)_r - l_r left(fracpartial v_mathrmbpartial xright)_r\n    fracmathrmd l_rmathrmd t  = dotl_r = - k_r left(fracpartial u_mathrmbpartial yright)_r - l_r left(fracpartial v_mathrmbpartial yright)_r\n    fracmathrmd m_rmathrmd t  = dotm_r = - k_r left(fracpartial u_mathrmbpartial zright)_r - l_r left(fracpartial v_mathrmbpartial zright)_r - frack_r^2 + l_r^22 widehatomega_r leftboldsymbolk_rright^2 left(fracpartial N^2partial zright)_r\nendalign*\n\nwhere the subscript r indicates either a ray-volume property or a mean-flow property interpolated to the ray-volume position, via interpolate_mean_flow and interpolate_stratification. In addition to these, MSGWaM integrates prognostic equations for the ray-volume extents, given by\n\nbeginalign*\n    fracmathrmd Delta x_rmathrmd t  = fracmathrmd x_r +mathrmd t - fracmathrmd x_r -mathrmd t = u_mathrmb r + - u_mathrmb r -\n    fracmathrmd Delta y_rmathrmd t  = fracmathrmd y_r +mathrmd t - fracmathrmd y_r -mathrmd t = v_mathrmb r + - v_mathrmb r -\n    fracmathrmd Delta z_rmathrmd t  = fracmathrmd z_r +mathrmd t - fracmathrmd z_r -mathrmd t = c_mathrmg z r + - c_mathrmg z r -\nendalign*\n\nwhere u_mathrmb r pm is the interpolation of u_mathrmb to x_r pm = x_r pm Delta x_r  2 and v_mathrmb r pm is the equivalent for v_mathrmb in y-direction. In the computation of c_mathrmg z r pm, the intrinsic frequency and squared buoyancy frequency are interpolated to z_r pm = z_r pm Delta z_r  2. The update of the spectral ray-volume extents uses the fact that the surfaces in the x-k, y-l and z-m subspaces are conserved. Finally, the prognostic equation for the phase-space wave-action density reads\n\nfracmathrmd mathcalN_rmathrmd t = - 2 alpha_mathrmR r mathcalN_r\n\nwhere alpha_mathrmR r is the interpolation of the Rayleigh-damping coefficient to the ray-volume position, obtained from interpolate_sponge. While the ray equations are integrated with the low-storage third-order Runge-Kutta scheme, the phase-space wave-action density is updated with an implicit substep at the end of each Runge-Kutta stage. The group velocities that are calculated for the propagation in physical space are also used to determine the maxima needed for the WKB-CFL condition used in the time-step computation.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    wkb_mode::SteadyState,\n)\n\nUpdate the vertical wavenumber and wave-action density, using steady-state WKB theory.\n\nIn steady-state mode, the ray volumes are stationary in physical space. In mountain-wave simulations, this method first updates the ray volumes in the launch layer by calling activate_orographic_source!. Subsequently, it performs a vertical sweep to update all other ray volumes. Therein, the vertical wavenumber is set to\n\nm_r = - sigma sqrtfracleft(k_r^2 + l_r^2right) left(N_r^2 - widehatomega_r^2right)widehatomega_r^2 - f^2\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position (with interpolate_stratification) and widehatomega_r = - k_r u_mathrmb - l_r v_mathrmb (in the case of mountain waves, for which omega_r = 0). The new wave-action-density field is obtained by integrating\n\nfracpartialpartial z left(c_mathrmg z r mathcalA_rright) = - 2 alpha_mathrmR r mathcalA_r - 2 K leftboldsymbolk_rright^2 mathcalA_r\n\nwhere alpha_mathrmR r is the Rayleigh-damping coefficient interpolated to the ray-volume position (using interpolate_sponge) and\n\nK = left2 sumlimits_r fracJ Delta widehatzc_mathrmg z r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_rright^- 1 max left0 sum_r left(m_r leftb_mathrmw rrightright)^2 f_r - alpha_mathrms^2 N^4right\n\nis the turbulent viscosity and diffusivity due to wave breaking (see PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme! for more details). After the first right-hand-side term has been integrated with the implicit step\n\nmathcalA_r = left1 + frac2 alpha_mathrmR rc_mathrmg z r left(z_r - z_r k - 1right)right^- 1 fracc_mathrmg z r k - 1c_mathrmg z r mathcalA_r k - 1\n\nthe second term is integrated with the pseudo-time step J Delta widehatz  c_mathrmg z r, which corresponds to the substitution mathcalA_r rightarrow left(1 - 2 J Delta widehatz  c_mathrmg z r K leftboldsymbolk_rright^2right) mathcalA_r. If the domain is parallelized in the vertical, the integration in vertical subdomains is performed sequentially, with one-way communication providing boundary conditions.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrkstage: Runge-Kutta-stage index.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.get_physical_position\nPinCFlow.MSGWaM.RayOperations.get_spectral_position\nPinCFlow.MSGWaM.RayOperations.get_physical_extent\nPinCFlow.MSGWaM.RayOperations.get_spectral_extent\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.Interpolation.interpolate_mean_flow\nPinCFlow.MSGWaM.Interpolation.interpolate_sponge\nPinCFlow.MSGWaM.RaySources.activate_orographic_source!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.shift_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.shift_rays!","text":"shift_rays!(state::State)\n\nShift the array positions of ray volumes such that they are attributed to the correct grid cells by dispatching to a test-case-specific method.\n\nshift_rays!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\nshift_rays!(state::State, testcase::AbstractWKBTestCase)\n\nShift the array positions of ray volumes such that they are attributed to the correct grid cells by dispatching to a WKB-mode-specific method.\n\nshift_rays!(state::State, wkb_mode::SteadyState)\n\nReturn for steady-state mode.\n\nshift_rays!(state::State, wkb_mode::SingleColumn)\n\nShift the vertical array positions of ray volumes such that they are attributed to the correct grid cells.\n\nThis method enforces the vertical boundary conditions (via set_vertical_boundary_rays!), checks if ray volumes need to be shifted and, if they do, copies them to the correct grid cells and marks them for removal (by dispatching to the appropriate method). A second call of set_vertical_boundary_rays! ensures that ray volumes that have moved across MPI processes are included in the appropriate halo cells. Finally, the gaps that were created by marking ray volumes for removal are filled (via remove_rays!).\n\nshift_rays!(state::State, wkb_mode::MultiColumn)\n\nShift the array positions of ray volumes such that they are attributed to the correct grid cells.\n\nFor each dimension in physical space (with more than one grid point), this method performs the corresponding equivalent of the algorithm that is implemented in the method for single-column mode.\n\nshift_rays!(state::State, direction::X)\n\nFor each ray volume, check if it is attributed to the correct position in widehatx and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes that should be attributed to a halo cell are marked for removal but not copied, since the copies are created from the corresponding halo cell in the adjacent MPI process.\n\nshift_rays!(state::State, direction::Y)\n\nFor each ray volume, check if it is attributed to the correct position in widehaty and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes in halo cells are treated in the same way as in the method for shifting in widehatx.\n\nshift_rays!(state::State, direction::Z)\n\nFor each ray volume, check if it is attributed to the correct position in widehatz and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes in halo cells are treated in the same way as in the methods for shifting in widehatx and widehatz.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\ndirection: Shift direction.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!\nPinCFlow.MSGWaM.RayOperations.remove_rays!\nPinCFlow.MSGWaM.RayOperations.check_rays\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.split_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.split_rays!","text":"split_rays!(state::State)\n\nSplit ray volumes that have become larger than the local grid cell by dispatching to a test-case-specific method.\n\nsplit_rays!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\nsplit_rays!(state::State, testcase::AbstractWKBTestCase)\n\nSplit ray volumes that have become larger than the local grid cell by dispatching to a WKB-mode-specific method.\n\nsplit_rays!(state::State, wkb_mode::SteadyState)\n\nReturn for steady-state mode.\n\nsplit_rays!(state::State, wkb_mode::SingleColumn)\n\nSplit ray volumes which have a vertical extent larger than the local vertical grid spacing.\n\nsplit_rays!(state::State, wkb_mode::MultiColumn)\n\nIn each dimension of physical space, split ray volumes which have an extent larger than the local grid spacing.\n\nThe splitting is performed sequentially, such that a ray volume with extents that are all between once and twice as large as allowed is split into exactly eight smaller ray volumes (all of which have the same size).\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::X)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta x_r  Delta widehatx.\n\nThe number of splits is the result of ceiling division of Delta x_r by Delta widehatx. Each split is carried out by adjusting the position and extent of the ray volume, copying it and changing the position of the copy appropriately.\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Y)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta y_r  Delta widehaty.\n\nThe splitting is analogous to that in widehatx.\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Z)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta z_r  J_min Delta widehatz, with J_min being the minimum value of the Jacobian in all grid cells that are at least partially covered by the ray volume (at its true horizontal position on the grid).\n\nThe splitting is analogous to that in widehatx and widehaty.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\nwkb_mode: Approximations used by MSGWaM.\ni: Grid-cell index in widehatx-direction\nj: Grid-cell index in widehaty-direction\nk: Grid-cell index in widehatz-direction\naxis: Axis perpendicular to the split.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#MeanFlowEffect","page":"MSGWaM","title":"MeanFlowEffect","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect","text":"MeanFlowEffect\n\nModule for computing the mean-flow effect of gravity waves.\n\nProvides functions that compute mean-flow tendencies by integrating ray-volume properties in spectral space and mapping the result to physical grid cells. Also provides two filters for smoothing the tendencies, as well as a simple blocked-layer scheme that includes a blocked-flow drag in mountain-wave simulations.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.MSGWaM.Interpolation\nPinCFlow.MSGWaM.RayUpdate\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.UChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.UChi","text":"UChi <: AbstractVariable \n\nSingleton for dispatch to calculation of zonal gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.VChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.VChi","text":"VChi <: AbstractVariable \n\nSingleton for dispatch to calculation of meridional gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.WChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.WChi","text":"WChi <: AbstractVariable \n\nSingleton for dispatch to calculation of vertical gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!","text":"apply_blocked_layer_scheme!(state::State)\n\nCompute the blocked-flow drag and adjust the mean-flow impact accordingly by dispatching to a test-case-specific method.\n\napply_blocked_layer_scheme!(state::State, testcase::AbstractWKBTestCase)\n\nReturn for non-mountain-wave test cases.\n\napply_blocked_layer_scheme!(state::State, testcase::WKBMountainWave)\n\nCompute the blocked-flow drag and adjust the mean-flow impact accordingly.\n\nThe blocked-flow drag is given by\n\nleft(fracpartial boldsymbolu_mathrmbpartial tright)_mathrmB = - D fracleftboldsymbolk_hright leftboldsymbolu_mathrmpright2 pi boldsymbolu_mathrmp\n\nwhere boldsymbolu_mathrmb = left(u_mathrmb v_mathrmb 0right)^mathrmT is the resolved horizontal wind, D is a dimensionless drag coefficient (represented by state.namelists.wkb.drag_coefficient),\n\nboldsymbolk_h = fracsum_alpha lefth_mathrmw alpharight boldsymbolk_h alphasum_alpha lefth_mathrmw alpharight\n\nis a weighted average of the orography's wavevectors boldsymbolk_h alpha (with h_mathrmw alpha being the corresponding spectral modes) and\n\nboldsymbolu_mathrmp = fracleft(boldsymbolu_mathrmb cdot boldsymbolk_hright) boldsymbolk_hleftboldsymbolk_hright^2\n\nis the projection of boldsymbolu_mathrmb onto boldsymbolk_h. This drag replaces the drag due to gravity waves below z_mathrmB, the upper edge of the blocked layer that has been determined by PinCFlow.MSGWaM.RaySources.activate_orographic_source!. In grid cells that contain this upper edge, blocking and gravity waves both contribute to the total drag, weighted by the corresponding grid-cell fractions. The gravity-wave heating is treated similarly, with the \"blocking contribution\" being zero.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!","text":"apply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{1},\n)\n\nApply the first-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac14 left(phi_i - 1 + 2 phi_i + phi_i + 1right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{2},\n)\n\nApply the second-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac116 left(- phi_i - 2 + 4 phi_i - 1 + 10 phi_i + 4 phi_i + 1 - phi_i + 2right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{3},\n)\n\nApply the third-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac164 left(phi_i - 3 - 6 phi_i - 2 + 15 phi_i - 1 + 44 phi_i + 15 phi_i + 1 - 6 phi_i + 2 + phi_i + 3right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{4},\n)\n\nApply the fourth-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac1256 left(- phi_i - 4 + 8 phi_i - 3 - 28 phi_i - 2 + 56 phi_i - 1 + 186 phi_i + 56 phi_i + 1 - 28 phi_i + 2 + 8 phi_i + 3 - phi_i + 4right)\n\nwhere phi_i are the elements of input.\n\nArguments\n\noutput: Filtered output vector.\ninput: Input vector.\nscope: Index range.\norder: Order of the Shapiro filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!","text":"compute_gw_integrals!(state::State)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact by dispatching to a WKB-mode-specific method.\n\ncompute_gw_integrals!(state::State, wkb_mode::MultiColumn)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in multi-column mode.\n\nThis method computes the sums\n\nbeginalign*\n    M_u u  = overlinerho sum_r lambda mu nu left(F u_mathrmw u_mathrmw^*right)_r i + lambda j + mu k + nu\n    M_u v  = overlinerho sum_r lambda mu nu left(F u_mathrmw v_mathrmw^*right)_r i + lambda j + mu k + nu\n    M_u w  = overlinerho sum_r lambda mu nu left(F u_mathrmw w_mathrmw^*right)_r i + lambda j + mu k + nu\n    M_v v  = overlinerho sum_r lambda mu nu left(F v_mathrmw v_mathrmw^*right)_r i + lambda j + mu k + nu\n    M_v w  = overlinerho sum_r lambda mu nu left(F v_mathrmw w_mathrmw^*right)_r i + lambda j + mu k + nu\n    T_u  = sum_r lambda mu nu left(F u_mathrmw theta_mathrmw^*right)_r i + lambda j + mu k + nu\n    T_v  = sum_r lambda mu nu left(F v_mathrmw theta_mathrmw^*right)_r i + lambda j + mu k + nu\n    E_u  = fracfoverlinetheta sum_r lambda mu nu left(F v_mathrmw theta_mathrmw^*right)_r i + lambda j + mu k + nu\n    E_v  = fracfoverlinetheta sum_r lambda mu nu left(F u_mathrmw theta_mathrmw^*right)_r i + lambda j + mu k + nu\n    E  = sum_r lambda mu nu left(F mathcalEright)_r i + lambda j + mu k + nu\nendalign*\n\nTherein, left(lambda mu nuright) are index shifts to ray volumes that are at least partially within the grid cell at left(i j kright), F_r i + lambda j + mu k + nu are the corresponding ray volume fractions and left(u_mathrmw v_mathrmw w_mathrmw theta_mathrmw mathcalEright)_r i + lambda j + mu k + nu are the wave amplitudes of the wind, those of the potential temperature and the wave-energy densities. The computation is based on the relations\n\nbeginalign*\n    overlinerho u_mathrmw r u_mathrmw r^*  = left(k_r widehatc_mathrmg x r - mathrmsgn left(leftfrightright) frack_r widehatc_mathrmg x r + l_r widehatc_mathrmg y r1 - left(widehatomega_r  fright)^2right) mathcalA_r\n    overlinerho u_mathrmw r v_mathrmw r^*  = l_r widehatc_mathrmg x r mathcalA_r\n    overlinerho u_mathrmw r w_mathrmw r^*  = frack_r widehatc_mathrmg z r1 - left(f  widehatomega_rright)^2 mathcalA_r\n    overlinerho v_mathrmw r v_mathrmw r^*  = left(l_r widehatc_mathrmg y r - mathrmsgn left(leftfrightright) frack_r widehatc_mathrmg x r + l_r widehatc_mathrmg y r1 - left(widehatomega_r  fright)^2right) mathcalA_r\n    overlinerho v_mathrmw r w_mathrmw r^*  = fracl_r widehatc_mathrmg z r1 - left(f  widehatomega_rright)^2 mathcalA_r\n    overlinerho u_mathrmw r theta_mathrmw r^*  = fracfg overlinetheta fracl_r m_r N_r^2widehatomega_r leftboldsymbolk_rright^2 mathcalA_r\n    overlinerho v_mathrmw r theta_mathrmw r^*  = - fracfg overlinetheta frack_r m_r N_r^2widehatomega_r leftboldsymbolk_rright^2 mathcalA_r\n    mathcalE_r  = widehatomega_r mathcalA_r\nendalign*\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position. The components of the intrinsic group velocity are given by\n\nbeginalign*\n    widehatc_mathrmg x r  = frack_r left(N_r^2 - widehatomega_r^2right)widehatomega_r leftboldsymbolk_rright^2\n    widehatc_mathrmg y r  = fracl_r left(N_r^2 - widehatomega_r^2right)widehatomega_r leftboldsymbolk_rright^2\n    widehatc_mathrmg z r  = - fracm_r left(widehatomega_r^2 - f^2right)widehatomega_r leftboldsymbolk_rright^2\nendalign*\n\ncompute_gw_integrals!(state::State, wkb_mode::SingleColumn)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in single-column mode.\n\nThis method computes the sums M_u w, M_v w, T_u, T_v, E_u, E_v and E (see above for details).\n\ncompute_gw_integrals!(state::State, wkb_mode::SteadyState)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in steady-state mode.\n\nThis method computes the sums M_u w and M_v w (see above for details). In contrast to the multi-column and single-column modes, the steady-state mode uses the pseudo-momentum approximation\n\nbeginalign*\n    overlinerho u_mathrmw r w_mathrmw r^*  = k_r widehatc_mathrmg z r mathcalA_r\n    overlinerho v_mathrmw r w_mathrmw r^*  = l_r widehatc_mathrmg z r mathcalA_r\nendalign*\n\nArguments\n\nstate::State: Model state.\nwkb_mode: Approximations used by MSGWaM.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!","text":"compute_gw_tendencies!(state::State)\n\nCompute the gravity-wave impact on the momentum and mass-weighted potential temperature.\n\nCalculates the tendencies that are to be added to the equations for momentum and mass-weighted potential temperature. These are given by\n\nbeginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho left(fracM_u u i + 1 - M_u u i - 12 Delta widehatx + G^13 fracM_u u k + 1 - M_u u k - 12 Delta widehatz + fracM_u v j + 1 - M_u v j - 12 Delta widehatyright\n     qquad qquad + leftG^23 fracM_u v k + 1 - M_u v k - 12 Delta widehatz + fracM_u w k + 1 - M_u w k - 12 J Delta widehatzright) + E_u\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho left(fracM_v u i + 1 - M_v u i - 12 Delta widehatx + G^13 fracM_v u k + 1 - M_v u k - 12 Delta widehatz + fracM_v v j + 1 - M_v v j - 12 Delta widehatyright\n     qquad qquad + leftG^23 fracM_v v k + 1 - M_v v k - 12 Delta widehatz + fracM_v w k + 1 - M_v w k - 12 J Delta widehatzright) + E_v\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = - rho_mathrmb left(fracT_u i + 1 - T_u i - 12 Delta widehatx + G^13 fracT_u k + 1 - T_u k - 12 Delta widehatz + fracT_v j + 1 - T_u j - 12 Delta widehatyright\n     qquad qquad + leftG^23 fracT_v k + 1 - T_v k - 12 Delta widehatzright)\nendalign*\n\nwhere left(u_mathrmb v_mathrmb widehatw_mathrmbright) are the components of the transformed (i.e. terrain-following) resolved wind, rho_mathrmb is the resolved density (including the reference part overlinerho) and P_mathrmb is the resolved mass-weighted potential temperature. For a documentation of the fluxes left(M_u u M_u v M_u w M_v v M_v wright), left(E_u E_vright) and left(T_u T_vright), see PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!. Below state.namelists.wkb.zmin_wkb_dim, all tendencies are set to zero.\n\nArguments\n\nstate::State: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices","text":"compute_horizontal_cell_indices(\n    state::State,\n    xr::AbstractFloat,\n    yr::AbstractFloat,\n    dxr::AbstractFloat,\n    dyr::AbstractFloat,\n)::NTuple{4, <:Integer}\n\nFrom the given horizontal ray-volume position and extent, determine the indices of the grid cells that contain the ray-volume edges and return them (in the order left, right, backward and forward).\n\nArguments\n\nstate: Model state.\nxr: Ray-volume position in x.\nyr: Ray-volume position in y.\ndxr: Ray-volume extent in x.\ndyr: Ray-volume extent in y.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!","text":"compute_leading_order_tracer_fluxes!(\n    state::State,\n    tracersetup::NoTracer,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)\n\nReturn for configurations without tracer transport.\n\ncompute_leading_order_tracer_fluxes!(\n    state::State,\n    tracersetup::AbstractTracer,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)\n\nCompute the leading-order gravity-wave tracer fluxes at (i j k).\n\nThe zonal, meridional, and vertical fluxes are given by\n\nbeginalign*\n    overlinerholeftlangle u chirightrangle  = overlinerhosum_r lambdamunuleft(F u_mathrmwchi^*_mathrmwright)_r i + lambda j + mu k + nu\n    overlinerholeftlangle v chirightrangle  = overlinerhosum_r  lambda mu nu left(F v_mathrmw chi^*_mathrmwright)_r i + lambda j + mu k + nu\n    overlinerholeftlangle w chirightrangle  = overlinerhosum_r lambda mu nu left(F w_mathrmw chi^*_mathrmwright)_r i + lambda j + mu k + nu\nendalign*\n\nArguments:\n\nstate: Model state.\ntracersetup:  General tracer-transport configuration.\nfc: Coriolis parameter.\nomir: Gravity-wave intrinsic frequency.\nwnrk: Zonal wavenumber.\nwnrl: Meridional wavenumber.\nwnrm: Vertical wavenumber.\nwadr: Phase-space wave-action density.\nxlc: Zonal location of the ray-volume.\nylc: Meridional location of the ray-volume.\nzlc: Vertical location of the ray-volume.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also:\n\nPinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!-Tuple{State, Integer, Integer, Integer, PinCFlow.Types.NamelistTypes.AbstractTracer}","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!","text":"compute_leading_order_tracer_forcing!(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    tracersetup::AbstractTracer,\n)\n\nCompute and return the leading-order tracer forcing at left(i j kright).\n\ncompute_leading_order_tracer_forcing!(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    tracersetup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"method"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!","text":"compute_mean_flow_effect!(state::State)\n\nCalculate the mean-flow impact of unresolved gravity waves by dispatching to a test-case-specific method.\n\ncompute_mean_flow_effect!(state::State, testcase::AbstractTestCase)\n\nReturn for non-WKB test cases.\n\ncompute_mean_flow_effect!(state::State, testcase::AbstractWKBTestCase)\n\nCalculate the mean-flow impact of unresolved gravity waves.\n\nThis method first computes several spectral integrals (using compute_gw_integrals!), most of which represent gravity-wave fluxes. After the boundary conditions for these have been enforced (using set_boundaries!), the corresponding tendencies are calculated (using compute_gw_tendencies!). These also have boundary conditions that need to be enforced (once again using set_boundaries!) before they are smoothed to remove small-scale features that may occur due to a coarse ray-volume distribution (using smooth_gw_tendencies!). Afterwards, if MSGWaM parameterizes mountain waves, the tendencies are adjusted to account for the formation of blocked layers (using apply_blocked_layer_scheme!), before the boundary conditions are enforced again.\n\nArguments\n\nstate: Model state.\ntestcase: Test case on which the current simulation is based.\n\nSee also\n\nPinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!\nPinCFlow.Boundaries.set_boundaries!\nPinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!\nPinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!\nPinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes","text":"leading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::UChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the zonal leading-order gravity-wave tracer fluxes overlinerholangle uchirangle.\n\nThe flux-contributions are given by\n\noverlinerho u_mathrmw rchi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftl_r left(fracpartial chi_mathrmbpartial zright)_r - m_r left(fracpartial chi_mathrmbpartial yright)_rright\n\nleading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::VChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the meridional leading-order gravity-wave tracer fluxes overlinerholangle vchirangle.\n\nThe fluxes are given by\n\noverlinerho v_mathrmw r chi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftm_r left(fracpartial chi_mathrmbpartial xright)_r - k_r left(fracpartial chi_mathrmbpartial zright)_rright\n\nleading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::WChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the vertical leading-order gravity-wave tracer fluxes overlinerholangle wchirangle.\n\nThe fluxes are given by\n\noverlinerho w_mathrmw r chi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftk_r left(fracpartial chi_mathrmbpartial yright)_r - l_r left(fracpartial chi_mathrmbpartial xright)_rright\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!","text":"set_tracer_field_zero!(state)\n\nReset the gravity-wave-induced tracer fluxes to zero by dispatching over tracer configurations.\n\nset_tracer_field_zero!(state::State, tracersetup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nset_tracer_field_zero!(state::State, tracersetup::AbstractTracer)\n\nSet the gravity-wave-induced tracer fluxes to zero.\n\nArguments:\n\nstate: Model state.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!","text":"smooth_gw_tendencies!(state::State)\n\nApply spatial smoothing to gravity-wave tendency fields by dispatching to a method specific for the chosen filter (state.namelists.wkb.sm_filter) and dimensionality of the domain.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Box,\n    direction::XYZ,\n)\n\nApply a 3D box filter to smooth in all spatial directions.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 3 sumlimits_lambda = i - N_mathrms^i + N_mathrms sumlimits_mu = j - N_mathrms^j + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_lambda mu nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.nsmth_wkb).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Box,\n    direction::XZ,\n)\n\nApply a 2D box filter to smooth in widehatx and widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 2 sumlimits_lambda = i - N_mathrms^i + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_lambda j nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.nsmth_wkb).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Box,\n    direction::YZ,\n)\n\nApply a 2D box filter to smooth in widehaty and widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 2 sumlimits_mu = j - N_mathrms^j + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_i mu nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.nsmth_wkb).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Box,\n    direction::Z,\n)\n\nApply a 1D box filter to smooth in widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 1 sumlimits_nu = k - N_mathrms^k + N_mathrms phi_i j nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.nsmth_wkb).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::XYZ,\n)\n\nApply a 3D Shapiro filter to smooth in all spatial directions.\n\nA 1D Shapiro filter is applied sequentially in widehatx, widehaty and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::XZ,\n)\n\nApply a 2D Shapiro filter to smooth in widehatx and widehatz.\n\nA 1D Shapiro filter is applied sequentially in widehatx and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::YZ,\n)\n\nApply a 2D Shapiro filter to smooth in widehaty and widehatz.\n\nA 1D Shapiro filter is applied sequentially in widehaty and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::Z,\n)\n\nApply a 1D Shapiro filter to smooth in widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::Y,\n)\n\nApply a 1D Shapiro filter to smooth in widehaty.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    sm_filter::Shapiro,\n    direction::X,\n)\n\nApply a 1D Shapiro filter to smooth in widehatx.\n\nsmooth_gw_tendencies!(state::State, tracersetup::AbstractTracer)\n\nApply smoothing to tracer tendencies.\n\nsmooth_gw_tendencies!(state::State, tracersetup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nArguments\n\nstate: Model state.\noutput: Field to smooth.\nsm_filter: Filter type.\ndirection: Directions to smooth in.\ntracersetup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types","page":"Types","title":"PinCFlow.Types","text":"Types\n\nModule for the construction of a single composite type that contains all information on the current model state.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.PoissonTypes\nPinCFlow.Types.VariableTypes\nPinCFlow.Types.WKBTypes\nPinCFlow.Types.TracerTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.AbstractVariable","page":"Types","title":"PinCFlow.Types.AbstractVariable","text":"AbstractVariable\n\nAbstract type for prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Chi","page":"Types","title":"PinCFlow.Types.Chi","text":"Chi <: AbstractVariable\n\nSingleton that represents the tracer mixing ratio.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Explicit","page":"Types","title":"PinCFlow.Types.Explicit","text":"Explicit\n\nSingleton for explicit integration in time.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Implicit","page":"Types","title":"PinCFlow.Types.Implicit","text":"Implicit\n\nSingleton for implicit integration in time.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.P","page":"Types","title":"PinCFlow.Types.P","text":"P <: AbstractVariable\n\nSingleton that represents the mass-weighted potential temperature.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PiP","page":"Types","title":"PinCFlow.Types.PiP","text":"PiP <: AbstractVariable\n\nSingleton that represents the Exner-pressure fluctuations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Rho","page":"Types","title":"PinCFlow.Types.Rho","text":"Rho <: AbstractVariable\n\nSingleton that represents density fluctuations predicted with the continuity equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.RhoP","page":"Types","title":"PinCFlow.Types.RhoP","text":"RhoP <: AbstractVariable\n\nSingleton that represents density fluctuations predicted with the auxiliary equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.State","page":"Types","title":"PinCFlow.Types.State","text":"State{\n    A <: Namelists,\n    B <: Time,\n    C <: Constants,\n    D <: Domain,\n    E <: Grid,\n    F <: Atmosphere,\n    G <: Sponge,\n    H <: Poisson,\n    I <: Variables,\n    J <: WKB,\n    K <: Tracer,\n}\n\nModel state container.\n\nAn instance of this composite type holds complete information about the model configuration and simulation state, so that it is sufficient as primary input to most methods. The construction of such an instance is the first operation performed in PinCFlow.Integration.integrate, since it almost fully initializes the model.\n\nState(namelists::Namelists)::State\n\nConstruct a State instance and thus initialize the model.\n\nThis method first uses the parameters specified in namelists to construct instances of the composite types defined in FoundationalTypes (i.e. Constants, Time, Domain, Grid, Atmosphere and Sponge). It then uses these instances to prepare the arrays needed for the Poisson solver, the time integration and the parameterization of unresolved gravity waves with MSGWaM. Afterwards, only three operations of the initialization process remain (these are performed by PinCFlow.Integration.integrate), namely the initial cleaning, the setting of the initial ray-volume properties and the reading of input data in restart simulations.\n\nFields\n\nnamelists::A: Namelists with all model parameters.\ntime::B: Runge-Kutta time integration coefficients.\nconstants::C: Physical constants and reference values.\ndomain::D: Collection of domain-decomposition and MPI-communication parameters.\ngrid::E: Collection of parameters and fields that describe the grid.\natmosphere::F: Atmospheric-background fields.\nsponge::G: Sponge parameters and damping coefficients.\npoisson::H: Workspace and solution arrays for the Poisson solver.\nvariables::I: Arrays needed for the predictions of the prognostic variables.\nwkb::J: Container for WKB ray-tracing data and parameters.\ntracer::K: Tracer setup and parameters.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.Constants\nPinCFlow.Types.FoundationalTypes.Time\nPinCFlow.Types.FoundationalTypes.Domain\nPinCFlow.Types.FoundationalTypes.Grid\nPinCFlow.Types.FoundationalTypes.Atmosphere\nPinCFlow.Types.FoundationalTypes.Sponge\nPinCFlow.Types.PoissonTypes.Poisson\nPinCFlow.Types.VariableTypes.Variables\nPinCFlow.Types.WKBTypes.WKB\nPinCFlow.Types.TracerTypes.Tracer\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Theta","page":"Types","title":"PinCFlow.Types.Theta","text":"Theta <: AbstractVariable\n\nSingleton that represents the potential temperature.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.U","page":"Types","title":"PinCFlow.Types.U","text":"U <: AbstractVariable\n\nSingleton that represents the zonal wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.V","page":"Types","title":"PinCFlow.Types.V","text":"V <: AbstractVariable\n\nSingleton that represents the meridional wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.W","page":"Types","title":"PinCFlow.Types.W","text":"W <: AbstractVariable\n\nSingleton that represents the (transformed) vertical wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#NamelistTypes","page":"Types","title":"NamelistTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes","page":"Types","title":"PinCFlow.Types.NamelistTypes","text":"NamelistTypes\n\nModule that contains all namelist types.\n\nProvides constructors that allow setting only specific parameters and using default values for the rest.\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractBackground","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractBackground","text":"AbstractBackground\n\nAbstract type for atmospheric background configurations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractLimiter","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractLimiter","text":"AbstractLimiter\n\nAbstract type for flux limiters used in the reconstruction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractMergeMode","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractMergeMode","text":"AbstractMergeMode\n\nAbstract type for ray-volume merge algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractModel","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractModel","text":"AbstractModel\n\nAbstract type for levels of compressibility.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractSponge","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractSponge","text":"AbstractSponge\n\nAbstract type for sponge configurations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractTestCase","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractTestCase","text":"AbstractTestCase\n\nAbstract type for model test cases.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractTracer","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractTracer","text":"AbstractTracer\n\nAbstract type for the inclusion of a tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractWKBFilter","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractWKBFilter","text":"AbstractWKBFilter\n\nAbstract type for filtering methods applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractWKBMode","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractWKBMode","text":"AbstractWKBMode\n\nAbstract type for approximations in WKB theory.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractWKBTestCase","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractWKBTestCase","text":"AbstractWKBTestCase <: AbstractTestCase\n\nAbstract type for WKB test cases.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AtmosphereNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.AtmosphereNamelist","text":"AtmosphereNamelist{\n    A <: Bool,\n    B <: AbstractFloat,\n    C <: AbstractBackground,\n    D <: NTuple{3, <:AbstractFloat},\n}\n\nNamelist for parameters describing the atmospheric background.\n\nAtmosphereNamelist(;\n    specifyreynolds::Bool = false,\n    reinv::AbstractFloat = 0.0E+0,\n    mu_viscous_dim::AbstractFloat = 0.0E+0,\n    mu_conduct_dim::AbstractFloat = 0.0E+0,\n    mu_mom_diff_dim::AbstractFloat = 0.0E+0,\n    background::AbstractBackground = Isothermal(),\n    buoyancy_frequency::AbstractFloat = 1.0E-2,\n    theta0_dim::AbstractFloat = 3.0E+2,\n    temp0_dim::AbstractFloat = 3.0E+2,\n    press0_dim::AbstractFloat = 1.0E+5,\n    backgroundflow_dim::NTuple{3, <:AbstractFloat} = (0.0E+0, 0.0E+0, 0.0E+0),\n    coriolis_frequency::AbstractFloat = 0.0E+0,\n)::AtmosphereNamelist\n\nConstruct an AtmosphereNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nspecifyreynolds::A: Flag to specify inverse Reynolds number instead of viscosity.\nreinv::B: Inverse Reynolds number.\nmu_viscous_dim::B: Kinematic viscosity at the surface.\nmu_conduct_dim::B: Molecular diffusivity in the potential temperature.\nmu_mom_diff_dim::B: Turbulent diffusivity in the momentum.\nbackground::C: Atmospheric background.\nbuoyancy_frequency::B: Buoyancy frequency if background == StratifiedBoussinesq().\ntheta0_dim::B: Reference potential temperature.\ntemp0_dim::B: Reference temperature.\npress0_dim::B: Reference pressure.\nbackgroundflow_dim::D: Initial wind.\ncoriolis_frequency::B: Coriolis frequency of the f-plane.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Boussinesq","page":"Types","title":"PinCFlow.Types.NamelistTypes.Boussinesq","text":"Boussinesq <: AbstractModel\n\nSingleton for Boussinesq dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Box","page":"Types","title":"PinCFlow.Types.NamelistTypes.Box","text":"Box <: AbstractWKBFilter\n\nSingleton for a box filter as smoothing method applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.COSMOSponge","page":"Types","title":"PinCFlow.Types.NamelistTypes.COSMOSponge","text":"COSMOSponge <: AbstractSponge\n\nSingleton for a sponge configuration similar to that used in the COSMO model (squared cosine with time-step-dependent maximum).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Compressible","page":"Types","title":"PinCFlow.Types.NamelistTypes.Compressible","text":"Compressible <: AbstractModel\n\nSingleton for compressible dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.ConstantWaveAction","page":"Types","title":"PinCFlow.Types.NamelistTypes.ConstantWaveAction","text":"ConstantWaveAction <: AbstractMergeMode\n\nSingleton for the constant-wave-action ray-volume merging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.ConstantWaveEnergy","page":"Types","title":"PinCFlow.Types.NamelistTypes.ConstantWaveEnergy","text":"ConstantWaveEnergy <: AbstractMergeMode\n\nSingleton for the constant-wave-energy ray-volume merging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.DiscretizationNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.DiscretizationNamelist","text":"DiscretizationNamelist{A <: AbstractFloat, B <: Bool, C <: AbstractLimiter}\n\nNamelist for parameters describing the discretization.\n\nDiscretizationNamelist(;\n    cfl::AbstractFloat = 5.0E-1,\n    cfl_wave::AbstractFloat = 5.0E-1,\n    dtmin_dim::AbstractFloat = 1.0E-6,\n    dtmax_dim::AbstractFloat = 1.0E+3,\n    adaptive_time_step::Bool = true,\n    limitertype::AbstractLimiter = MCVariant(),\n)::DiscretizationNamelist\n\nConstruct a DiscretizationNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ncfl::A: Number used for the CFL condition in the time step computation.\ncfl_wave::A: Number used for the WKB-CFL condition in the time step computation.\ndtmin_dim::A: Minimum time step allowed for the integration.\ndtmax_dim::A: Maximum time step allowed for the integration.\nadaptive_time_step::B: Switch for using stability criteria to determine the time step. If set to false, dtmax_dim is used as a fixed time step.\nlimitertype::C: Flux limiter used by the MUSCL scheme.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.DomainNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.DomainNamelist","text":"DomainNamelist{A <: Integer, B <: NTuple{2, <:AbstractFloat}, C <: MPI.Comm}\n\nNamelist for parameters describing the model domain.\n\nDomainNamelist(;\n    sizex::Integer = 3,\n    sizey::Integer = 3,\n    sizez::Integer = 3,\n    nbx::Integer = 3,\n    nby::Integer = 3,\n    nbz::Integer = 3,\n    lx_dim::AbstractFloat = 1.0E+3,\n    ly_dim::AbstractFloat = 1.0E+3,\n    lz_dim::AbstractFloat = 1.0E+3,\n    npx::Integer = 1,\n    npy::Integer = 1,\n    npz::Integer = 1,\n    base_comm::MPI.Comm = MPI.COMM_WORLD,\n)::DomainNamelist\n\nConstruct a DomainNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nsizex::A: Number of grid cells in widehatx-direction.\nsizey::A: Number of grid cells in widehaty-direction.\nsizez::A: Number of grid cells in widehatz-direction.\nnbx::A: Number of boundary/halo cells in widehatx-direction.\nnby::A: Number of boundary/halo cells in widehaty-direction.\nnbz::A: Number of boundary/halo cells in widehatz-direction.\nlx_dim::B: Domain extent in widehatx-direction.\nly_dim::B: Domain extent in widehaty-direction.\nlz_dim::B: Domain extent in widehatz-direction.\nnpx::A: Number of MPI processes in widehatx-direction.\nnpy::A: Number of MPI processes in widehaty-direction.\nnpz::A: Number of MPI processes in widehatz-direction.\nbase_comm::C: MPI base communicator.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.ExponentialSponge","page":"Types","title":"PinCFlow.Types.NamelistTypes.ExponentialSponge","text":"ExponentialSponge <: AbstractSponge\n\nSingleton for an exponentially increasing Rayleigh damping in the entire Domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.GridNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.GridNamelist","text":"GridNamelist{A <: AbstractFloat, B <: Integer}\n\nNamelist for parameters describing the grid.\n\nGridNamelist(;\n    mountainheight_dim::AbstractFloat = 1.0E+2,\n    mountainwidth_dim::AbstractFloat = 1.0E+3,\n    mountain_case::Integer = 1,\n    height_factor::AbstractFloat = 1.0E+0,\n    width_factor::AbstractFloat = 1.0E+0,\n    spectral_modes::Integer = 1,\n    stretch_exponent::AbstractFloat = 1.0E+0,\n)::GridNamelist\n\nConstruct a GridNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nmountainheight_dim::A: Mountain height (summit).\nmountainwidth_dim::A: Mountain half-width.\nmountain_case::B: Mountain shape. See PinCFlow.Types.FoundationalTypes.compute_topography for available options.\nheight_factor::A: Factor between the amplitudes of the large and small orographic features.\nwidth_factor::A: Factor between the wavelengths of the large and small orographic features.\nspectral_modes::B: Number of spectral modes used for mountain_case == 13.\nstretch_exponent::A: Vertical-grid-stretching parameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Isothermal","page":"Types","title":"PinCFlow.Types.NamelistTypes.Isothermal","text":"Isothermal <: AbstractBackground\n\nSingleton for an isothermal atmosphere in pseudo-incompressible or compressible mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.LinearTracer","page":"Types","title":"PinCFlow.Types.NamelistTypes.LinearTracer","text":"LinearTracer <: AbstractTracer\n\nSingleton for model configurations with an initially linear tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.MCVariant","page":"Types","title":"PinCFlow.Types.NamelistTypes.MCVariant","text":"MCVariant <: AbstractLimiter\n\nSingleton for the MC-Variant limiter function (used in reconstruction).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.MountainWave","page":"Types","title":"PinCFlow.Types.NamelistTypes.MountainWave","text":"MountainWave <: AbstractTestCase\n\nSingleton for mountain-wave test cases.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.MultiColumn","page":"Types","title":"PinCFlow.Types.NamelistTypes.MultiColumn","text":"MultiColumn <: AbstractWKBMode\n\nSingleton for the multi-column approximation in MSGWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Namelists","page":"Types","title":"PinCFlow.Types.NamelistTypes.Namelists","text":"Namelists{\n    A <: DomainNamelist,\n    B <: OutputNamelist,\n    C <: SettingNamelist,\n    D <: DiscretizationNamelist,\n    E <: PoissonNamelist,\n    F <: AtmosphereNamelist,\n    G <: GridNamelist,\n    H <: SpongeNamelist,\n    I <: WKBNamelist,\n    J <: TracerNamelist,\n}\n\nCollection of all configurable model parameters.\n\nNamelists(;\n    domain::DomainNamelist = DomainNamelist(),\n    output::OutputNamelist = OutputNamelist(),\n    setting::SettingNamelist = SettingNamelist(),\n    discretization::DiscretizationNamelist = DiscretizationNamelist(),\n    poisson::PoissonNamelist = PoissonNamelist(),\n    atmosphere::AtmosphereNamelist = AtmosphereNamelist(),\n    grid::GridNamelist = GridNamelist(),\n    sponge::SpongeNamelist = SpongeNamelist(),\n    wkb::WKBNamelist = WKBNamelist(),\n    tracer::TracerNamelist = TracerNamelist(),\n)::Namelists\n\nConstruct a Namelists instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ndomain::A: Namelist for parameters describing the model domain.\noutput::B: Namelist for I/O parameters.\nsetting::C: Namelist for parameters describing the general model setting.\ndiscretization::D: Namelist for parameters describing discretization.\npoisson::E: Namelist for parameters used by the Poisson solver.\natmosphere::F: Namelist for parameters describing the atmospheric background.\ngrid::G: Namelist for parameters describing the grid.\nsponge::H: Namelist for parameters describing the sponge.\nwkb::I: Namelist for parameters used by MSGWaM.\ntracer::J: Namelist for parameters configuring tracer transport.\n\nSee also\n\nPinCFlow.Types.NamelistTypes.DomainNamelist\nPinCFlow.Types.NamelistTypes.OutputNamelist\nPinCFlow.Types.NamelistTypes.SettingNamelist\nPinCFlow.Types.NamelistTypes.DiscretizationNamelist\nPinCFlow.Types.NamelistTypes.PoissonNamelist\nPinCFlow.Types.NamelistTypes.AtmosphereNamelist\nPinCFlow.Types.NamelistTypes.GridNamelist\nPinCFlow.Types.NamelistTypes.SpongeNamelist\nPinCFlow.Types.NamelistTypes.WKBNamelist\nPinCFlow.Types.NamelistTypes.TracerNamelist\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.NoTracer","page":"Types","title":"PinCFlow.Types.NamelistTypes.NoTracer","text":"NoTracer <: AbstractTracer\n\nSingleton for model configurations without a tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.OutputNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.OutputNamelist","text":"OutputNamelist{\n    A <: Tuple{Vararg{Symbol}},\n    B <: Bool,\n    C <: Integer,\n    D <: AbstractFloat,\n    E <: AbstractString,\n}\n\nNamelist for I/O parameters.\n\nOutputNamelist(;\n    output_variables::Tuple{Vararg{Symbol}} = (),\n    save_ray_volumes::Bool = false,\n    prepare_restart::Bool = false,\n    restart::Bool = false,\n    iin::Integer = -1,\n    output_steps::Bool = false,\n    noutput::Integer = 1,\n    maxiter::Integer = 1,\n    outputtimediff::AbstractFloat = 3.6E+3,\n    maxtime::AbstractFloat = 3.6E+3,\n    input_file::AbstractString = \"./pincflow_input.h5\",\n    output_file::AbstractString = \"./pincflow_output.h5\",\n)::OutputNamelist\n\nConstruct an OutputNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\noutput_variables::A: A tuple of symbols representing the variables that should be written to the output file.\nsave_ray_volumes::B: A boolean indicating whether to write ray-volume data.\nprepare_restart::B: A boolean indicating whether to write all variables needed for restart simulations.\nrestart::B: A boolean indicating whether to initialize with data from a previous state (as written in input_file).\niin::C: Temporal index in input_file at which to read the data to initialize with in restart simulations.\noutput_steps::B: If set to true, write output every noutput time steps.\nnoutput::C: Output interval (in indices) if output_steps == true.\nmaxiter::C: Maximum number of iterations if output_steps == true.\noutputtimediff::D: Output interval (in physical time) if output_steps == false.\nmaxtime::D: Simulation time if output_steps == false.\ninput_file::E: File from which to read input data in restart simulations.\noutput_file::E: File to which output data is written.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.PoissonNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.PoissonNamelist","text":"PoissonNamelist{A <: AbstractFloat, B <: Integer, C <: Bool}\n\nNamelist for parameters used by the Poisson solver.\n\nPoissonNamelist(;\n    tolpoisson::AbstractFloat = 1.0E-8,\n    maxiterpoisson::Integer = 1000,\n    preconditioner::Bool = true,\n    dtau::AbstractFloat = 1.0E+0,\n    maxiteradi::Integer = 2,\n    initialcleaning::Bool = true,\n    relative_tolerance::Bool = false,\n)::PoissonNamelist\n\nConstruct a PoissonNamelists instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ntolpoisson::A: Tolerance for the convergence criterion of the Poisson solver.\nmaxiterpoisson::B: Maximum number of iterations performed by the Poisson solver before it terminates regardless of convergence.\npreconditioner::C: Whether to use a preconditioner to accelerate the convergence of the Poisson solver.\ndtau::A: Pseudo-time step coefficient used by the preconditioner.\nmaxiteradi::B: Number of iterations performed by the preconditioner.\ninitialcleaning::C: Whether to solve the Poisson problem at initialization to guarantee an initially divergence-free state.\nrelative_tolerance::C: If set to true, the tolerance used for the convergence criterion is given by tolpoisson. If set to false, the tolerance is given by tolpoisson divided by a reference value determined from the right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.PolynomialSponge","page":"Types","title":"PinCFlow.Types.NamelistTypes.PolynomialSponge","text":"PolynomialSponge <: AbstractSponge\n\nSingleton for a sponge configuration with polynomial profiles.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.PseudoIncompressible","page":"Types","title":"PinCFlow.Types.NamelistTypes.PseudoIncompressible","text":"PseudoIncompressible <: AbstractModel\n\nSingleton for pseudo-incompressible dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SettingNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.SettingNamelist","text":"SettingNamelist{A <: AbstractModel, B <: AbstractTestCase}\n\nNamelist for parameters describing the general model setting.\n\nSettingNamelist(;\n    model::AbstractModel = PseudoIncompressible(),\n    testcase::AbstractTestCase = MountainWave(),\n)::SettingNamelist\n\nConstruct a SettingNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nmodel::A: Dynamic equations.\ntestcase::B: Test case on which the current simulation is based.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Shapiro","page":"Types","title":"PinCFlow.Types.NamelistTypes.Shapiro","text":"Shapiro <: AbstractWKBFilter\n\nSingleton for a Shapiro filter as smoothing method applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SingleColumn","page":"Types","title":"PinCFlow.Types.NamelistTypes.SingleColumn","text":"SingleColumn <: AbstractWKBMode\n\nSingleton for the single-column approximation in MSGWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SinusoidalSponge","page":"Types","title":"PinCFlow.Types.NamelistTypes.SinusoidalSponge","text":"SinusoidalSponge <: AbstractSponge\n\nSingleton for a sponge configuration with sinusoidal profiles.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SpongeNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.SpongeNamelist","text":"SpongeNamelist{\n    A <: Bool,\n    B <: AbstractFloat,\n    C <: AbstractSponge,\n    D <: Integer,\n    E <: NTuple{3, <:AbstractFloat},\n}\n\nNamelist for parameters describing the sponge.\n\nSpongeNamelist(;\n    spongelayer::Bool = false,\n    sponge_uv::Bool = false,\n    spongeheight::AbstractFloat = 5.0E-1,\n    alpharmax::AbstractFloat = 0.0E+0,\n    betarmax::AbstractFloat = 1.0E+0,\n    lateralsponge::Bool = false,\n    spongetype::AbstractSponge = PolynomialSponge(),\n    spongeorder::Integer = 1,\n    cosmosteps::Integer = 1,\n    relax_to_mean::Bool = true,\n    perturbation_period::AbstractFloat = 0.0E+0,\n    perturbation_amplitude::AbstractFloat = 0.0E+0,\n    relaxation_wind::NTuple{3, <:AbstractFloat} = (0.0E+0, 0.0E+0, 0.0E+0),\n)::SpongeNamelist\n\nConstruct a SpongeNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nspongelayer::A: Switch for enabling Rayleigh-damping in the sponges.\nsponge_uv::A: Switch for applying the RHS sponge to the horizontal wind.\nspongeheight::B: Fractional vertical extent of the sponge.\nalpharmax::B: Rayleigh-damping coefficient of the LHS sponge.\nbetarmax::B: Rayleigh-damping coefficient of the RHS sponge, multiplied by the time step.\nlateralsponge::A: Switch for the lateral LHS sponge.\nspongetype::C: Profile of the LHS sponge.\nspongeorder::D: Order of the polynomial LHS sponge.\ncosmosteps::D: Factor by which the time step is multiplied in the damping coefficient of the COSMO-like LHS sponge.\nrelax_to_mean::A: Switch for relaxing the wind towards its averages on the terrain-following surfaces. If set to false, the wind is relaxed towards relaxation_wind.\nperturbation_period::B: Period of an oscillating perturbation on top of relaxation_wind.\nperturbation_amplitude::B: Amplitude of an oscillating perturbation on top of relaxation_wind.\nrelaxation_wind::E: Wind to be obtained through Rayleigh damping in the LHS sponge.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SteadyState","page":"Types","title":"PinCFlow.Types.NamelistTypes.SteadyState","text":"SteadyState <: AbstractWKBMode\n\nSingleton for the steady-state approximation in MSGWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.StratifiedBoussinesq","page":"Types","title":"PinCFlow.Types.NamelistTypes.StratifiedBoussinesq","text":"StratifiedBoussinesq <: AbstractBackground\n\nSingleton for a Boussinesq atmosphere with stratification.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.TracerNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.TracerNamelist","text":"TracerNamelist{A <: AbstractTracer, B <: Bool, C <: AbstractFloat}\n\nNamelist for the inclusion of a tracer and the calculation of the leading-order gravity-wave impact.\n\nTracerNamelist(;\n    tracersetup::AbstractTracer = NoTracer(),\n    leading_order_impact::Bool = false,\n    alphatracer::AbstractFloat = 1.0E+0,\n)::TracerNamelist\n\nConstruct a TracerNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ntracersetup::A: General tracer configuration.\nleading_order_impact::B: Flag to include the leading-order impact of gravity waves when parameterizing waves with the WKB model.\nalphatracer::C: Scaling parameter for the initial tracer distribution.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.UniformBoussinesq","page":"Types","title":"PinCFlow.Types.NamelistTypes.UniformBoussinesq","text":"UniformBoussinesq <: AbstractBackground\n\nSingleton for a Boussinesq atmosphere without stratification.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.WKBMountainWave","page":"Types","title":"PinCFlow.Types.NamelistTypes.WKBMountainWave","text":"WKBMountainWave <: AbstractWKBTestCase\n\nSingleton for WKB-mountain-wave test cases.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.WKBNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.WKBNamelist","text":"WKBNamelist{\n    A <: AbstractFloat,\n    B <: Integer,\n    C <: AbstractMergeMode,\n    D <: Bool,\n    E <: AbstractWKBFilter,\n    F <: AbstractWKBMode,\n}\n\nNamelist for parameters used by MSGWaM.\n\nWKBNamelist(;\n    xrmin_dim::AbstractFloat = 0.0E+0,\n    xrmax_dim::AbstractFloat = 1.0E+3,\n    yrmin_dim::AbstractFloat = 0.0E+0,\n    yrmax_dim::AbstractFloat = 1.0E+3,\n    zrmin_dim::AbstractFloat = 0.0E+0,\n    zrmax_dim::AbstractFloat = 1.0E+3,\n    nrxl::Integer = 1,\n    nryl::Integer = 1,\n    nrzl::Integer = 1,\n    nrk_init::Integer = 1,\n    nrl_init::Integer = 1,\n    nrm_init::Integer = 1,\n    nray_fac::Integer = 4,\n    fac_dk_init::AbstractFloat = 1.0E-1,\n    fac_dl_init::AbstractFloat = 1.0E-1,\n    fac_dm_init::AbstractFloat = 1.0E-1,\n    branchr::Integer = -1,\n    merge_mode::AbstractMergeMode = ConstantWaveAction(),\n    nsmth_wkb::Integer = 2,\n    lsmth_wkb::Bool = true,\n    sm_filter::AbstractWKBFilter = Shapiro(),\n    zmin_wkb_dim::AbstractFloat = 0.0E+0,\n    lsaturation::Bool = true,\n    alpha_sat::AbstractFloat = 1.0E+0,\n    wkb_mode::AbstractWKBMode = MultiColumn(),\n    blocking::Bool = false,\n    long_threshold::AbstractFloat = 2.5E-1,\n    drag_coefficient::AbstractFloat = 1.0E+0,\n    nwm::Integer = 1,\n)::WKBNamelist\n\nConstruct a WKBNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\nxrmin_dim::A: Lower bound in x of the region where ray volumes are initialized.\nxrmax_dim::A: Upper bound in x of the region where ray volumes are initialized.\nyrmin_dim::A: Lower bound in y of the region where ray volumes are initialized.\nyrmax_dim::A: Upper bound in y of the region where ray volumes are initialized.\nzrmin_dim::A: Lower bound in z of the region where ray volumes are initialized.\nzrmax_dim::A: Upper bound in z of the region where ray volumes are initialized.\nnrxl::B: Number of ray-volumes launched per grid cell and wave mode in widehatx-direction.\nnryl::B: Number of ray-volumes launched per grid cell and wave mode in widehaty-direction.\nnrzl::B: Number of ray-volumes launched per grid cell and wave mode in widehatz-direction.\nnrk_init::B: Number of ray-volumes launched per grid cell and wave mode in k-direction.\nnrl_init::B: Number of ray-volumes launched per grid cell and wave mode in l-direction.\nnrm_init::B: Number of ray-volumes launched per grid cell and wave mode in m-direction.\nnray_fac::B: Factor by which ray volumes are allowed to multiply in each dimension of physical space.\nfac_dk_init::A: Relative initial ray-volume extent in k.\nfac_dl_init::A: Relative initial ray-volume extent in l.\nfac_dm_init::A: Relative initial ray-volume extent in m.\nbranchr::B: Frequency branch.\nmerge_mode::C: Ray-volume merging strategy (conserved quantity).\nnsmth_wkb::B: Order of the smoothing applied to the mean-flow tendencies.\nlsmth_wkb::D: Switch for smoothing the mean-flow tendencies.\nsm_filter::E: Filter to use for the smoothing of the mean-flow tendencies.\nzmin_wkb_dim::A: Minimum altitude for ray-tracing and mean-flow impact.\nlsaturation::D: Switch for the saturation scheme.\nalpha_sat::A: Relative saturation threshold.\nwkb_mode::F: Approximations used by MSGWaM.\nblocking::D: Switch for parameterizing blocking in WKB-mountain-wave simulations.\nlong_threshold::A: Long-number threshold used by the blocked-layer scheme.\ndrag_coefficient::A: Dimensionless (relative) drag coefficient used by the blocked layer scheme.\nnwm::B: Number of wave modes per grid cell.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#FoundationalTypes","page":"Types","title":"FoundationalTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes","page":"Types","title":"PinCFlow.Types.FoundationalTypes","text":"FoundationalTypes\n\nModule that contains the composite types Time, Constants, Domain, Grid, Atmosphere and Sponge.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Atmosphere","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Atmosphere","text":"Atmosphere{A <: AbstractArray{<:AbstractFloat, 3}}\n\nComposite type for atmospheric background fields.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n)::Atmosphere\n\nCreate an Atmosphere instance by dispatching to a method specific for the background and dynamic equations set in namelists.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Boussinesq,\n    background::UniformBoussinesq,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a uniform (i.e. neutral) Boussinesq atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    overlinerho  = rho_0  overlinetheta  = theta_0  P  = overlinerho overlinetheta  N^2  = 0\nendalign*\n\nwhere rho_0 and theta_0 are given by constants.rhoref and namelists.atmosphere.theta0_dim, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Boussinesq,\n    background::StratifiedBoussinesq,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a stratified Boussinesq atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    overlinerho  = rho_0  overlinetheta  = theta_0  P  = overlinerho overlinetheta  N^2  = N_0^2\nendalign*\n\nwhere rho_0, theta_0 and N_0 are given by constants.rhoref, namelists.atmosphere.theta0_dim and namelists.atmosphere.buoyancy_frequency, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::AbstractModel,\n    background::Isothermal,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing an isothermal atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    P left(zright)  = p_0 exp left(- fracsigma zgamma T_0right)\n    overlinetheta left(zright)  = T_0 exp left(frackappa sigma zT_0right)\n    overlinerho left(zright)  = fracP left(zright)overlinetheta left(zright)\n    N^2  = fracgoverlinetheta fracoverlinetheta_k + 1 - overlinetheta_k - 12 J Delta widehatz\nendalign*\n\nwhere p_0, T_0, sigma, gamma and kappa are given by namelists.atmosphere.press0_dim, namelists.atmosphere.temp0_dim, constants.sig, constants.gamma and constants.kappa, respectively.\n\nFields\n\npstrattfc::A: Mass-weighted potential temperature P left(zright) (P left(x y z tright) in compressible mode).\nthetastrattfc::A: Background potential temperature overlinetheta left(zright).\nrhostrattfc::A: Background density overlinerho left(zright).\nbvsstrattfc::A: Squared buoyancy frequency N^2 left(zright).\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\nmodel: Dynamic equations.\nbackground: Atmospheric background.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Constants","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Constants","text":"Constants{A <: AbstractFloat}\n\nComposite type for natural constants, reference quantities and non-dimensional parameters.\n\nConstants(namelists::Namelists)::Constants\n\nCreate a Constants instance.\n\nThe Reynolds number is the only constant that depends on the model parameters in namelists. If namelists.atmosphere.specifyreynolds is false, the Reynolds number is mathrmRe = L_mathrmref u_mathrmref  mu, with mu being the kinematic viscosity at the surface, given by namelists.atmosphere.mu_viscous_dim. Otherwise, it is set to the inverse of namelists.atmosphere.reinv.\n\nFields\n\nNatural constants:\n\ngamma::A: Ratio of specific heats gamma = c_p  c_V = 14.\ngammainv::A: Inverse ratio of specific heats 1  gamma.\nkappa::A: Ratio between specific gas constant and specific heat capacity at constant pressure kappa = left(gamma - 1right)  gamma = R  c_p = 2  7.\nkappainv::A: Ratio between specific heat capacity at constant pressure and specific gas constant 1  kappa.\nrsp::A: Specific gas constant R = 287  mathrmJ  kg^- 1  K^- 1.\ng::A: Gravitational acceleration g = 981  mathrmm  s^- 2.\n\nReference quantities:\n\nrhoref::A: Reference density rho_mathrmref = 1184  mathrmkg  m^- 3.\npref::A: Reference pressure p_mathrmref = 101325  mathrmPa.\naref::A: Reference sound speed c_mathrmref = sqrtp_mathrmref  rho_mathrmref.\nuref::A: Reference wind u_mathrmref = a_mathrmref.\nlref::A: Reference length L_mathrmref = p_mathrmref left(g rho_mathrmrefright).\ntref::A: Reference time t_mathrmref = L_mathrmref  a_mathrmref.\nthetaref::A: Reference potential temperature theta_mathrmref = a_mathrmref^2  R.\nfref::A: Reference body force F_mathrmref = rho_mathrmref u_mathrmref^2  L_mathrmref.\n\nNon-dimensional parameters\n\ng_ndim::A: Non-dimensional gravitational acceleration widehatg = g L_mathrmref  u_mathrmref^2.\nre::A: Reynolds number mathrmRe = L_mathrmref u_mathrmref  mu (with mu being the kinematic viscosity at the surface).\nma::A: Mach number mathrmMa = u_mathrmref  a_mathrmref.\nmainv2::A: Inverse Mach number squared mathrmMa^- 2.\nma2::A: Mach number squared mathrmMa^2.\nfr::A: Froude number mathrmFr = u_mathrmref  sqrtg L_mathrmref.\nfrinv2::A: Inverse Froude number squared mathrmFr^- 2.\nfr2::A: Froude number squared mathrmFr^2.\nsig::A: Ratio between squared Mach number and squared Froude number sigma = mathrmMa^2  mathrmFr^2.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Domain","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Domain","text":"Domain{A <: MPI.Comm, B <: Bool, C <: Integer}\n\nCollection of domain-decomposition and MPI-communication parameters.\n\nDomain(namelists::Namelists)::Domain\n\nConstruct a Domain instance from the model parameters in namelists.\n\nIf namelists.domain.base_comm is equal to MPI.COMM_WORLD, this method first initializes the MPI parallelization by calling MPI.Init(). It then creates a Cartesian topology from the base communicator, with periodic boundaries in the first two dimensions (widehatx and widehaty) but not in the last (widehatz). The domain is divided into corresponding subdomains, where in each direction, the number of grid points (nx, ny and nz) is the result of floor division of the global grid size (namelists.domain.sizex, namelists.domain.sizey and namelists.domain.sizez) by the number of processes in that direction (namelists.domain.npx, namelists.domain.npy and namelists.domain.npz). The remainder of the floor division is included in the grid-point count of the last processes (in each direction). The index bounds ((i0, i1), (j0, j1) and (k0, k1)) are set such that they exclude the first and last namelists.domain.nbx, namelists.domain.nby and namelists.domain.nbz cells in widehatx, widehaty and widehatz, respectively (these are not included in nx, ny and nz).\n\nFields\n\nGeneral MPI communication:\n\ncomm::A: MPI communicator with Cartesian topology for the computational domain.\nmaster::B: Boolean flag indicating if this process is the master process (rank 0).\nrank::C: MPI rank of this process within the communicator comm.\nroot::C: Root process rank (0).\n\nDimensions of the MPI subdomain:\n\nnx::C: Number of physical grid points in widehatx-direction.\nny::C: Number of physical grid points in widehaty-direction.\nnz::C: Number of physical grid points in widehatz-direction.\nnxx::C: Number of computational grid points in widehatx-direction (including halo/boundary cells).\nnyy::C: Number of computational grid points in widehaty-direction (including halo/boundary cells).\nnzz::C: Number of computational grid points in widehatz-direction (including halo/boundary cells).\n\nDimensions of the entire domain:\n\nsizexx::C: Number of computational grid points in widehatx-direction (including halo/boundary cells).\nsizeyy::C: Number of computational grid points in widehaty-direction (including halo/boundary cells).\nsizezz::C: Number of computational grid points in widehatz-direction (including halo/boundary cells).\n\nIndex offsets and bounds:\n\nio::C: MPI offset in widehatx-direction.\njo::C: MPI offset in widehaty-direction.\nko::C: MPI offset in widehatz-direction.\ni0::C: First physical grid cell of the subdomain in widehatx-direction.\ni1::C: Last physical grid cell of the subdomain in widehatx-direction.\nj0::C: First physical grid cell of the subdomain in widehaty-direction.\nj1::C: Last physical grid cell of the subdomain in widehaty-direction.\nk0::C: First physical grid cell of the subdomain in widehatz-direction.\nk1::C: Last physical grid cell of the subdomain in widehatz-direction.\n\nNeighbor-process ranks:\n\nleft::C: Rank of the next process to the left (negative x-direction).\nright::C: Rank of the next process to the right (positive x-direction).\nbackward::C: Rank of the next process to the back (negative y-direction).\nforward::C: Rank of the next process to the front (positive y-direction).\ndown::C: Rank of the next process to the bottom (negative z-direction).\nup::C: Rank of the next process to the top (positive z-direction).\n\nHorizontal and vertical communication:\n\nlayer_comm::A: MPI communicator for processes in the same layer (i.e. with the same vertical index).\ncolumn_comm::A: MPI communicator for processes in the same column (i.e. with the same horizontal indices).\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Grid","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Grid","text":"Grid{\n    A <: AbstractFloat,\n    B <: AbstractVector{<:AbstractFloat},\n    C <: AbstractMatrix{<:AbstractFloat},\n    D <: AbstractArray{<:AbstractFloat, 3},\n    E <: AbstractArray{<:AbstractFloat, 3},\n    F <: AbstractArray{<:AbstractFloat, 5},\n}\n\nCollection of parameters and fields that describe the grid.\n\nGrid(namelists::Namelists, constants::Constants, domain::Domain)::Grid\n\nConstruct a Grid instance, using the specifications in namelists.grid and the MPI decomposition described by domain.\n\nThis constructor creates a 3D parallelized grid for a terrain-following, vertically stretched coordinate system. The global computational grid is defined by\n\nbeginalign*\n    widehatx_i  = - L_x  2 + left(i - i_0 + frac12right) Delta widehatx\n    widehaty_j  = - L_y  2 + left(j - j_0 + frac12right) Delta widehaty\n    widehatz_k  = left(k - k_0 + frac12right) Delta widehatz\nendalign*\n\nwhere left(L_x L_yright), left(i_0 j_0 k_0right) and left(Delta widehatx Delta widehaty Delta widehatzright) are the horizontal extents of the domain, the lower index bounds of the MPI subdomains and the grid spacings (determined from the total extents and grid-point counts of the domain), respectively. Throughout the documentation, the position of any variable on this grid is indicated with the indices left(i j kright) in its subscript. Therein, unshifted indices are omitted for the sake of brevity. The grid is staggered, i.e. the wind components are defined at the midpoints of those cell surfaces that are orthogonal to their respective directions. Interpolations are therefore necessary in many places. These are indicated as in\n\nbeginalign*\n    rho_i + 1  2  = fracrho + rho_i + 12  rho_j + 1  2  = fracrho + rho_j + 12  rho_k + 1  2  = fracJ_k + 1 rho + J rho_k + 1J_k + 1 + J\n    u  = fracu_i - 1  2 + u_i + 1  22  u_j + 1  2  = fracu + u_j + 12  u_k + 1  2  = fracJ_k + 1 u + J u_k + 1J_k + 1 + J\n    v_i + 1  2  = fracv + v_i + 12  v  = fracv_j - 1  2 + v_j + 1  22  v_k + 1  2  = fracJ_k + 1 v + J v_k + 1J_k + 1 + J\n    widehatw_i + 1  2  = fracwidehatw + widehatw_i + 12  widehatw_j + 1  2  = fracwidehatw + widehatw_j + 12  widehatw  = fracwidehatw_k - 1  2 + widehatw_k + 1  22\nendalign*\n\nThe vertical layer centers and edges of the stretched and physical grids are given by\n\nbeginalign*\n    widetildez_k + 1  2  = L_z left(fracwidehatz_k + 1  2L_zright)^s  z_k + 1  2  = fracL_z - hL_z widetildez_k + 1  2 + h\n    widetildez  = fracwidetildez_k + 1  2 + widetildez_k - 1  22  z  = fracL_z - hL_z widetildez + h\nendalign*\n\nwhere L_z, s and h are the vertical extent of the domain (namelists.domain.lz_dim), the vertical-stretching parameter (namelists.grid.stretch_exponent) and the surface topography (as returned by compute_topography), respectively. Finally, the Jacobian is\n\nJ = fracL_z - hL_z fracwidetildez_k + 1  2 - widetildez_k - 1  2Delta widehatz\n\nand the non-Cartesian elements of the metric tensor are\n\nbeginalign*\n    G^1 3  = frach_mathrmb i + 1 - h_mathrmb i - 12 Delta widehatx fracwidetildez - L_zL_z - h fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2\n    G^2 3  = frach_mathrmb j + 1 - h_mathrmb j - 12 Delta widehaty fracwidetildez - L_zL_z - h fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2\n    G^3 3  = leftleft(fracL_zL_z - hright)^2 + left(fracwidetildez - L_zL_z - hright)^2 leftleft(frach_mathrmb i + 1 - h_mathrmb i - 12 Delta widehatxright)^2 + left(frach_mathrmb j + 1 - h_mathrmb j - 12 Delta widehatyright)^2rightright\n     quad times left(fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2right)^2\nendalign*\n\nFields\n\nDomain extent:\n\nlx::A: Non-dimensional domain extent in widehatx-direction.\nly::A: Non-dimensional domain extent in widehaty-direction.\nlz::A: Non-dimensional domain extent in widehatz-direction.\n\nGrid spacing:\n\ndx::A: Grid spacing Delta widehatx.\ndy::A: Grid spacing Delta widehaty.\ndz::A: Grid spacing Delta widehatz.\n\nHorizontal coordinates:\n\nx::B: Cell-centered widehatx-coordinate of the entire domain.\ny::B: Cell-centered widehaty-coordinate of the entire domain.\n\nTopography:\n\ntopography_surface::C: Resolved surface topography.\ntopography_spectrum::D: Spectrum of the unresolved surface topography.\nk_spectrum::D: Zonal wavenumbers of the spectrum.\nl_spectrum::D: Meridional wavenumbers of the spectrum.\n\nCoordinate transformation.\n\njac::E: Jacobian.\nmet::F: Metric tensor.\n\nVertical coordinates:\n\nztfc::E: Physical height at cell centers.\nztildetfc::E: Physical height at vertical cell edges.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.compute_topography\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Sponge","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Sponge","text":"Sponge{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractFloat,\n    C <: AbstractVector{<:AbstractFloat},\n}\n\nComposite type for Rayleigh-damping coefficients, sponge bounds and extents, as well as an auxiliary array for the computation of horizontal means.\n\nSponge(namelists::Namelists, domain::Domain, grid::Grid)::Sponge\n\nConstruct a Sponge instance, using the model parameters in namelists.\n\nThe vertical extent of the sponge is set to the fraction namelists.sponge.spongeheight of the vertical extent of the domain. The horizontal extents of the LHS sponge are computed similarly, using the same parameter multiplied by 0.5 (since the sponge is centered at the horizontal boundaries).\n\nFields\n\nRayleigh-damping coefficients:\n\nalphar::A: Coefficient of the LHS sponge (used in all prognostic equations).\nbetar::A: Coefficient of the RHS sponge (used in the momentum equation).\n\nVertical sponge extent:\n\nzsponge::B: Lower edge of both sponges.\ndzsponge::B: Vertical extent of both sponges.\n\nHorizontal sponge extent:\n\nxsponge0::B: Right edge of the LHS sponge.\nxsponge1::B: Left edge of the LHS sponge.\nysponge0::B: Forward edge of the LHS sponge.\nysponge1::B: Backward edge of the LHS sponge.\ndxsponge::B: Halved zonal extent of the LHS sponge.\ndysponge::B: Halved meridional extent of the LHS sponge.\n\nAuxiliary array:\n\nhorizontal_mean::C: Auxiliary array for the computation of horizontal means.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Time","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Time","text":"Time{A <: Integer, B <: NTuple{3, <:AbstractFloat}}\n\nTime integration parameters for the low-storage third-order Runge-Kutta scheme.\n\nTime()::Time\n\nConstruct a Time instance.\n\nFields\n\nnstages::A: Number of Runge-Kutta stages.\nalphark::B: Runge-Kutta coefficients for the total tendency, i.e. boldsymbolalpha_mathrmRK = left(0 - 5  9 - 153  128right).\nbetark::B: Runge-Kutta coefficients for the previous tendency, i.e. boldsymbolbeta_mathrmRK = left(1  3 15  16 8  15right).\nstepfrac::B: Time step fractions for each stage, i.e. boldsymbolf_mathrmRK = left(1  3 5  12 1  4right).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.compute_topography","page":"Types","title":"PinCFlow.Types.FoundationalTypes.compute_topography","text":"compute_topography(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    x::AbstractVector{<:AbstractFloat},\n    y::AbstractVector{<:AbstractFloat},\n    testcase::AbstractWKBTestCase,\n)::Tuple{\n    <:AbstractMatrix{<:AbstractFloat},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n}\n\nCompute and return the topography for WKB test cases.\n\nThe supported topography shapes are as follows, listed according to the value of namelists.grid.mountain_case.\n\n2D cosine mountains:\n    h_mathrmb = frach_02 quad k_h = fracpil_0 quad l_h = 0 quad h_mathrmw = frach_02\n-\n-\n-\n2D cosine envelope and even background:\nbeginalign*\n    h_mathrmb  = frach_02 quad k_h = fracpil_0 quad l_h = 0\n    h_mathrmw left(xright)  = begincases\n        frach_04 left1 + cos left(fracpi xr_l l_0right)right  mathrmif quad leftxright leq r_l l_0\n        0  mathrmelse\n    endcases\nendalign*\n-\n2D Gaussian envelope and even background:\nbeginalign*\n    h_mathrmb  = frach_02 quad k_h = fracpil_0 quad l_h = 0\n    h_mathrmw left(xright)  = frach_02 exp left(- fracx^2r_l^2 l_0^2right)\nendalign*\n-\n2D cosine envelope and cosine background:\nbeginalign*\n    h_mathrmb left(xright)  = h_mathrmw left(xright) quad k_h = fracpil_0 quad l_h = 0\n    h_mathrmw left(xright)  = begincases\n        frach_04 left1 + cos left(fracpi xr_l l_0right)right  mathrmif quad leftxright leq r_l l_0\n        0  mathrmelse\n    endcases\nendalign*\n-\n2D Gaussian envelope and Gaussian background:\nbeginalign*\n    h_mathrmb left(xright)  = h_mathrmw left(xright) quad k_h = fracpil_0 quad l_h = 0\n    h_mathrmw left(xright)  = frach_02 exp left(- fracx^2r_l^2 l_0^2right)\nendalign*\n-\n3D WKB topography:\nbeginalign*\n    h_mathrmb left(x yright)  = r_h n_h h_mathrmw left(x yright) quad k_h alpha = fracpil_0 cos left(fracpi alphan_hright) quad l_h alpha = fracpil_0 sin left(fracpi alphan_hright)\n    h_mathrmw left(x yright)  = begincases\n        frach_02 n_h left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\nendalign*\n\nTherein, h_0, l_0, r_h, r_l and n_h are given by the properties mountainheight_dim, mountainwidth_dim, height_factor, width_factor and spectral_modes of namelists.grid, respectively.\n\nThe arrays in the returned tuple represent (in order) the resolved topography, the amplitudes of the unresolved topography, the corresponding zonal wavenumbers and the corresponding meridional wavenumbers.\n\ncompute_topography(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    x::AbstractVector{<:AbstractFloat},\n    y::AbstractVector{<:AbstractFloat},\n    testcase::AbstractTestCase,\n)::Tuple{\n    <:AbstractMatrix{<:AbstractFloat},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n}\n\nCompute and return the topography for non-WKB test cases.\n\nThe supported topography shapes are as follows, listed according to the value of namelists.grid.mountain_case.\n\n2D cosine mountains:\nh left(xright) = frach_02 left1 + cos left(fracpi xl_0right)right\n3D cosine mountains:\nh left(x yright) = frach_02 left1 + cos left(fracpil_0 sqrtx^2 + y^2right)right\n2D isolated mountain:\nh left(xright) = frach_01 + x^2  l_0^2\n3D isolated mountain:\nh left(x yright) = frach_01 + left(x^2 + y^2right)  l_0^2\n2D cosine envelope and even background:\nh left(xright) = begincases\n    frach_02 left1 + frac12 left1 + cos left(fracpi xr_l l_0right)right cos left(fracpi xl_0right)right  mathrmif quad leftxright leq r_l l_0\n    frach_02  mathrmelse\nendcases\n3D cosine envelope and even background:\nh left(x yright) = begincases\n    frach_02 left1 + frac12 left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right cos left(fracpil_0 sqrtx^2 + y^2right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n    frach_02  mathrmelse\nendcases\n2D Gaussian envelope and even background:\nh left(xright) = frach_02 left1 + exp left(- fracx^2r_l^2 l_0^2right) cos left(fracpi xl_0right)right\n3D Gaussian envelope and even background:\nh left(x yright) = frach_02 left1 + exp left(- fracx^2 + y^2r_l^2 l_0^2right) cos left(fracpil_0 sqrtx^2 + y^2right)right\n2D cosine envelope and cosine background:\nh left(xright) = begincases\n    frach_04 left1 + cos left(fracpi xr_l l_0right)right left1 + cos left(fracpi xl_0right)right  mathrmif quad leftxright leq r_l l_0\n    0  mathrmelse\nendcases\n3D cosine envelope and cosine background:\nh left(x yright) = begincases\n    frach_04 left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right left1 + cos left(fracpil_0 sqrtx^2 + y^2right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n    0  mathrmelse\nendcases\n2D Gaussian envelope and Gaussian background:\nh left(xright) = frach_02 exp left(- fracx^2r_l^2 l_0^2right) left1 + cos left(fracpi xl_0right)right\n3D Gaussian envelope and Gaussian background:\nh left(x yright) = frach_02 exp left(- fracx^2 + y^2r_l^2 l_0^2right) left1 + cos left(fracpil_0 sqrtx^2 + y^2right)right\n3D WKB topography:\nsmallbeginalign*\n    h left(x yright)  = begincases\n        frach_02 left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right leftr_h + n_h^- 1 sumlimits_alpha = 0^n_h - 1 cos left(k_alpha x + l_alpha yright)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\n    k_alpha  = fracpil_0 cos left(fracpi alphan_hright) quad l_alpha = fracpil_0 sin left(fracpi alphan_hright)\nendalign*\n\nTherein, h_0, l_0, r_h, r_l and n_h are given by the properties mountainheight_dim, mountainwidth_dim, height_factor, width_factor and spectral_modes of namelists.grid, respectively. The arrays representing the unresolved spectrum are set to have the size (0, 0, 0).\n\nThe topography is represented by the first array in the returned tuple.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nx: widehatx-coordinate grid points.\ny: widehaty-coordinate grid points.\ntestcase: Test case on which the current simulation is based.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!","text":"set_meridional_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce meridional boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npy > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_meridional_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_meridional_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_meridional_halos_of_field!","text":"set_meridional_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all meridional halo values of a matrix by performing bidirectional MPI communication between backward and forward neighbor processes.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!","text":"set_vertical_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain,\n    mode::Function;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n    staggered = false,\n)\n\nEnforce vertical boundary conditions for a 3D array (assuming solid-wall boundaries).\n\nHalo exchange is used for multi-process domains (npz > 1). Use mode = + (mode = -) for line-reflected (point-reflected) ghost-cell values.\n\nset_vertical_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange halo values of a 5D array if multiple processes are used in the vertical (npz > 1).\n\nThis method is applied to reconstruction arrays. Vertical boundary conditions are not enforced for these but for the fluxes determined from them.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmode: Method used for setting the boundary-cell values.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\nstaggered: A switch for whether or not the field is on the staggered vertical grid.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_vertical_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_vertical_halos_of_field!","text":"set_vertical_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 3D array by performing MPI communication between downward and upward neighbor processes.\n\nSolid walls are assumed at the vertical boundaries of the domain. The corresponding ghost-cell values are not changed.\n\nset_vertical_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 5D array with an algorithm similar to that implemented in the above method.\n\nThe vertical domain boundaries are treated as described above. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!","text":"set_zonal_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce zonal boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npx > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_zonal_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_zonal_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_zonal_halos_of_field!","text":"set_zonal_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all zonal halo values of a matrix by performing bidirectional MPI communication between left and right neighbor processes.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#VariableTypes","page":"Types","title":"VariableTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.VariableTypes","page":"Types","title":"PinCFlow.Types.VariableTypes","text":"VariableTypes\n\nModule for composite types needed for the integration in time.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Auxiliaries","page":"Types","title":"PinCFlow.Types.VariableTypes.Auxiliaries","text":"Auxiliaries{A <: AbstractArray{<:AbstractFloat, 3}}\n\nAuxiliary array used in the reconstruction of prognostic variables.\n\nAuxiliaries(domain::Domain)::Auxiliaries\n\nConstruct an Auxiliaries instance with a zero-initialized auxiliary array sized according to the MPI subdomain dimensions.\n\nFields\n\nphi::A: Auxiliary array used as input for PinCFlow.FluxCalculator.apply_3d_muscl!.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Backups","page":"Types","title":"PinCFlow.Types.VariableTypes.Backups","text":"Backups{A <: AbstractArray{<:AbstractFloat, 3}}\n\nContainer for backup copies needed in the semi-implicit time scheme.\n\nBackups(domain::Domain)::Backups\n\nInitialize backup arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\nrhoold::A: Density backup.\nrhopold::A: Density-fluctuations backup.\nuold::A: Zonal-wind backup.\nvold::A: Meridional-wind backup.\nwold::A: Transformed-vertical-wind backup.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Fluxes","page":"Types","title":"PinCFlow.Types.VariableTypes.Fluxes","text":"Fluxes{\n    A <: AbstractArray{<:AbstractFloat, 4},\n    B <: AbstractArray{<:AbstractFloat, 4},\n}\n\nArrays for fluxes needed in the computation of the left-hand sides.\n\nThe first three dimensions represent physical space and the fourth dimension represents the flux direction.\n\nFluxes(namelists::Namelists, domain::Domain)::Fluxes\n\nConstruct a Fluxes instance with dimensions depending on whether or not the model is compressible, by dispatching to the appropriate method.\n\nFluxes(domain::Domain, model::AbstractModel)::Fluxes\n\nConstruct a Fluxes instance in non-compressible modes, with a zero-size array for mass-weighted potential-temperature fluxes.\n\nFluxes(domain::Domain, model::Compressible)::Fluxes\n\nConstruct a Fluxes instance in compressible mode.\n\nFields\n\nphirho::A: Density fluxes.\nphirhop::A: Density-fluctuations fluxes.\nphiu::A: Zonal-momentum fluxes.\nphiv::A: Meridional-momentum fluxes.\nphiw::A: Transformed-vertical-momentum fluxes.\nphip::B: Mass-weighted potential-temperature fluxes.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Increments","page":"Types","title":"PinCFlow.Types.VariableTypes.Increments","text":"Increments{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractArray{<:AbstractFloat, 3},\n}\n\nContainer for the Runge-Kutta updates of the prognostic variables, as well as the Exner-pressure update of the Poisson solver.\n\nIncrements(namelists::Namelists, domain::Domain)::Increments\n\nCreate a Increments instance with dimensions depending on whether or not the model is compressible, by dispatching to the appropriate method.\n\nIncrements(domain::Domain, model::AbstractModel)::Increments\n\nCreate a Increments instance in non-compressible modes, with a zero-size array for the mass-weighted potential-temperature update.\n\nIncrements(domain::Domain, model::Compressible)::Increments\n\nCreate a Increments instance in compressible mode.\n\nFields\n\ndrho::A: Density update.\ndrhop::A: Density-fluctuations update.\ndu::A: Zonal-momentum update.\ndv::A: Meridional-momentum update.\ndw::A: Transformed-vertical-momentum update.\ndpip::A: Exner-pressure update.\ndp::B: Mass-weighted potential-temperature update.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Predictands","page":"Types","title":"PinCFlow.Types.VariableTypes.Predictands","text":"Predictands{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractArray{<:AbstractFloat, 3},\n}\n\nArrays for prognostic variables.\n\nPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n)::Predictands\n\nConstruct a Predictands instance with dimensions and initial values depending on which test case is initialized, by dispatching to the appropriate method.\n\nPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    testcase::AbstractTestCase,\n)::Predictands\n\nConstruct a Predictands instance. The mass-weighted potential temperature p is constructed depending on the dynamic equations (see set_p).\n\nThe wind is initialized with boldsymbolu_0 (given by namelists.atmosphere.backgroundflow_dim) everywhere, whereas the density fluctuations and Exner-pressure fluctuations are initialized with zero. The array for the mass-weighted potential temperature is constructed with size (0, 0, 0).\n\nFields\n\nrho::A: Density.\nrhop::A: Density-fluctuations.\nu::A: Zonal wind.\nv::A: Meridional wind.\nw::A: Transformed vertical wind.\npip::A: Exner-pressure fluctuations.\np::B: Mass-weighted potential temperature.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\nmodel: Dynamic equations.\ntestcase: Test case on which the current simulation is based.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Reconstructions","page":"Types","title":"PinCFlow.Types.VariableTypes.Reconstructions","text":"Reconstructions{A <: AbstractArray{<:AbstractFloat, 5}}\n\nArrays for the reconstructions of prognostic variables.\n\nThe first three dimensions represent physical space, the fourth represents the physical-space dimension of the reconstruction and the fifth the two directions in which it is computed.\n\nReconstructions(domain::Domain)::Reconstructions\n\nConstruct a Reconstructions instance with zero-initialized arrays.\n\nFields\n\nrhotilde::A: Reconstructed density.\nrhoptilde::A: Reconstructed density fluctuations.\nutilde::A: Reconstructed zonal momentum.\nvtilde::A: Reconstructed meridional momentum.\nwtilde::A: Reconstructed vertical momentum.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Variables","page":"Types","title":"PinCFlow.Types.VariableTypes.Variables","text":"Variables{\n    A <: Predictands,\n    B <: Increments,\n    C <: Backups,\n    D <: Auxiliaries,\n    E <: Reconstructions,\n    F <: Fluxes,\n}\n\nContainer for arrays needed for the prediction of the prognostic variables.\n\nVariables(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n)::Variables\n\nConstruct a Variables instance, with array dimensions and initial values set according to the model configuration.\n\nFields\n\npredictands::A: Prognostic variables.\nincrements::B: Runge-Kutta increments and pressure correction.\nbackups::C: Backups of the prognostic variables needed in the semi-implicit time scheme.\nauxiliaries::D: Auxiliary array needed in the reconstruction.\nreconstructions::E: Reconstructions of the prognostic variables.\nfluxes::F: Fluxes of the prognostic variables.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\n\nSee also\n\nPinCFlow.Types.VariableTypes.Predictands\nPinCFlow.Types.VariableTypes.Increments\nPinCFlow.Types.VariableTypes.Backups\nPinCFlow.Types.VariableTypes.Auxiliaries\nPinCFlow.Types.VariableTypes.Reconstructions\nPinCFlow.Types.VariableTypes.Fluxes\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.set_p","page":"Types","title":"PinCFlow.Types.VariableTypes.set_p","text":"set_p(\n    model::AbstractModel,\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n    pstrattfc::AbstractArray{<:AbstractFloat, 3},\n)::AbstractArray{<:AbstractFloat, 3}\n\nReturn a zero-size array in non-compressible modes.\n\nIn these cases, the mass-weighted potential temperature is a background field: constant in Boussinesq mode, vertically varying in pseudo-incompressible mode.\n\nset_p(\n    model::Compressible,\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n    pstrattfc::AbstractArray{<:AbstractFloat, 3},\n)::AbstractArray{<:AbstractFloat, 3}\n\nReturn a copy of pstrattfc in compressible mode.\n\nIn compressible mode, the mass-weighted potential temperature is a prognostic variable.\n\nArguments:\n\nmode: Dynamic equations.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehatx-direction.\nnzz: Number of subdomain grid points in widehatx-direction.\npstrattfc: Mass-weighted potential temperature.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PoissonTypes","page":"Types","title":"PoissonTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes","page":"Types","title":"PinCFlow.Types.PoissonTypes","text":"PoissonTypes\n\nModule for composite types used by the Poisson solver.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.BicGStab","page":"Types","title":"PinCFlow.Types.PoissonTypes.BicGStab","text":"BicGStab{\n    A <: AbstractMatrix{<:AbstractFloat},\n    B <: AbstractArray{<:AbstractFloat, 3},\n}\n\nWorkspace arrays used by PinCFlow.PoissonSolver.apply_bicgstab!.\n\nBicGStab(domain::Domain)::BicGStab\n\nCreate a BicGStab instance with zero-initialized workspace arrays sized according to dimensions of the MPI subdomain.\n\nFields\n\nr_vm::A: Vertically-averaged residual.\np::B: Search direction.\nr0::B: Initial residual.\nrold::B: Previous residual.\nr::B: Current residual.\ns::B: Intermediate solution.\nt::B: Result of applying the linear operator to s.\nv::B: Result of applying the linear operator to p.\nmatvec::B: Intermediate result of applying the linear operator.\nv_pc::B: Output of the preconditioner.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Correction","page":"Types","title":"PinCFlow.Types.PoissonTypes.Correction","text":"Correction{A <: AbstractArray{<:AbstractFloat, 3}}\n\nCorrection terms used to update the horizontal wind in the corrector step.\n\nCorrection(domain::Domain)::Correction\n\nCreate a Correction instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\ncorx::A: Correction term for the zonal wind.\ncory::A: Correction term for the meridional wind.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Operator","page":"Types","title":"PinCFlow.Types.PoissonTypes.Operator","text":"Operator{A <: AbstractArray{<:AbstractFloat, 3}}\n\nWorkspace array for applying the linear operator of the Poisson solver.\n\nOperator(domain::Domain)::Operator\n\nCreate an Operator instance with a zero-initialized array sized according to the dimensions of the MPI subdomain.\n\nFields\n\ns::A: Auxiliary array for enforcing boundary conditions and performing MPI communication prior to the application of the linear operator.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Poisson","page":"Types","title":"PinCFlow.Types.PoissonTypes.Poisson","text":"Poisson{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: Tensor,\n    C <: Operator,\n    D <: Preconditioner,\n    E <: BicGStab,\n    F <: Correction,\n}\n\nMain container for Poisson-solver workspace and solution arrays.\n\nPoisson(domain::Domain)::Poisson\n\nCreate a Poisson instance with an initialized Poisson-solver workspace, sized according to the dimensions of the MPI subdomain.\n\nFields\n\nrhs::A: Right-hand side.\nsolution::A: Solution of the Poisson problem.\ntensor::B: Tensor elements of the linear operator.\noperator::C: Workspace arrays for applying the linear operator.\npreconditioner::D: Workspace arrays for applying the preconditioner.\nbicgstab::E: Workspace arrays used by the BicGStab algorithm.\ncorrection::F: Correction terms used to update the horizontal wind in the corrector step.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nSee also\n\nPinCFlow.Types.PoissonTypes.Tensor\nPinCFlow.Types.PoissonTypes.Operator\nPinCFlow.Types.PoissonTypes.Preconditioner\nPinCFlow.Types.PoissonTypes.BicGStab\nPinCFlow.Types.PoissonTypes.Correction\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Preconditioner","page":"Types","title":"PinCFlow.Types.PoissonTypes.Preconditioner","text":"Preconditioner{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractMatrix{<:AbstractFloat},\n}\n\nWorkspace arrays for applying the preconditioner.\n\nPreconditioner(domain::Domain)::Preconditioner\n\nCreate a Preconditioner instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\ns_pc::A: Solution computed by the preconditioner.\nq_pc::A: Auxiliary array used for the upward sweep.\np_pc::B: Auxiliary array used for the upward sweep and downward pass.\ns_pc_bc::B: MPI communication buffer for s_pc.\nq_pc_bc::B: MPI communication buffer for q_pc.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Tensor","page":"Types","title":"PinCFlow.Types.PoissonTypes.Tensor","text":"Tensor{A <: AbstractArray{<:AbstractFloat, 3}}\n\nTensor elements of the linear operator, as computed by PinCFlow.PoissonSolver.compute_operator!.\n\nTensor(domain::Domain)::Tensor\n\nCreate a Tensor instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\nac_b::A: Coefficient applied to s.\nal_b::A: Coefficient applied to s_i - 1.\nar_b::A: Coefficient applied to s_i + 1.\nab_b::A: Coefficient applied to s_j - 1.\naf_b::A: Coefficient applied to s_j + 1.\nad_b::A: Coefficient applied to s_k - 1.\nau_b::A: Coefficient applied to s_k + 1.\nald_b::A: Coefficient applied to s_i - 1 k - 1.\nalu_b::A: Coefficient applied to s_i - 1 k + 1.\nard_b::A: Coefficient applied to s_i + 1 k - 1.\naru_b::A: Coefficient applied to s_i + 1 k + 1.\nabd_b::A: Coefficient applied to s_j - 1 k - 1.\nabu_b::A: Coefficient applied to s_j - 1 k + 1.\nafd_b::A: Coefficient applied to s_j + 1 k - 1.\nafu_b::A: Coefficient applied to s_j + 1 k + 1.\nadd_b::A: Coefficient applied to s_k - 2.\nauu_b::A: Coefficient applied to s_k + 2.\naldd_b::A: Coefficient applied to s_i - 1 k - 2.\naluu_b::A: Coefficient applied to s_i - 1 k + 2.\nardd_b::A: Coefficient applied to s_i + 1 k - 2.\naruu_b::A: Coefficient applied to s_i + 1 k + 2.\nabdd_b::A: Coefficient applied to s_j - 1 k - 2.\nabuu_b::A: Coefficient applied to s_j - 1 k + 2.\nafdd_b::A: Coefficient applied to s_j + 1 k - 2.\nafuu_b::A: Coefficient applied to s_j + 1 k + 2.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#WKBTypes","page":"Types","title":"WKBTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.WKBTypes","page":"Types","title":"PinCFlow.Types.WKBTypes","text":"WKBTypes\n\nModule that contains a collection of types for WKB ray tracing calculations including ray data structures, surface indices, integrals, tendencies, and increments.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.VariableTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.MergedRays","page":"Types","title":"PinCFlow.Types.WKBTypes.MergedRays","text":"MergedRays{\n    A <: AbstractMatrix{<:AbstractFloat},\n    B <: AbstractVector{<:AbstractFloat},\n}\n\nComposite type used for creating merged ray volumes.\n\nMergedRays(bounds::Integer, count::Integer)::MergedRays\n\nConstruct a MergedRays instance, with arrays sized according to the given dimensions.\n\nFields\n\nxr::A: Outermost ray-volume bounds in x.\nyr::A: Outermost ray-volume bounds in y.\nzr::A: Outermost ray-volume bounds in z.\nkr::A: Outermost ray-volume bounds in k.\nlr::A: Outermost ray-volume bounds in l.\nmr::A: Outermost ray-volume bounds in m.\nnr::B: Wave-action integral.\n\nArguments\n\nbounds: Number of bounds in each dimension.\ncount: Maximum ray-volume count per grid cell.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.Rays","page":"Types","title":"PinCFlow.Types.WKBTypes.Rays","text":"Rays{A <: AbstractArray{<:AbstractFloat, 4}}\n\nContainer for prognostic ray-volume properties.\n\nRays(nray_wrk::Integer, nxx::Integer, nyy::Integer, nzz::Integer)::Rays\n\nConstruct a Rays instance, with arrays sized according to the given dimensions.\n\nFields\n\nx::A: Position in x.\ny::A: Position in y.\nz::A: Position in z.\nk::A: Position in k.\nl::A: Position in l.\nm::A: Position in m.\ndxray::A: Extent in x.\ndyray::A: Extent in y.\ndzray::A: Extent in z.\ndkray::A: Extent in k.\ndlray::A: Extent in l.\ndmray::A: Extent in m.\ndens::A: Phase-space wave-action density.\n\nArguments\n\nnray_wrk: Size of the spectral dimension of ray-volume arrays.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.SurfaceIndices","page":"Types","title":"PinCFlow.Types.WKBTypes.SurfaceIndices","text":"SurfaceIndices{A <: AbstractArray{<:Integer, 3}, B <: AbstractVector{<:Integer}}\n\nIndices that connect orographic wave modes to the corresponding ray volumes launched by PinCFlow.MSGWaM.RaySources.activate_orographic_source!.\n\nSurfaceIndices(n_sfc::Integer, nxx::Integer, nyy::Integer)::SurfaceIndices\n\nConstruct a SurfaceIndices instance, with arrays sized according to the given dimensions.\n\nFields\n\nrs::A: Ray-volume indices.\nixs::B: Zonal indices within grid cells.\njys::B: Meridional indices within grid cells.\nkzs::B: Vertical indices within grid cells.\niks::B: Indices in k.\njls::B: Indices in l.\nkms::B: Indices in m.\nalphas::B: Wave-mode indices.\n\nArguments\n\nn_sfc: Number of orographic wave modes per grid cell.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKB","page":"Types","title":"PinCFlow.Types.WKBTypes.WKB","text":"WKB{\n    A <: Integer,\n    B <: AbstractArray{<:Integer, 3},\n    C <: Rays,\n    D <: MergedRays,\n    E <: SurfaceIndices,\n    F <: WKBIncrements,\n    G <: WKBIntegrals,\n    H <: WKBTendencies,\n    I <: Ref{<:AbstractFloat},\n    J <: AbstractArray{<:AbstractFloat, 3},\n    K <: AbstractMatrix{<:AbstractFloat},\n}\n\nMain container for WKB ray-tracing data and parameters.\n\nWKB(namelists::Namelists, constants::Constants, domain::Domain, grid::Grid)::WKB\n\nConstruct a WKB instance by dispatching to a test-case-specific method.\n\nWKB(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    testcase::AbstractTestCase,\n)::WKB\n\nConstruct a WKB instance with zero-size arrays for non-WKB test cases.\n\nWKB(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    testcase::AbstractWKBTestCase,\n)::WKB\n\nConstruct a WKB instance.\n\nThis method primarily determines the size of the spectral dimension of ray-volume arrays and initializes them and related arrays (with zeros) accordingly. The proper initialization with nonzero wave action is performed by PinCFlow.MSGWaM.RayUpdate.initialize_rays!.\n\nFields\n\nnxray::A: Number of ray volumes allowed in widehatx, per grid cell and wave mode (nray_fac * nrxl * nrk_init, taken from namelists.wkb).\nnyray::A: Number of ray volumes allowed in widehaty, per grid cell and wave mode (nray_fac * nryl * nrl_init, taken from namelists.wkb).\nnzray::A: Number of ray volumes allowed in widehatz, per grid cell and wave mode (nray_fac * nrzl * nrm_init, taken from namelists.wkb).\nnxray_wrk::A: 2 * nxray.\nnyray_wrk::A: 2 * nyray.\nnzray_wrk::A: 2 * nzray.\nnray_max::A: Maximum ray-volume count allowed per grid-cell before merging is triggered (nxray * nyray * nzray * namelists.wkb.nwm).\nnray_wrk::A: Size of the spectral dimension of ray-volume arrays (nxray_wrk * nyray_wrk * nzray_wrk).\nn_sfc::A: Number of orographic wave modes.\nnray::B: Ray-volume count in each grid cell.\nrays::C: Prognostic ray-volume properties.\nmerged_rays::D: Container used for creating merged ray volumes.\nsurface_indices::E: Indices that connect orographic wave modes to ray volumes.\nincrements::F: WKBIncrements of the prognostic ray-volume properties.\nintegrals::G: Integrals of ray-volume properties.\ntendencies::H: Gravity-wave drag and heating fields.\ncgx_max::I: Maximum zonal group velocities.\ncgy_max::I: Maximum meridional group velocities.\ncgz_max::J: Maximum vertical group velocities.\nzb::K: Upper edge of the blocked layer.\ndiffusion::J: Diffusion induced by wave breaking.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\ntestcase: Test case on which the current simulation is based.\n\nSee also\n\nPinCFlow.Types.WKBTypes.Rays\nPinCFlow.Types.WKBTypes.SurfaceIndices\nPinCFlow.Types.WKBTypes.WKBIncrements\nPinCFlow.Types.WKBTypes.WKBIntegrals\nPinCFlow.Types.WKBTypes.WKBTendencies\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBIncrements","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBIncrements","text":"WKBIncrements{A <: AbstractArray{<:AbstractFloat, 4}}\n\nRay-volume-propagation increments.\n\nWKBIncrements(\n    nray_wrk::Integer,\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n)::WKBIncrements\n\nConstruct an WKBIncrements instance, with arrays sized according to the given dimensions.\n\nFields\n\ndxray::A: WKBIncrements for the position in x.\ndyray::A: WKBIncrements for the position in y.\ndzray::A: WKBIncrements for the position in z.\ndkray::A: WKBIncrements for the position in k.\ndlray::A: WKBIncrements for the position in l.\ndmray::A: WKBIncrements for the position in m.\nddxray::A: WKBIncrements for the extent in x.\nddyray::A: WKBIncrements for the extent in y.\nddzray::A: WKBIncrements for the extent in z.\n\nArguments\n\nnray_wrk: Size of the spectral dimension of ray-volume arrays.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBIntegrals","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBIntegrals","text":"WKBIntegrals{A <: AbstractArray{<:AbstractFloat, 3}}\n\nIntegrals of ray-volume properties.\n\nWKBIntegrals(nxx::Integer, nyy::Integer, nzz::Integer)::WKBIntegrals\n\nConstruct a WKBIntegrals instance, with arrays sized according to the given dimensions.\n\nFields\n\nuu::A: Zonal zonal-momentum flux.\nuv::A: Meridional zonal-momentum flux.\nuw::A: Vertical zonal-momentum flux.\nvv::A: Meridional meridional-momentum flux.\nvw::A: Vertical meridional-momentum flux.\netx::A: Elastic term in the zonal-momentum equation.\nety::A: Elastic term in the meridional momentum equation.\nutheta::A: Zonal mass-weighted potential-temperature flux.\nvtheta::A: Meridional mass-weighted potential-temperature flux.\ne::A: Wave-energy density.\n\nArguments\n\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBTendencies","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBTendencies","text":"WKBTendencies{A <: AbstractArray{<:AbstractFloat, 3}}\n\nGravity-wave drag and heating fields.\n\nWKBTendencies(nxx::Integer, nyy::Integer, nzz::Integer)::WKBTendencies\n\nConstruct a WKBTendencies instance, with arrays sized according to the given dimensions.\n\nFields\n\ndudt::A: Gravity-wave drag on the zonal momentum.\ndvdt::A: Gravity-wave drag on the meridional momentum.\ndthetadt::A: Gravity-wave heating term in the mass-weighted potential-temperature equation.\n\nArguments\n\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#TracerTypes","page":"Types","title":"TracerTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types.TracerTypes","page":"Types","title":"PinCFlow.Types.TracerTypes","text":"TracerTypes\n\nModule for composite types needed for tracer transport.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.VariableTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.Tracer","page":"Types","title":"PinCFlow.Types.TracerTypes.Tracer","text":"Tracer{\n    A <: TracerPredictands,\n    B <: TracerIncrements,\n    C <: TracerAuxiliaries,\n    D <: TracerReconstructions,\n    E <: TracerFluxes,\n    F <: TracerForcings,\n}\n\nContainer for arrays needed for tracer transport.\n\nTracer(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    variables::Variables,\n)::Tracer\n\nConstruct a Tracer instance, with array dimensions and initial values set according to the model configuration.\n\nFields\n\ntracerpredictands::A: Tracers.\ntracerincrements::B: Runge-Kutta updates of the tracers.\ntracerauxiliaries::C: Initial states of the tracers.\ntracerreconstructions::D: Reconstructions of the tracers.\ntracerfluxes::E: Fluxes of the tracers.\ntracerforcings::F: Forcing terms due to gravity-waves and turbulence.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\ngrid: Collection of parameters and fields describing the grid.\nvariables: Container for arrays needed for the prediction of the prognostic variables.\n\nSee also\n\nPinCFlow.Types.TracerTypes.TracerPredictands\nPinCFlow.Types.TracerTypes.TracerIncrements\nPinCFlow.Types.TracerTypes.TracerAuxiliaries\nPinCFlow.Types.TracerTypes.TracerReconstructions\nPinCFlow.Types.TracerTypes.TracerFluxes\nPinCFlow.Types.TracerTypes.TracerForcings\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerAuxiliaries","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerAuxiliaries","text":"TracerAuxiliaries{A <: AbstractArray{<:AbstractFloat, 3}}\n\nInitial states of the tracers.\n\nTracerAuxiliaries(tracerpredictands::TracerPredictands)::TracerAuxiliaries\n\nConstruct a TracerAuxiliaries instance by copying the arrays in tracerpredictands.\n\nFields\n\ninitialtracer::A: Initial state of a non-dimensional tracer.\n\nArguments\n\ntracerpredictands: Tracers.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerFluxes","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerFluxes","text":"TracerFluxes{A <: AbstractArray{<:AbstractFloat, 4}}\n\nArrays for fluxes of tracers.\n\nThe first three dimensions represent physical space and the fourth dimension represents the flux direction.\n\nTracerFluxes(namelists::Namelists, domain::Domain)::TracerFluxes\n\nConstruct a TracerFluxes instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerFluxes(domain::Domain, tracersetup::NoTracer)::TracerFluxes\n\nConstruct a TracerFluxes instance with zero-size arrays for configurations without tracer transport.\n\nTracerFluxes(domain::Domain, tracersetup::AbstractTracer)::TracerFluxes\n\nConstruct a TracerFluxes instance with zero-initialized arrays.\n\nFields\n\nphichi::A: Fluxes of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerForcings","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerForcings","text":"TracerForcings{A <: TracerWKBImpact}\n\nContainer for TracerWKBImpact instance with all necessary terms for the right-hand side of the tracer equation.\n\nTracerForcings(namelists::Namelists, domain::Domain)\n\nConstruct a TracerForcings instance set according to the model configuration.\n\nTracerForcings(namelists::Namelists, domain::Domain, tracersetup::NoTracer)\n\nConstruct a TracerForcings instance for configurations without tracer transport.\n\nTracerForcings(\n    namelists::Namelists,\n    domain::Domain,\n    tracersetup::AbstractTracer,\n)\n\nConstruct a TracerForcings instance for configurations with tracer transport.\n\nTracerForcings(namelists::Namelists, domain::Domain, testcase::AbstractTestCase)\n\nConstruct a TracerForcings instance for configurations without WKB model.\n\nTracerForcings(\n    namelists::Namelists,\n    domain::Domain,\n    testcase::AbstractWKBTestCase,\n)\n\nConstruct a TracerForcings instance for configurations with tracer transport and WKB model.\n\nFields\n\nchiq0::A: Leading-order tracer forcings.\n\nArguments:\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracersetup: General tracer-transport configuration.\ntestcase: Teset case on which the current simulation is based.\n\nSee also:\n\nPinCFlow.Types.TracerTypes.TracerWKBImpact\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerIncrements","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerIncrements","text":"TracerIncrements{A <: AbstractArray{<:AbstractFloat, 3}}\n\nArrays for the Runge-Kutta updates of tracers.\n\nTracerIncrements(namelists::Namelists, domain::Domain)::TracerIncrements\n\nConstruct a TracerIncrements instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerIncrements(domain::Domain, tracersetup::NoTracer)::TracerIncrements\n\nConstruct a TracerIncrements instance with zero-size arrays for configurations without tracer transport.\n\nTracerIncrements(domain::Domain, tracersetup::AbstractTracer)::TracerIncrements\n\nConstruct a TracerIncrements instance with zero-initialized arrays.\n\nFields\n\ndchi::A: Runge-Kutta update of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerPredictands","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerPredictands","text":"TracerPredictands{A <: AbstractArray{<:AbstractFloat, 3}}\n\nArrays for tracers.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with dimensions and initial values depending on the general configuration of tracer transport, by dispatching to the appropriate method.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    tracersetup::AbstractTracer,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with zero-size arrays for configurations without tracer transport.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    tracersetup::LinearTracer,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with an initialized non-dimensional tracer linearly increasing with altitude. The tracer field is multiplied by the density.\n\nFields\n\nchi::A: Non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\ngrid: Collection of parameters and fields describing the grid.\ntracersetup: General tracer-transport configuration.\nvariables: Container for arrays needed for the prediction of the prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerReconstructions","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerReconstructions","text":"TracerReconstructions{A <: AbstractArray{<:AbstractFloat, 5}}\n\nArrays for the reconstruction of tracers.\n\nThe first three dimensions represent physical space, the fourth represents the physical-space dimension of the reconstruction and the fifth the two directions in which it is computed.\n\nTracerReconstructions(\n    namelists::Namelists,\n    domain::Domain,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerReconstructions(\n    domain::Domain,\n    tracersetup::NoTracer,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with zero-size arrays for configurations without tracer transport.\n\nTracerReconstructions(\n    domain::Domain,\n    tracersetup::AbstractTracer,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with zero-initialized arrays.\n\nFields\n\nchitilde::A: Reconstructions of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracersetup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerWKBImpact","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerWKBImpact","text":"TracerWKBImpact{A <: AbstractArray{<:AbstractFloat, 3}}\n\nContainer for the gravity-wave-induced tracer fluxes and resulting tracer tendency.\n\nTracerWKBImpact(nxi::Integer, nyi::Integer, nzi::Integer)\n\nConstruct a TracerWKBImpact instance with array dimensions given by nxi, nyi, and nzi.\n\nFields\n\nuchi::A: Zonal tracer fluxes due to unresolved gravity waves.\nvchi::A: Meridional tracer fluxes due to unresolved gravity waves.\nwchi::A: Vertical tracer fluxes due to unresolved gravity waves.\ndchidt::A: Leading-order tracer impact of unresolved gravity waves.\n\nArguments:\n\nnxi: Grid-points in \\widehat{x}-direction.\nnyi: Grid-points in \\widehat{y}-direction.\nnzi: Grid-points in \\widehat{z}-direction.\n\n\n\n\n\n","category":"type"},{"location":"#PinCFlow.jl","page":"Home","title":"PinCFlow.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PinCFlow is an atmospheric flow solver that was designed for performing idealized simulations. It integrates the Boussinesq, pseudo-incompressible and compressible equations in a conservative flux form (Klein, 2009; Rieper et al., 2013), using a a semi-implicit method that combines explicit and implicit time-stepping schemes (Benacchio & Klein, 2019; Schmid et al., 2021). Spatially, the equations are discretized with a finite-volume method, such that all quantities are represented by averages over grid cells and fluxes are computed on the respective cell interfaces. The grid is staggered so that the velocity components are defined at the same points as the corresponding fluxes of scalar quantities. PinCFlow operates in a vertically stretched terrain-following coordinate system based on Gal-Chen and Somerville (1975a), Gal-Chen and Somerville (1975b) and Clark (1977).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Lagrangian WKB model MSGWaM is interactively coupled to PinCFlow, so that unresolved gravity waves may be parameterized in a manner that accounts for transience and horizontal propagation. The resolved fields are updated with tendencies computed by MSGWaM at the beginning of every time step. A description of the theory behind PinCFlow-MSGWaM can be found in Achatz et al. (2017) and Achatz et al. (2023). For a numerical perspective and more information on the development, see Muraschko et al. (2014), Boeloeni et al. (2016), Wilhelm et al. (2018), Wei et al. (2019) and Jochum et al. (2025).","category":"page"},{"location":"#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install PinCFlow, first make sure you have installed Julia. You can then clone this repository with","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone git@github.com:Atmospheric-Dynamics-GUF/PinCFlow.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"and set up the project environment by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the root directory of your clone.","category":"page"},{"location":"#Running-the-model","page":"Home","title":"Running the model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a minimal example, the script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PinCFlow\n\nintegrate(Namelists())","category":"page"},{"location":"","page":"Home","title":"Home","text":"runs PinCFlow in its default configuration, if executed with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the root directory of the repository. This simulation will finish comparatively quickly and won't produce particularly interesting results, since PinCFlow simply initializes a 1 times 1 times 1  mathrmkm^3 isothermal atmosphere at rest with 3 times 3 times 3 grid points and integrates the governing equations over one hour. A more complex configuration can be set up by providing namelists with changed parameters. For instance, running the script","category":"page"},{"location":"","page":"Home","title":"Home","text":"# examples/submit/periodic_hill.jl\n\nusing PinCFlow\n\n@ivy if length(ARGS) == 0\n    output_file = \"./pincflow_output.h5\"\nelseif length(ARGS) == 1\n    output_file = ARGS[1] * \"/pincflow_output.h5\"\nelse\n    error(\"Too many arguments to the script!\")\nend\n\natmosphere = AtmosphereNamelist(; backgroundflow_dim = (1.0E+1, 0.0E+0, 0.0E+0))\ndomain = DomainNamelist(;\n    sizex = 40,\n    sizey = 1,\n    sizez = 40,\n    lx_dim = 2.0E+4,\n    ly_dim = 2.0E+4,\n    lz_dim = 2.0E+4,\n)\ngrid = GridNamelist(; mountainheight_dim = 1.0E+1, mountainwidth_dim = 1.0E+4)\noutput = OutputNamelist(; output_variables = (:w,), output_file = output_file)\nsponge = SpongeNamelist(; spongelayer = true)\n\nintegrate(Namelists(; atmosphere, domain, grid, output, sponge))\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"yields a 2D simulation with an initial wind of 10  mathrmm  s^- 1 that generates a mountain wave above a periodic hill. The vertical wind is written to the output file pincflow_output.h5 in the directory specified by an additional argument to the script (or the current directory, if that argument is omitted). More involved examples are given in the \"Examples\" section of the documentation. A description of all namelists and their parameters is provided in the \"Reference\" section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to run PinCFlow in parallel, make sure you are using the correct backends for MPI.jl and HDF5.jl. By default, the two packages use JLL backends that have been automatically installed. If you want to keep this setting, you only need to make sure to use the correct MPI binary (specifically not that of a default MPI installation on your system). You can do so by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"mpiexec=$(julia --project -e 'using MPICH_jll; println(MPICH_jll.mpiexec_path)')\n${mpiexec} -n ${tasks} julia --project script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"with tasks set to the number of MPI processes. Note that in script.jl, the parameters npx, npy and npz of the namelist domain, which represent the number of MPI processes in the three dimensions of physical space, need to be set such that their product is equal to tasks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, if you plan to run PinCFlow on a cluster, you may want to consider using a provided MPI installation as backend. In that case, the MPI preferences need to be updated accordingly and the HDF5 backend has to be set to a library that has been installed with parallel support, using the chosen MPI installation. This can be done by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'using MPIPreferences; MPIPreferences.use_system_binary(; library_names = [\"/path/to/mpi/library/\"])'\njulia --project -e 'using HDF5; HDF5.API.set_libraries!(\"/path/to/libhdf5.so\", \"/path/to/libhdf5_hl.so\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"with the paths set appropriately (more details can be found in the documentations of MPI.jl and HDF5.jl). Note that this configuration will be saved in LocalPreferences.toml, so that the new backends will be used by all future scripts run in the project. By running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'using MPIPreferences; MPIPreferences.use_system_binary()'\njulia --project -e 'using HDF5; HDF5.API.set_libraries!()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"you can restore the default backends. Having configured MPI.jl and HDF5.jl to use installations on your system, you can run","category":"page"},{"location":"","page":"Home","title":"Home","text":"mpiexec -n ${tasks} julia --project script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"with mpiexec being your chosen system binary. For users who would like to run PinCFlow on Goethe or Levante, shell-script examples are provided in examples/submit.","category":"page"},{"location":"#Visualizing-the-results","page":"Home","title":"Visualizing the results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PinCFlow uses parallel HDF5 to write simulation data. By default, the path to the output file is pincflow_output.h5 (from the directory in which the run script is executed). This may be changed by setting the parameter output_file of the namelist output accordingly. The dimensions of most output fields are (in order) widehatx (zonal axis), widehaty (meridional axis), widehatz (axis orthogonal to the vertical coordinate surfaces) and t (time). Ray-volume property fields differ slightly in that they have an additional (spectral) dimension in front and a vertical dimension that includes the first ghost layer below the surface. To specify which fields are to be written, set the parameters output_variables, save_ray_volumes and prepare_restart of the namelist output accordingly (more details are given in the \"Reference\" section of the documentation).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the visualization of simulation results, we recommend using PythonPlot.jl. A function that configures PythonPlot.jl to use a preset style, as well as one that facilitates the generation of symmetric contour plots, are exported by PinCFlow. The script","category":"page"},{"location":"","page":"Home","title":"Home","text":"# examples/visualization/periodic_hill.jl\n\nusing HDF5\nusing PythonPlot\nusing LaTeXStrings\nusing PinCFlow\n\nset_plot_style()\n\n# Import the data.\n@ivy if length(ARGS) == 0\n    data = h5open(\"./pincflow_output.h5\")\nelseif length(ARGS) == 1\n    data = h5open(ARGS[1] * \"/pincflow_output.h5\")\nelse\n    error(\"Too many arguments to the script!\")\nend\n\n# Set the grid.\nx = data[\"x\"][:] ./ 1000\nz = data[\"z\"][:, 1, :] ./ 1000\nx = x .* ones(size(z))\n\n# Get the vertical wind.\nw = data[\"w\"][:, 1, :, end]\n\n# Close the file.\nclose(data)\n\n# Create the plot.\n(levels, colormap) = symmetric_contours(minimum(w), maximum(w))\ncontours = contourf(x, z, w; levels = levels, cmap = colormap)\nxlabel(L\"x\\,\\left[\\mathrm{km}\\right]\")\nylabel(L\"z\\,\\left[\\mathrm{km}\\right]\")\ncolorbar(contours; label = L\"w\\,\\left[\\mathrm{m\\,s^{-1}}\\right]\")\nsavefig(\"examples/results/periodic_hill.png\")\nclf()\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"is an example for how to visualize the vertical wind at the end of a simple mountain-wave simulation performed with the script introduced above. Once again, the directory which the output file has been saved to is given as an additional argument to the script. The resulting plot is displayed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Developer-guide","page":"Home","title":"Developer guide","text":"","category":"section"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code is shared in a GitHub repository. Any contributions to the code should adhere to the following workflow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are new to the project, create a remote development branch for your contributions (name it such that others can identify it as your branch) and clone the repository.\nMake your changes on your local development branch.\nPull recent changes made on the remote main branch into your local main branch and merge it into your local development branch, resolving merge conflicts if necessary.\nEnsure that the model is stable and that all canonical tests reproduce the sample results.\nPush your changes to your remote development branch.\nRequest to merge your remote development branch into the remote main branch.","category":"page"},{"location":"#Writing-code","page":"Home","title":"Writing code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to the code should respect the following rules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Put every module, composite type (including constructor methods) and function into a file on its own, with the file name matching that of the object. Create a folder for every module (see below for a diagram of PinCFlow's modular structure).\nVariables that are communicated between functions should be stored at an appropriate level of the State instance (see below for a diagram of PinCFlow's model-state structure).\nUse type parameters to declare the types of all composite-type fields.\nDeclare the types of all method arguments and the return types of all methods that return something other than nothing.\nUse PinCFlow's @ivy in front of expressions that access elements of arrays/tuples. Always apply this macro to the outermost expression possible but do not create new blocks for this purpose.\nDo not use Unicode.\nUse CamelCase for the names of modules and types. Use single capital letters for type parameters. For all other objects, use snake_case (in case the name only contains (preferably whole) words, e.g. vertical_wind) and squashedcase (in case the name is mathematical, e.g. what for widehatw).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Writing-documentation","page":"Home","title":"Writing documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions to the code should always be accompanied by corresponding contributions to the documentation, respecting the following rules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Write a docstring for every module, function and type.\nModule docstrings:\nInclude the exact full signature within a Julia code block, followed by a single descriptive (pseudo-)sentence and (if needed) additional paragraphs with more details.\nList links to imported modules in a # See also section, with one bullet for each.\nFunction docstrings:\nFor every method, include the exact full signature within a Julia code block, followed by a single, descriptive sentence in imperative form and (if needed) additional paragraphs with more details.\nList all positional and optional arguments with descriptions (but without types and default values) in an # Arguments section, with one bullet for each.\nList all keyword arguments with descriptions (but without types and default values) in a # Keywords section, with one bullet for each.\nList links to constructors/functions that are called in any of the function's methods in a # See also section, with one bullet for each.\nType docstrings:\nInclude the exact full signature within a Julia code block, followed by a single descriptive (pseudo-)sentence and (if needed) a additional paragraphs with more details.\nIf the type is composite, include the exact full signature within a Julia code block, followed by a single, descriptive sentence in imperative form and (if needed) additional paragraphs with more details, for each explicitly defined constructor method.\nIf the type is composite, list all fields with their type restrictions and descriptions in a # Fields section, with one bullet for each.\nIf the type is composite, list all positional and optional arguments of the explicitly defined constructor methods with descriptions (but without types and default values) in an # Arguments section, with one bullet for each.\nIf the type is composite, list all keyword arguments of the explicitly defined constructor methods with descriptions (but without types and default values) in a # Keywords section, with one bullet for each.\nIf the type is composite, list links to constructors/functions that are called in any of the explicitly defined constructor methods in a # See also section, with one bullet for each.\nUse single backticks to identify code and double backticks to identify equations. Use LaTeX escape sequences instead of Unicode characters.\nPlace the starting and ending \"\"\" characters on lines by themselves.","category":"page"},{"location":"#Markdown-syntax","page":"Home","title":"Markdown syntax","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Markdown code should use the following syntax.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Headings:\n# Heading level 1\n\n## Heading level 2\n\n### Heading level 3\n\n#### Heading level 4\n\n##### Heading level 5\n\n###### Heading level 6\nParagraphs:\nThis is the first paragraph.\n\nThis is the second paragraph.\nEmphasis:\nThis sentence contains *italic*, **bold** and ***italic bold*** words.\nBlock quotes:\nThis is a sentence above a block quote.\n\n  > This is the first paragraph of a block quote.\n  >\n  >   > This is a nested block quote.\n  >\n  > This is the second paragraph of a block quote.\n\nThis is a sentence below a block quote.\n\nUnnumbered lists:\nThis is a sentence above an unnumbered list.\n\n  - This is the first paragraph of the first item.\n\n      - This is the first item of a nested list.\n\n      - This is the second item of a nested list.\n\n    This is the second paragraph of the first item.\n\n  - This is the second item.\n\nThis is a sentence below an unnumbered list.\nNumbered lists:\nThis is a sentence above a numbered list.\n\n 1. This is the first paragraph of the first item.\n\n     1. This is the first item of a nested list.\n\n     1. This is the second item of a nested list.\n\n    This is the second paragraph of the first item.\n\n 1. This is the second item.\n\n This is a sentence below a numbered list.\nInline code:\nThis sentence contains inline `code` and inline `` `nested code` ``.\nCode blocks:\nThis sentence contains the code block\n\n```julia\nif true\n    println(\"true\")\nend\n```\n\nand other stuff. This sentence contains the nested code blocks\n\n``````markdown\n```julia\nif true\n    println(\"true\")\nend\n```\n``````\n\nand other stuff.\nHorizontal rule:\n---\nURLs and email addresses:\nThis sentence contains the URL <http://example.com> and the email address <fake@example.com>.\nLinks:\nThis sentence contains a [link](http://example.com).\nImages:\n![](image.png)\nBackslash escapes:\nThis sentence contains the backslash escapes \\\\\\`\\*\\_\\{\\}\\[\\]\\(\\)\\#\\+\\-\\.\\!.\nInline math:\nThis sentence contains the equation $x^2 + y^2 = z^2$.\nCentered math:\nThis sentence contains the equation\n\n$$x^2 + y^2 = z^2$$\n\nand other stuff.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In docstrings, the following syntax elements are different.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inline math:\nThis sentence contains the equation ``x^2 + y^2 = z^2``.\nCentered math:\nThis sentence contains the equation\n\n```math\nx^2 + y^2 = z^2\n```\n\nand other stuff.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, every backslash used for LaTeX commands in equations has to be doubled.","category":"page"},{"location":"#Building-and-accessing-the-documentation","page":"Home","title":"Building and accessing the documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code uses Documenter.jl. To build the documentation, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs -e 'using Pkg; Pkg.develop(; path = \".\"); Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the root directory of the repository. The documentation will be generated in the docs/build directory. To view it, open docs/build/index.html in a web browser or preview the file in Visual Studio Code with Live Preview.","category":"page"},{"location":"#List-of-publications","page":"Home","title":"List of publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initial flow solver: Rieper et al. (2013)\nInitial gravity-wave scheme: Muraschko et al. (2014)\nGravity-wave breaking scheme: Boeloeni et al. (2016)\nGravity-wave theory: Achatz et al. (2017)\nCoupling of the flow solver and gravity-wave scheme: Wilhelm et al. (2018)\nHorizontal propagation and direct approach in the gravity-wave scheme: Wei et al. (2019)\nSemi-implicit time scheme: Schmid et al. (2021)\nExtended gravity-wave theory: Achatz et al. (2023)\nTerrain-following coordinates & orographic source: Jochum et al. (2025)","category":"page"}]
}
