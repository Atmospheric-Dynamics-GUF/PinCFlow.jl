<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Update · PinCFlow.jl</title><meta name="title" content="Update · PinCFlow.jl"/><meta property="og:title" content="Update · PinCFlow.jl"/><meta property="twitter:title" content="Update · PinCFlow.jl"/><meta name="description" content="Documentation for PinCFlow.jl."/><meta property="og:description" content="Documentation for PinCFlow.jl."/><meta property="twitter:description" content="Documentation for PinCFlow.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PinCFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/mountain_wave_simulation/">Mountain-wave simulation</a></li><li><a class="tocitem" href="../../examples/wkb_mountain_wave_simulation/">WKB mountain-wave simulation</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/physics/">Physics</a></li><li><a class="tocitem" href="../../theory/numerics/">Numerics</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../pincflow/">PinCFlow</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../mpi_operations/">MPIOperations</a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../flux_calculator/">FluxCalculator</a></li><li><a class="tocitem" href="../poisson_solver/">PoissonSolver</a></li><li class="is-active"><a class="tocitem" href>Update</a></li><li><a class="tocitem" href="../msgwam/">MSGWaM</a></li><li><a class="tocitem" href="../integration/">Integration</a></li><li><a class="tocitem" href="../output/">Output</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Update</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Update</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Atmospheric-Dynamics-GUF/PinCFlow.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Update"><a class="docs-heading-anchor" href="#Update">Update</a><a id="Update-1"></a><a class="docs-heading-anchor-permalink" href="#Update" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update" href="#PinCFlow.Update"><code>PinCFlow.Update</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Update</code></pre><p>Module for integrating the prognostic equations.</p><p>Provides functions for updating the prognostic variables at the various stages of the semi-implicit time scheme.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="../boundaries/#PinCFlow.Boundaries"><code>PinCFlow.Boundaries</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.Cartesian" href="#PinCFlow.Update.Cartesian"><code>PinCFlow.Update.Cartesian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cartesian</code></pre><p>Singleton for transformations from the terrain-following system to the Cartesian one.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.LHS" href="#PinCFlow.Update.LHS"><code>PinCFlow.Update.LHS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LHS</code></pre><p>Singleton for the integration of the left-hand side of an equation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.RHS" href="#PinCFlow.Update.RHS"><code>PinCFlow.Update.RHS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RHS</code></pre><p>Singleton for the integration of the right-hand side of an equation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.Transformed" href="#PinCFlow.Update.Transformed"><code>PinCFlow.Update.Transformed</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transformed</code></pre><p>Singleton for transformations from the Cartesian system to the terrain-following one.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.X" href="#PinCFlow.Update.X"><code>PinCFlow.Update.X</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X</code></pre><p>Singleton for <span>$\widehat{x}$</span>-axis along which a calculation should be performed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.Y" href="#PinCFlow.Update.Y"><code>PinCFlow.Update.Y</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y</code></pre><p>Singleton for <span>$\widehat{y}$</span>-axis along which a calculation should be performed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.Z" href="#PinCFlow.Update.Z"><code>PinCFlow.Update.Z</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Z</code></pre><p>Singleton for <span>$\widehat{z}$</span>-axis along which a calculation should be performed.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.apply_lhs_sponge!" href="#PinCFlow.Update.apply_lhs_sponge!"><code>PinCFlow.Update.apply_lhs_sponge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::AbstractVariable,
)</code></pre><p>Perform an implicit substep to integrate the Rayleigh-damping term that represents the LHS sponge in the prognostic equation for <code>variable</code> by dispatching to the appropriate model-specific method.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::Rho,
    model::Boussinesq,
)</code></pre><p>Return in Boussinesq mode (constant density).</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::Rho,
    model::AbstractModel,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the continuity equation.</p><p>The update is given by</p><p class="math-container">\[\rho \rightarrow \left(1 + \alpha_\mathrm{R} \Delta t\right)^{- 1} \left(\rho + \alpha_\mathrm{R} \Delta t \overline{\rho}\right),\]</p><p>where <span>$\alpha_\mathrm{R}$</span> is the Rayleigh-damping coefficient computed by <a href="#PinCFlow.Update.compute_sponges!"><code>PinCFlow.Update.compute_sponges!</code></a> and <span>$\Delta t$</span> is the time step given as input to this method.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::RhoP,
    model::AbstractModel,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the auxiliary equation.</p><p>The update is given by</p><p class="math-container">\[\rho&#39; \rightarrow \left(1 + \alpha_\mathrm{R} \Delta t\right)^{- 1} \left[\rho&#39; + \alpha_\mathrm{R} \Delta t \overline{\rho} \left(1 - \frac{P}{\rho \overline{\theta}}\right)\right].\]</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::U,
    model::AbstractModel,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the zonal-momentum equation.</p><p>The update is given by</p><p class="math-container">\[u_{i + 1 / 2} \rightarrow \left(1 + \alpha_{\mathrm{R}, i + 1 / 2} \Delta t\right)^{- 1} \left\{u_{i + 1 / 2} + \alpha_{\mathrm{R}, i + 1 / 2} \Delta t u_\mathrm{r} \left[1 + a_\mathrm{r} \sin \left(\frac{2 \pi t}{t_\mathrm{r}}\right)\right]\right\}.\]</p><p>If <code>state.namelists.sponge.relax_to_mean</code> is <code>false</code>, <span>$u_\mathrm{r}$</span>, <span>$a_\mathrm{r}$</span> and <span>$t_\mathrm{r}$</span> are given by the sponge-namelist parameters <code>relaxation_wind[1]</code>, <code>perturbation_amplitude</code> and <code>perturbation_period</code>, respectively. Otherwise, <span>$u_\mathrm{r}$</span> is the average of <span>$u_{i + 1 / 2}$</span> across the terrain-following coordinate surface and <span>$a_\mathrm{r} = 0$</span>.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::V,
    model::AbstractModel,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the meridional-momentum equation.</p><p>The update is given by</p><p class="math-container">\[v_{j + 1 / 2} \rightarrow \left(1 + \alpha_{\mathrm{R}, j + 1 / 2} \Delta t\right)^{- 1} \left\{v_{j + 1 / 2} + \alpha_{\mathrm{R}, j + 1 / 2} \Delta t v_\mathrm{r} \left[1 + a_\mathrm{r} \sin \left(\frac{2 \pi t}{t_\mathrm{r}}\right)\right]\right\}.\]</p><p>The computation of the relaxation wind is analogous to that in the method for the zonal momentum, with <span>$v_\mathrm{r}$</span> given by <code>state.namelists.sponge.relaxation_wind[2]</code>.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::W,
    model::AbstractModel,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the transformed-vertical-momentum equation.</p><p>The update is given by</p><p class="math-container">\[\widehat{w}_{k + 1 / 2} \rightarrow \left(1 + \alpha_{\mathrm{R}, k + 1 / 2} \Delta t\right)^{- 1} \left\{\widehat{w}_{k + 1 / 2} + \alpha_{\mathrm{R}, k + 1 / 2} \Delta t \widehat{w}_\mathrm{r} \left[1 + a_\mathrm{r} \sin \left(\frac{2 \pi t}{t_\mathrm{r}}\right)\right]\right\},\]</p><p>The computation of the relaxation wind is analogous to that in the methods for the zonal and meridional momenta, with <span>$\widehat{w}_\mathrm{r}$</span> given by <code>state.namelists.sponge.relaxation_wind[3]</code>.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::PiP,
    model::AbstractModel,
)</code></pre><p>Return in non-compressible modes (Exner-pressure fluctuations are only updated in the corrector step).</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::PiP,
    model::Compressible,
)</code></pre><p>Update the Exner-pressure fluctuations to account for the Rayleigh damping applied to the mass-weighted potential temperature.</p><p>The update is given by</p><p class="math-container">\[\pi&#39; \rightarrow \pi&#39; - \alpha_\mathrm{R} \Delta t P \frac{\partial \pi&#39;}{\partial P} \left(1 - \frac{\overline{\rho}}{\rho}\right).\]</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::P,
    model::AbstractModel,
)</code></pre><p>Return in non-compressible modes (mass-weighted potential temperature is constant in time).</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    variable::P,
    model::Compressible,
)</code></pre><p>Integrate the Rayleigh-damping term that represents the LHS sponge in the thermodynamic-energy equation.</p><p>The update is given by</p><p class="math-container">\[P \rightarrow \left(1 + \alpha_\mathrm{R} \Delta t\right)^{- 1} P \left(1 + \alpha_\mathrm{R} \Delta t \frac{\overline{\rho}}{\rho}\right).\]</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    tracersetup::NoTracer,
)</code></pre><p>Return for configurations without tracer transport.</p><pre><code class="language-julia hljs">apply_lhs_sponge!(
    state::State,
    dt::AbstractFloat,
    time::AbstractFloat,
    tracersetup::AbstractTracer,
)</code></pre><p>Integrate the Rayleigh-damping terms that represent the LHS sponge in the tracer equations.</p><p>In each tracer equation, the update is given by</p><p class="math-container">\[\chi \rightarrow \left(1 + \alpha_\mathrm{R} \Delta t\right)^{- 1} \left(\chi + \alpha_\mathrm{R} \Delta t \chi_0\right),\]</p><p>where <span>$\chi_0$</span> is the initial distribution of the tracer.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>dt</code>: Time step.</p></li><li><p><code>time</code>: Simulation time.</p></li><li><p><code>variable</code>: Variable to apply Rayleigh damping to.</p></li><li><p><code>model</code>: Dynamic equations.</p></li><li><p><code>tracersetup</code>: General tracer-transport configuration.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_buoyancy_factor" href="#PinCFlow.Update.compute_buoyancy_factor"><code>PinCFlow.Update.compute_buoyancy_factor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_buoyancy_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::AbstractVariable,
)::AbstractFloat</code></pre><p>Compute the factor by which the buoyancy term should be multiplied at <span>$\left(i, j, k\right)$</span> or <span>$\left(i, j, k + 1 / 2\right)$</span>, by dispatching to a method specific for the dynamic equations and <code>variable</code>, and return the result.</p><p>In pseudo-incompressible mode, <span>$\rho&#39;$</span> are deviations of the total density from <span>$\overline{\rho}$</span>, which describes the reference atmosphere. However, in compressible mode, <span>$\rho&#39; = \rho - P / \overline{\theta}$</span> does not reduce to this, i.e. the density background has a spatiotemporal dependence. As a consequence, the right-hand side of the prognostic equation for <span>$\rho&#39;$</span> is given by</p><p class="math-container">\[\left(\frac{\partial \rho&#39;}{\partial t}\right)_{N^2} = f_{\rho&#39;} \frac{N^2 \rho w}{g},\]</p><p>with <span>$f_{\rho&#39;} = \overline{\rho} / \rho$</span> in pseudo-incompressible mode and <span>$f_{\rho&#39;} = P / \left(\rho \overline{\theta}\right)$</span> in compressible mode. This method returns either <span>$f_{\rho&#39;}$</span> at <span>$\left(i, j, k\right)$</span> or <span>$f_w$</span>, which is the interpolation of <span>$f_{\rho&#39;}$</span> to <span>$\left(i, j, k + 1 / 2\right)$</span>, based on the type of <code>variable</code>.</p><pre><code class="language-julia hljs">compute_buoyancy_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::RhoP,
    model::Compressible,
)::AbstractFloat</code></pre><p>Return <span>$f_{\rho&#39;} = P / \left(\rho \overline{\theta}\right)$</span> as the factor by which the buoyancy term should be multiplied at <span>$\left(i, j, k\right)$</span> in compressible mode.</p><pre><code class="language-julia hljs">compute_buoyancy_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::RhoP,
    model::AbstractModel,
)::AbstractFloat</code></pre><p>Return <span>$f_{\rho&#39;} = \overline{\rho} / \rho$</span> as the factor by which the buoyancy term should be multiplied at <span>$\left(i, j, k\right)$</span> in pseudo-incompressible mode (this method is also used in Boussinesq mode).</p><pre><code class="language-julia hljs">compute_buoyancy_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    model::Compressible,
)::AbstractFloat</code></pre><p>Return <span>$f_w = \left(P / \overline{\theta}\right)_{k + 1 / 2} / \rho_{k + 1 / 2}$</span> as the factor by which the buoyancy term should be multiplied in compressible mode.</p><pre><code class="language-julia hljs">compute_buoyancy_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    model::AbstractModel,
)::AbstractFloat</code></pre><p>Return <span>$f_w = \overline{\rho}_{k + 1 / 2} / \rho_{k + 1 / 2}$</span> as the factor by which the buoyancy term should be multiplied at <span>$\left(i, j, k + 1 / 2\right)$</span> in pseudo-incompressible mode (this method is also used in Boussinesq mode).</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>variable</code>: Variable for which the factor is needed.</p></li><li><p><code>model</code>: Dynamic equations.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_compressible_wind_factor" href="#PinCFlow.Update.compute_compressible_wind_factor"><code>PinCFlow.Update.compute_compressible_wind_factor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_compressible_wind_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::AbstractVariable,
)::AbstractFloat</code></pre><p>Compute the factor by which the wind should be multiplied at <span>$\left(i + 1 / 2, j, k\right)$</span>, <span>$\left(i, j + 1 / 2, k\right)$</span> or <span>$\left(i, j, k + 1 / 2\right)$</span>, by dispatching to a method specific for the dynamic equations and the component indicated by <code>variable</code>, and return the result.</p><p>In compressible mode, the Euler steps that are used to integrate the right-hand side of the momentum equation update <span>$\left(J P\right)_{i + 1 / 2} u_{i + 1 / 2}$</span>, <span>$\left(J P\right)_{j + 1 / 2} v_{j + 1 / 2}$</span> and <span>$\left(J P\right)_{k + 1 / 2} \widehat{w}_{k + 1 / 2}$</span> instead of <span>$u_{i + 1 / 2}$</span>, <span>$v_{j + 1 / 2}$</span> and <span>$\widehat{w}_{k + 1 / 2}$</span>.</p><pre><code class="language-julia hljs">compute_compressible_wind_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::AbstractVariable,
    model::AbstractModel,
)::AbstractFloat</code></pre><p>Return <span>$1$</span> as the factor by which the wind should be multiplied in non-compressible mode.</p><pre><code class="language-julia hljs">compute_compressible_wind_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
    model::Compressible,
)::AbstractFloat</code></pre><p>Return <span>$\left(J P\right)_{i + 1 / 2}$</span> as the factor by which the zonal wind should be multiplied in compressible mode.</p><pre><code class="language-julia hljs">compute_compressible_wind_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
    model::Compressible,
)::AbstractFloat</code></pre><p>Return <span>$\left(J P\right)_{j + 1 / 2}$</span> as the factor by which the meridional wind should be multiplied in compressible mode.</p><pre><code class="language-julia hljs">compute_compressible_wind_factor(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    model::Compressible,
)::AbstractFloat</code></pre><p>Return <span>$\left(J P\right)_{k + 1 / 2}$</span> as the factor by which the transformed vertical wind should be multiplied in compressible mode.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>variable</code>: Variable for which the factor is needed.</p></li><li><p><code>model</code>: Dynamic equations.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_momentum_diffusion_terms" href="#PinCFlow.Update.compute_momentum_diffusion_terms"><code>PinCFlow.Update.compute_momentum_diffusion_terms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
    direction::X,
)::AbstractFloat</code></pre><p>Compute and return the diffusive zonal momentum fluxes in <span>$\widehat{x}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{u}_{\widehat{x}} = \frac{u_{i+1/2} - u_{i-1/2}}{\Delta \widehat{x}} + G^{13}\frac{u_{k+1} - u_{k-1}}{2\Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
    direction::Y,
)::AbstractFloat</code></pre><p>Compute and return the diffusive zonal momentum fluxes in <span>$\widehat{y}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{u}_{\widehat{y}} = \frac{u_{j+1}-u_{j-1}}{2\Delta \widehat{y}} + G^{23}\frac{u_{k+1}-u_{k-1}}{2\Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
    direction::Z,
)::AbstractFloat</code></pre><p>Compute and return the diffusive zonal momentum fluxes in <span>$\widehat{z}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{u}_{\widehat{z}} = G^{13}\frac{u_{i+1/2}-u_{i-1/2}}{\Delta \widehat{x}} + G^{23}\frac{u_{j+1}-u_{j-1}}{2 \Delta \widehat{y}} + G^{33}\frac{u_{k+1}-u_{k-1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
    direction::X,
)::AbstractFloat</code></pre><p>Compute and return the diffusive meridional momentum fluxes in <span>$\widehat{x}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{v}_{\widehat{x}} = \frac{v_{i+1} - v_{i-1}}{2 \Delta \widehat{x}} + G^{13}\frac{v_{k+1}-v_{k-1}}{2\Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
    direction::Y,
)::AbstractFloat</code></pre><p>Compute and return the diffusive meridional momentum fluxes in <span>$\widehat{y}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{v}_{\widehat{y}} = \frac{v_{j+1/2} - v_{j-1/2}}{\Delta \widehat{y}} + G^{23}\frac{v_{k+1}-v_{k-1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
    direction::Z,
)::AbstractFloat</code></pre><p>Compute and return the diffusive meridional momentum fluxes in <span>$\widehat{z}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{v}_{\widehat{z}} = G^{13}\frac{v_{i+1} - v_{i-1}}{2\Delta\widehat{x}} + G^{23}\frac{v_{j+1/2}-v_{j-1/2}}{\Delta \widehat{y}} + G^{33}\frac{v_{k+1}-v_{k-1}}{2\Delta\widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    direction::X,
)::AbstractFloat</code></pre><p>Compute and return the diffusive vertical momentum fluxes in <span>$\widehat{x}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{\widehat{w}}_{\widehat{x}} = \frac{\widehat{w}_{i+1} - \widehat{w}_{i-1}}{2\Delta\widehat{x}} + G^{13}\frac{w_{k+1/2}-w_{k-1/2}}{\Delta\widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    direction::Y,
)::AbstractFloat</code></pre><p>Compute and return the diffusive vertical momentum fluxes in <span>$\widehat{y}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{\widehat{w}}_{\widehat{y}} = \frac{\widehat{w}_{j+1}-\widehat{w}_{j-1}}{2\Delta\widehat{y}} + G^{23}\frac{w_{k+1/2}-w_{k-1/2}}{\Delta\widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_momentum_diffusion_terms(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    direction::Z,
)::AbstractFloat</code></pre><p>Compute and return the diffusive vertical momentum fluxes in <span>$\widehat{z}$</span>-direction, i.e.</p><p class="math-container">\[\Xi^{\widehat{w}}_{\widehat{z}} = G^{13}\frac{\widehat{w}_{i+1}-\widehat{w}_{i-1}}{2\Delta\widehat{x}} + G^{23}\frac{\widehat{w}_{j+1}-\widehat{w}_{j-1}}{2\Delta\widehat{y}} + G^{33}\frac{w_{k+1/2}-w_{k-1/2}}{\Delta\widehat{z}}.\]</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Grid-cell index on the <span>$\widehat{x}$</span>-axis.</p></li><li><p><code>j</code>: Grid-cell index on the <span>$\widehat{y}$</span>-axis.</p></li><li><p><code>k</code>: Grid-cell index on the <span>$\widehat{z}$</span>-axis.</p></li><li><p><code>variable</code>: Wind direction.</p></li><li><p><code>direction</code>: Direction of the flux.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_pressure_gradient" href="#PinCFlow.Update.compute_pressure_gradient"><code>PinCFlow.Update.compute_pressure_gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_pressure_gradient(
    state::State,
    pip::AbstractArray{&lt;:AbstractFloat, 3},
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
)::AbstractFloat</code></pre><p>Compute and return the pressure(-difference)-gradient term in the zonal-wind equation at <span>$\left(i + 1 / 2, j, k\right)$</span>, using the pressure(-difference) field <code>pip</code>.</p><p>The pressure-gradient component is given by</p><p class="math-container">\[\mathcal{P}^u_{i + 1 / 2} = \frac{\pi&#39;_{i + 1} - \pi&#39;}{\Delta \widehat{x}} + G^{13}_{i + 1 / 2} \frac{\pi&#39;_{i + 1 / 2, k + 1} - \pi&#39;_{i + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.\]</p><p>Since the Exner-pressure is not known in the vertical ghost cells, a different discretization is needed at the vertical boundaries. At <span>$k = k_0$</span> (in the first process in <span>$\widehat{z}$</span>), the alternative second-order-accurate approximation</p><p class="math-container">\[\mathcal{P}^u_{i + 1 / 2} = \frac{\pi&#39;_{i + 1} - \pi&#39;}{\Delta \widehat{x}} + G^{13}_{i + 1 / 2} \frac{- \pi&#39;_{i + 1 / 2, k + 2} + 4 \pi&#39;_{i + 1 / 2, k + 1} - 3 \pi&#39;_{i + 1 / 2}}{2 \Delta \widehat{z}}\]</p><p>is used and, in a similar manner, one has</p><p class="math-container">\[\mathcal{P}^u_{i + 1 / 2} = \frac{\pi&#39;_{i + 1} - \pi&#39;}{\Delta \widehat{x}} + G^{13}_{i + 1 / 2} \frac{\pi&#39;_{i + 1 / 2, k - 2} - 4 \pi&#39;_{i + 1 / 2, k - 1} + 3 \pi&#39;_{i + 1 / 2}}{2 \Delta \widehat{z}}\]</p><p>at <span>$k = k_1$</span> (in the last process in <span>$\widehat{z}$</span>). The corresponding pressure-difference-gradient component <span>$\mathcal{D}^u_{i + 1 / 2}$</span> is obtained by replacing <span>$\pi&#39;$</span> with <span>$\Delta \pi&#39;$</span>. The returned quantity also includes the factor <span>$c_p \left(P_{i + 1 / 2} / \rho_{i + 1 / 2}\right)$</span>.</p><pre><code class="language-julia hljs">compute_pressure_gradient(
    state::State,
    pip::AbstractArray{&lt;:AbstractFloat, 3},
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
)::AbstractFloat</code></pre><p>Compute and return the pressure-gradient term in the meridional-wind equation at <span>$\left(i, j + 1 / 2, k\right)$</span>, using the pressure(-difference) field <code>pip</code>.</p><p>The pressure-gradient component is given by</p><p class="math-container">\[\mathcal{P}^v_{j + 1 / 2} = \frac{\pi&#39;_{j + 1} - \pi&#39;}{\Delta \widehat{y}} + G^{23}_{j + 1 / 2} \frac{\pi&#39;_{j + 1 / 2, k + 1} - \pi&#39;_{j + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.\]</p><p>Analogous to the component in the zonal-wind equation, one has</p><p class="math-container">\[\mathcal{P}^v_{j + 1 / 2} = \frac{\pi&#39;_{j + 1} - \pi&#39;}{\Delta \widehat{y}} + G^{23}_{j + 1 / 2} \frac{- \pi&#39;_{j + 1 / 2, k + 2} + 4 \pi&#39;_{j + 1 / 2, k + 1} - 3 \pi&#39;_{j + 1 / 2}}{2 \Delta \widehat{z}}\]</p><p>at <span>$k = k_0$</span> (in the first process in <span>$\widehat{z}$</span>) and</p><p class="math-container">\[\mathcal{P}^v_{j + 1 / 2} = \frac{\pi&#39;_{j + 1} - \pi&#39;}{\Delta \widehat{y}} + G^{23}_{j + 1 / 2} \frac{\pi&#39;_{j + 1 / 2, k - 2} - 4 \pi&#39;_{j + 1 / 2, k - 1} + 3 \pi&#39;_{j + 1 / 2}}{2 \Delta \widehat{z}}\]</p><p>at <span>$k = k_1$</span> (in the last process in <span>$\widehat{z}$</span>). The corresponding pressure-difference-gradient component <span>$\mathcal{D}^v_{j + 1 / 2}$</span> is obtained by replacing <span>$\pi&#39;$</span> with <span>$\Delta \pi&#39;$</span>. The returned quantity also includes the factor <span>$c_p \left(P_{j + 1 / 2} / \rho_{j + 1 / 2}\right)$</span>.</p><pre><code class="language-julia hljs">compute_pressure_gradient(
    state::State,
    pip::AbstractArray{&lt;:AbstractFloat, 3},
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
)::AbstractFloat</code></pre><p>Compute and return the pressure(-difference)-gradient term in the transformed-vertical-wind equation at <span>$\left(i, j, k + 1 / 2\right)$</span>, using the pressure(-difference) field <code>pip</code>.</p><p>The pressure-gradient component is given by</p><p class="math-container">\[\begin{align*}
    \mathcal{P}^{\widehat{w}}_{k + 1 / 2} &amp; = G^{13}_{k + 1 / 2} \frac{\pi&#39;_{i + 1, k + 1 / 2} - \pi&#39;_{i - 1, k + 1 / 2}}{2 \Delta \widehat{x}} + G^{23}_{k + 1 / 2} \frac{\pi&#39;_{j + 1, k + 1 / 2} - \pi&#39;_{j - 1, k + 1 / 2}}{2 \Delta \widehat{y}}\\
    &amp; \quad + G^{33}_{k + 1 / 2} \frac{\pi&#39;_{k + 1} - \pi&#39;}{\Delta \widehat{z}}.
 \end{align*}\]</p><p>At <span>$k = k_0 - 1$</span> (in the first process in <span>$\widehat{z}$</span>) and <span>$k = k_1$</span> (in the last process in <span>$\widehat{z}$</span>), it is set to zero. The corresponding pressure-difference-gradient component <span>$\mathcal{D}^{\widehat{w}}_{k + 1 / 2}$</span> is obtained by replacing <span>$\pi&#39;$</span> with <span>$\Delta \pi&#39;$</span>. The returned quantity also includes the factor <span>$c_p \left(P_{k + 1 / 2} / \rho_{k + 1 / 2}\right)$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>pip</code>: Pressure field.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>variable</code>: Equation in which the respective pressure-gradient component is needed.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_sponges!" href="#PinCFlow.Update.compute_sponges!"><code>PinCFlow.Update.compute_sponges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_sponges!(state::State, dt::AbstractFloat)</code></pre><p>Compute the Rayleigh-damping coefficients of the two sponges.</p><p>This method directly computes the Rayleigh-damping coefficients</p><p class="math-container">\[\beta_\mathrm{R}^{uv} = \beta_\mathrm{R}^{\widehat{w}} \left(z\right) = \begin{cases}
    \frac{\beta_{\mathrm{R}, \max}}{\Delta t} \sin^2 \left[\frac{\pi \left(z - z_\mathrm{R}\right)}{2 \left(L_z - z_\mathrm{R}\right)}\right] &amp; \mathrm{if} \quad z \geq z_\mathrm{R},\\
    0 &amp; \mathrm{else},
\end{cases}\]</p><p>where <span>$\beta_{\mathrm{R}, \max}$</span> and <span>$z_\mathrm{R}$</span> are given by <code>state.namelists.sponge.betarmax</code> and <code>state.sponge.zsponge</code>, respectively. These coefficients are only used in the prognostic equations for the horizontal wind (<span>$\beta_\mathrm{R}^{uv}$</span>, only if <code>state.namelists.sponge.sponge_uv</code> is <code>true</code>) and the transformed vertical wind (<span>$\beta_\mathrm{R}^{\widehat{w}}$</span>). The corresponding damping terms are integrated on the right-hand sides.</p><p>This method also dispatches to a specific method that computes the Rayleigh damping coefficient of the RHS sponge defined for <code>state.namelists.sponge.spongetype</code>.</p><pre><code class="language-julia hljs">compute_sponges!(state::State, dt::AbstractFloat, spongetype::ExponentialSponge)</code></pre><p>Compute the Rayleigh-damping coefficient of an exponential sponge.</p><p>If <code>state.namelists.sponge.lateralsponge</code> is <code>true</code>, the Rayleigh-damping coefficient is</p><p class="math-container">\[\alpha_\mathrm{R} \left(x, y, z\right) = \frac{\alpha_{\mathrm{R}, \max}}{3} \left[\exp \left(\frac{\left|x\right| - L_x / 2}{\Delta x_\mathrm{R}}\right) + \exp \left(\frac{\left|y\right| - L_y / 2}{\Delta y_\mathrm{R}}\right) + \exp \left(\frac{z - L_z}{\Delta z_\mathrm{R}}\right)\right]\]</p><p>and otherwise, it is</p><p class="math-container">\[\alpha_\mathrm{R} \left(z\right) = \alpha_{\mathrm{R}, \max} \left[\exp \left(\frac{z - L_z}{\Delta z_\mathrm{R}}\right)\right],\]</p><p>where <span>$\alpha_{\mathrm{R}, \max}$</span>, <span>$\Delta x_\mathrm{R}$</span>, <span>$\Delta y_\mathrm{R}$</span> and <span>$\Delta z_\mathrm{R}$</span> are given by <code>state.namelists.sponge.alpharmax</code>, <code>state.sponge.dxsponge</code>, <code>state.sponge.dysponge</code> and <code>state.sponge.dzsponge</code>, respectively. If the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.</p><pre><code class="language-julia hljs">compute_sponges!(state::State, dt::AbstractFloat, spongetype::COSMOSponge)</code></pre><p>Compute the Rayleigh-damping coefficient of a sponge similar to that used by the COSMO model.</p><p>If <code>state.namelists.sponge.lateralsponge</code> is <code>true</code>, the Rayleigh-damping coefficient is</p><p class="math-container">\[\alpha_\mathrm{R} \left(x, y, z\right) = \alpha_{\mathrm{R}, x} \left(x\right) + \alpha_{\mathrm{R}, y} \left(y\right) + \alpha_{\mathrm{R}, z} \left(z\right)\]</p><p>with</p><p class="math-container">\[\begin{align*}
    \alpha_{\mathrm{R}, x} \left(x\right) &amp; = \begin{cases}
        \left(2 N_\mathrm{R} \Delta t\right)^{- 1} \left\{1 - \cos \left[\frac{\pi \left(x_{\mathrm{R}, 0} - x\right)}{\Delta x_\mathrm{R}}\right]\right\} &amp; \mathrm{if} \quad x \leq x_{\mathrm{R}, 0},\\
        \left(2 N_\mathrm{R} \Delta t\right)^{- 1} \left\{1 - \cos \left[\frac{\pi \left(x - x_{\mathrm{R}, 1}\right)}{\Delta x_\mathrm{R}}\right]\right\} &amp; \mathrm{if} \quad x \geq x_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, y} \left(y\right) &amp; = \begin{cases}
        \left(2 N_\mathrm{R} \Delta t\right)^{- 1} \left\{1 - \cos \left[\frac{\pi \left(y_{\mathrm{R}, 0} - y\right)}{\Delta y_\mathrm{R}}\right]\right\} &amp; \mathrm{if} \quad y \leq y_{\mathrm{R}, 0},\\
        \left(2 N_\mathrm{R} \Delta t\right)^{- 1} \left\{1 - \cos \left[\frac{\pi \left(y - y_{\mathrm{R}, 1}\right)}{\Delta y_\mathrm{R}}\right]\right\} &amp; \mathrm{if} \quad y \geq y_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, z} \left(z\right) &amp; = \begin{cases}
        \left(2 N_\mathrm{R} \Delta t\right)^{- 1} \left\{1 - \cos \left[\frac{\pi \left(z - z_\mathrm{R}\right)}{\Delta z_\mathrm{R}}\right]\right\} &amp; \mathrm{if} \quad z \geq z_\mathrm{R},\\
        0 &amp; \mathrm{else}
    \end{cases}
\end{align*}\]</p><p>and otherwise, it is</p><p class="math-container">\[\alpha_\mathrm{R} \left(z\right) = \alpha_{\mathrm{R}, z} \left(z\right),\]</p><p>where <span>$N_\mathrm{R}$</span>, <span>$x_{\mathrm{R}, 0}$</span>, <span>$x_{\mathrm{R}, 1}$</span>, <span>$y_{\mathrm{R}, 0}$</span>, <span>$y_{\mathrm{R}, 1}$</span>, <span>$z_{\mathrm{R}, 0}$</span> and <span>$z_{\mathrm{R}, 1}$</span> are given by <code>state.namelists.sponge.cosmosteps</code> and the properties <code>xsponge0</code>, <code>xsponge1</code>, <code>ysponge0</code>, <code>ysponge1</code>, <code>zsponge0</code> and <code>zsponge1</code> of <code>state.sponge</code>, respectively.</p><pre><code class="language-julia hljs">compute_sponges!(state::State, dt::AbstractFloat, spongetype::PolynomialSponge)</code></pre><p>Compute the Rayleigh-damping coefficient of a polynomial sponge.</p><p>If <code>state.namelists.sponge.lateralsponge</code> is <code>true</code>, the Rayleigh-damping coefficient is</p><p class="math-container">\[\alpha_\mathrm{R} \left(x, y, z\right) = \frac{\alpha_{\mathrm{R}, x} \left(x\right) + \alpha_{\mathrm{R}, y} \left(y\right) + \alpha_{\mathrm{R}, z} \left(z\right)}{3}\]</p><p>with</p><p class="math-container">\[\begin{align*}
    \alpha_{\mathrm{R}, x} \left(x\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \left(\frac{x_{\mathrm{R}, 0} - x}{\Delta x_\mathrm{R}}\right)^{n_\mathrm{R}} &amp; \mathrm{if} \quad x \leq x_{\mathrm{R}, 0},\\
        \alpha_{\mathrm{R}, \max} \left(\frac{x - x_{\mathrm{R}, 1}}{\Delta x_\mathrm{R}}\right)^{n_\mathrm{R}} &amp; \mathrm{if} \quad x \geq x_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, y} \left(y\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \left(\frac{y_{\mathrm{R}, 0} - y}{\Delta y_\mathrm{R}}\right)^{n_\mathrm{R}} &amp; \mathrm{if} \quad y \leq y_{\mathrm{R}, 0},\\
        \alpha_{\mathrm{R}, \max} \left(\frac{y - y_{\mathrm{R}, 1}}{\Delta y_\mathrm{R}}\right)^{n_\mathrm{R}} &amp; \mathrm{if} \quad y \geq y_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, z} \left(z\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \left(\frac{z - z_\mathrm{R}}{\Delta z_\mathrm{R}}\right)^{n_\mathrm{R}} &amp; \mathrm{if} \quad z \geq z_\mathrm{R},\\
        0 &amp; \mathrm{else}
    \end{cases}
\end{align*}\]</p><p>and otherwise, it is</p><p class="math-container">\[\alpha_\mathrm{R} \left(z\right) = \alpha_{\mathrm{R}, z} \left(z\right),\]</p><p>where <span>$n_\mathrm{R}$</span> is given by <code>state.namelists.sponge.spongeorder</code>. If the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.</p><pre><code class="language-julia hljs">compute_sponges!(state::State, dt::AbstractFloat, spongetype::SinusoidalSponge)</code></pre><p>Compute the Rayleigh-damping coefficient of a sinusoidal sponge.</p><p>If <code>state.namelists.sponge.lateralsponge</code> is <code>true</code>, the Rayleigh-damping coefficient is</p><p class="math-container">\[\alpha_\mathrm{R} \left(x, y, z\right) = \frac{\alpha_{\mathrm{R}, x} \left(x\right) + \alpha_{\mathrm{R}, y} \left(y\right) + \alpha_{\mathrm{R}, z} \left(z\right)}{3}\]</p><p>with</p><p class="math-container">\[\begin{align*}
    \alpha_{\mathrm{R}, x} \left(x\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \sin^2 \left[\frac{\pi \left(x_{\mathrm{R}, 0} - x\right)}{2 \Delta x_\mathrm{R}}\right] &amp; \mathrm{if} \quad x \leq x_{\mathrm{R}, 0},\\
        \alpha_{\mathrm{R}, \max} \sin^2 \left[\frac{\pi \left(x - x_{\mathrm{R}, 1}\right)}{2 \Delta x_\mathrm{R}}\right] &amp; \mathrm{if} \quad x \geq x_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, y} \left(y\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \sin^2 \left[\frac{\pi \left(y_{\mathrm{R}, 0} - y\right)}{2 \Delta y_\mathrm{R}}\right] &amp; \mathrm{if} \quad y \leq y_{\mathrm{R}, 0},\\
        \alpha_{\mathrm{R}, \max} \sin^2 \left[\frac{\pi \left(y - y_{\mathrm{R}, 1}\right)}{2 \Delta y_\mathrm{R}}\right] &amp; \mathrm{if} \quad y \geq y_{\mathrm{R}, 1},\\
        0 &amp; \mathrm{else},
    \end{cases}\\
    \alpha_{\mathrm{R}, z} \left(z\right) &amp; = \begin{cases}
        \alpha_{\mathrm{R}, \max} \sin^2 \left[\frac{\pi \left(z - z_\mathrm{R}\right)}{2 \Delta z_\mathrm{R}}\right] &amp; \mathrm{if} \quad z \geq z_\mathrm{R},\\
        0 &amp; \mathrm{else}
    \end{cases}
\end{align*}\]</p><p>and otherwise, it is</p><p class="math-container">\[\alpha_\mathrm{R} \left(z\right) = \alpha_{\mathrm{R}, z} \left(z\right).\]</p><p>If the grid size in a horizontal direction is one, the contribution from that direction is set to zero and the other two are reweighted accordingly.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>dt</code>: Time step.</p></li><li><p><code>spongetype</code>: Specification of the spatial dependence of the  Rayleigh-damping coefficient.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="../boundaries/#PinCFlow.Boundaries.set_zonal_boundaries_of_field!"><code>PinCFlow.Boundaries.set_zonal_boundaries_of_field!</code></a></p></li><li><p><a href="../boundaries/#PinCFlow.Boundaries.set_meridional_boundaries_of_field!"><code>PinCFlow.Boundaries.set_meridional_boundaries_of_field!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_stress_tensor" href="#PinCFlow.Update.compute_stress_tensor"><code>PinCFlow.Update.compute_stress_tensor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_stress_tensor(
    i::Integer,
    j::Integer,
    k::Integer,
    mu::Integer,
    nu::Integer,
    state::State,
)::AbstractFloat</code></pre><p>Compute and return the element <span>$\left(\mu, \nu\right)$</span> of the Cartesian viscous stress tensor at the grid point <span>$\left(i, j, k\right)$</span>, divided by the dynamic viscosity.</p><p>The discretized elements of the Cartesian viscous stress tensor are given by</p><p class="math-container">\[\begin{align*}
    \Pi^{1 1} &amp; = \eta \left[\frac{2}{\Delta \widehat{x}} \left(u_{i + 1 / 2} - u_{i - 1 / 2}\right) + \frac{G^{1 3}}{\Delta \widehat{z}} \left(u_{k + 1} - u_{k - 1}\right) - \frac{2}{3} \delta\right],\\
    \Pi^{1 2} &amp; = \eta \left[\frac{1}{2 \Delta \widehat{y}} \left(u_{j + 1} - u_{j - 1}\right) + \frac{G^{2 3}}{2 \Delta \widehat{z}} \left(u_{k + 1} - u_{k - 1}\right) + \frac{1}{2 \Delta \widehat{x}} \left(v_{i + 1} - v_{i - 1}\right) + \frac{G^{1 3}}{2 \Delta \widehat{z}} \left(v_{k + 1} - v_{k - 1}\right)\right],\\
    \Pi^{1 3} &amp; = \eta \left[\frac{1}{2 J \Delta \widehat{z}} \left(u_{k + 1} - u_{k - 1}\right) + \frac{1}{2 \Delta \widehat{x}} \left(w_{i + 1} - w_{i - 1}\right) + \frac{G^{1 3}}{\Delta \widehat{z}} \left(w_{k + 1 / 2} - w_{k - 1 / 2}\right)\right],\\
    \Pi^{2 2} &amp; = \eta \left[\frac{2}{\Delta \widehat{y}} \left(v_{j + 1 / 2} - v_{j - 1 / 2}\right) + \frac{G^{2 3}}{\Delta \widehat{z}} \left(v_{k + 1} - v_{k - 1}\right) - \frac{2}{3} \delta\right],\\
    \Pi^{2 3} &amp; = \eta \left[\frac{1}{2 J \Delta \widehat{z}} \left(v_{k + 1} - v_{k - 1}\right) + \frac{1}{2 \Delta \widehat{y}} \left(w_{j + 1} - w_{j - 1}\right) + \frac{G^{2 3}}{\Delta \widehat{z}} \left(w_{k + 1 / 2} - w_{k - 1 / 2}\right)\right],\\
    \Pi^{3 3} &amp; = \eta \left[\frac{2}{J \Delta \widehat{z}} \left(w_{k + 1 / 2} - w_{k - 1 / 2}\right) - \frac{2}{3} \delta\right],
\end{align*}\]</p><p>where</p><p class="math-container">\[\begin{align*}
    \delta &amp; = \frac{1}{J} \left[\frac{1}{\Delta \widehat{x}} \left(J_{i + 1 / 2} u_{i + 1 / 2} - J_{i - 1 / 2} u_{i - 1 / 2}\right) + \frac{1}{\Delta \widehat{y}} \left(J_{j + 1 / 2} v_{j + 1 / 2} - J_{j - 1 / 2} v_{j - 1 / 2}\right)\right.\\
    &amp; \qquad \quad + \left.\frac{1}{\Delta \widehat{z}} \left(J_{k + 1 / 2} \widehat{w}_{k + 1 / 2} - J_{k - 1 / 2} \widehat{w}_{k - 1 / 2}\right)\right].
\end{align*}\]</p><p><strong>Arguments</strong></p><ul><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>mu</code>: First contravariant tensor index.</p></li><li><p><code>nu</code>: Second contravariant tensor index.</p></li><li><p><code>state</code>: Model state.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.Update.compute_vertical_wind"><code>PinCFlow.Update.compute_vertical_wind</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_vertical_wind" href="#PinCFlow.Update.compute_vertical_wind"><code>PinCFlow.Update.compute_vertical_wind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_vertical_wind(
    i::Integer,
    j::Integer,
    k::Integer,
    state::State,
)::AbstractFloat</code></pre><p>Compute and return the Cartesian vertical wind at the grid point <span>$\left(i, j, k + 1 / 2\right)$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>state</code>: Model state.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.Update.transform"><code>PinCFlow.Update.transform</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.compute_volume_force" href="#PinCFlow.Update.compute_volume_force"><code>PinCFlow.Update.compute_volume_force</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::AbstractVariable,
)::AbstractFloat</code></pre><p>Return the volume force in the equation specified by <code>variable</code>.</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::AbstractVariable,
    testcase::AbstractTestCase,
)::AbstractFloat</code></pre><p>Return <span>$0$</span> as the volume force in non-WKB test cases (for all variables except the mass-weighted potential temperature).</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::U,
    testcase::AbstractWKBTestCase,
)::AbstractFloat</code></pre><p>Return the gravity-wave drag on the zonal momentum, interpolated to <span>$\left(i + 1 / 2, j, k\right)$</span>.</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::V,
    testcase::AbstractWKBTestCase,
)::AbstractFloat</code></pre><p>Return the gravity-wave drag on the meridional momentum, interpolated to <span>$\left(i, j + 1 / 2, k\right)$</span>.</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::W,
    testcase::AbstractWKBTestCase,
)::AbstractFloat</code></pre><p>Return the gravity-wave drag on the transformed vertical momentum, interpolated to <span>$\left(i, j, k + 1 / 2\right)$</span>, as given by</p><p class="math-container">\[\left(\frac{\partial \widehat{w}}{\partial t}\right)_\mathrm{w} = \left[G^{1 3} \left(\frac{\partial u}{\partial t}\right)_\mathrm{w}\right]_{k + 1 / 2} + \left[G^{2 3} \left(\frac{\partial v}{\partial t}\right)_\mathrm{w}\right]_{k + 1 / 2}.\]</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::P,
    testcase::AbstractTestCase,
)::AbstractFloat</code></pre><p>Return the conductive heating.</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variable::P,
    testcase::AbstractWKBTestCase,
)::AbstractFloat</code></pre><p>Return the sum of gravity-wave impact on the mass-weighted potential temperature and conductive heating.</p><pre><code class="language-julia hljs">compute_volume_force(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    variables::Chi,
    testcase::AbstractWKBTestCase,
)::AbstractFloat</code></pre><p>Return the tracer flux convergence due to gravity waves.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>variable</code>: Variable (equation) of choice.</p></li><li><p><code>testcase</code>: Test case on which the current simulation is based.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.Update.conductive_heating"><code>PinCFlow.Update.conductive_heating</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.conductive_heating" href="#PinCFlow.Update.conductive_heating"><code>PinCFlow.Update.conductive_heating</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conductive_heating(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
)::AbstractFloat</code></pre><p>Compute and return the conductive heating by dispatching to specialized methods dependent on the model.</p><pre><code class="language-julia hljs">conductive_heating(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    model::Boussinesq,
)::AbstractFloat</code></pre><p>Return <span>$0$</span> as conductive heating in Boussinesq mode.</p><pre><code class="language-julia hljs">conductive_heating(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    model::PseudoIncompressible,
)::AbstractFloat</code></pre><p>Return <span>$0$</span> as conductive heating in PseudoIncompressible mode.</p><pre><code class="language-julia hljs">conductive_heating(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    model::Compressible,
)::AbstractFloat</code></pre><p>Compute and return the conductive heating as the divergence of potential temperature fluxes.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>model</code>: Dynamic equations.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.transform" href="#PinCFlow.Update.transform"><code>PinCFlow.Update.transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(
    i::Integer,
    j::Integer,
    k::Integer,
    uedger::AbstractFloat,
    uuedger::AbstractFloat,
    uedgel::AbstractFloat,
    uuedgel::AbstractFloat,
    vedgef::AbstractFloat,
    vuedgef::AbstractFloat,
    vedgeb::AbstractFloat,
    vuedgeb::AbstractFloat,
    wedgeu::AbstractFloat,
    coordinate::Cartesian,
    state::State,
)::AbstractFloat</code></pre><p>Perform the transformation of a vertical-wind-like variable from the transformed system to the Cartesian one, given the wind-like components at the grid points surrounding <span>$\left(i, j, k + 1 / 2\right)$</span>, and return the result.</p><p>The discretized transformation rule for the vertical wind is given by</p><p class="math-container">\[w_{k + 1 / 2} = J_{k + 1 / 2} \left[- \left(G^{1 3} u\right)_{k + 1 / 2} - \left(G^{2 3} v\right)_{k + 1 / 2} + \widehat{w}_{k + 1 / 2}\right].\]</p><pre><code class="language-julia hljs">transform(
    i::Integer,
    j::Integer,
    k::Integer,
    uedger::AbstractFloat,
    uuedger::AbstractFloat,
    uedgel::AbstractFloat,
    uuedgel::AbstractFloat,
    vedgef::AbstractFloat,
    vuedgef::AbstractFloat,
    vedgeb::AbstractFloat,
    vuedgeb::AbstractFloat,
    wedgeu::AbstractFloat,
    coordinate::Transformed,
    state::State,
)::AbstractFloat</code></pre><p>Perform the transformation of a vertical-wind-like variable from the Cartesian system to the transformed one, given the wind-like components at the grid points surrounding <span>$\left(i, j, k + 1 / 2\right)$</span>, and return the result.</p><p>The discretized transformation rule for the vertical wind is given by</p><p class="math-container">\[\widehat{w}_{k + 1 / 2} = \left(G^{1 3} u\right)_{k + 1 / 2} + \left(G^{2 3} v\right)_{k + 1 / 2} + \frac{w_{k + 1 / 2}}{J_{k + 1 / 2}}.\]</p><p><strong>Arguments</strong></p><ul><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>uedger</code>: Zonal-wind equivalent at <span>$\left(i + 1 / 2, j, k\right)$</span>.</p></li><li><p><code>uuedger</code>: Zonal-wind equivalent at <span>$\left(i + 1 / 2, j, k + 1\right)$</span>.</p></li><li><p><code>uedgel</code>: Zonal-wind equivalent at <span>$\left(i - 1 / 2, j, k\right)$</span>.</p></li><li><p><code>uuedgel</code>: Zonal-wind equivalent at <span>$\left(i - 1 / 2, j, k + 1\right)$</span>.</p></li><li><p><code>vedgef</code>: Meridional-wind equivalent at <span>$\left(i, j + 1 / 2, k\right)$</span>.</p></li><li><p><code>vuedgef</code>: Meridional-wind equivalent at <span>$\left(i, j + 1 / 2, k + 1\right)$</span>.</p></li><li><p><code>vedgeb</code>: Meridional-wind equivalent at <span>$\left(i, j - 1 / 2, k\right)$</span>.</p></li><li><p><code>vuedgeb</code>: Meridional-wind equivalent at <span>$\left(i, j - 1 / 2, k + 1\right)$</span>.</p></li><li><p><code>wedgeu</code>: Transformed-vertical-wind equivalent at <span>$\left(i, j, k + 1 / 2\right)$</span></p></li><li><p><code>coordinate</code>: Coordinate system to transform to.</p></li><li><p><code>state</code>: Model state.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.Update.update!" href="#PinCFlow.Update.update!"><code>PinCFlow.Update.update!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::Rho)</code></pre><p>Update the density if the atmosphere is not Boussinesq by dispatching to the appropriate method.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    m::Integer,
    variable::Rho,
    model::Boussinesq,
)</code></pre><p>Return in Boussinesq mode (the density is constant).</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    m::Integer,
    variable::Rho,
    model::AbstractModel,
)</code></pre><p>Update the density with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::RhoP, side::LHS)</code></pre><p>Update the density fluctuations with a Runge-Kutta step on the left-hand-side of the equation.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::RhoP,
    side::RHS,
    integration::Explicit,
)</code></pre><p>Update the density fluctuations with an explicit Euler step the on right-hand side of the equation, without the Rayleigh-damping term.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::RhoP,
    side::RHS,
    integration::Implicit,
    rayleigh_factor::AbstractFloat,
)</code></pre><p>Update the density fluctuations with an implicit Euler step on the right-hand side of the equation.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::U, side::LHS)</code></pre><p>Update the zonal momentum with a Runge-Kutta step on the left-hand side of the equation.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::U,
    side::RHS,
    integration::Explicit,
)</code></pre><p>Update the zonal wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::U,
    side::RHS,
    integration::Implicit,
    rayleigh_factor::AbstractFloat,
)</code></pre><p>Update the zonal wind with an implicit Euler step on the right-hand side of the equation.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::V, side::LHS)</code></pre><p>Update the meridional momentum with a Runge-Kutta step on the left-hand side of the equation.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::V,
    side::RHS,
    integration::Explicit,
)</code></pre><p>Update the meridional wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::V,
    side::RHS,
    integration::Implicit,
    rayleigh_factor::AbstractFloat,
)</code></pre><p>Update the meridional wind with an implicit Euler step on the right-hand side of the equation.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::W, side::LHS)</code></pre><p>Update the transformed vertical momentum with a Runge-Kutta step on the left-hand side of the equation.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::W,
    side::RHS,
    integration::Explicit,
)</code></pre><p>Update the transformed vertical wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    variable::W,
    side::RHS,
    integration::Implicit,
    rayleigh_factor::AbstractFloat,
)</code></pre><p>Update the transformed vertical wind with an implicit Euler step on the right-hand side of the equation.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, variable::PiP)</code></pre><p>Update the Exner-pressure if the atmosphere is compressible by dispatching to the appropriate method.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, variable::PiP, model::AbstractModel)</code></pre><p>Return in non-compressible modes.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, variable::PiP, model::Compressible)</code></pre><p>Update the Exner-pressure such that it is synchronized with the updated mass-weighted potential temperature.</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, variable::P)</code></pre><p>Update the mass-weighted potential temperature if the atmosphere is compressible by dispatching to the appropriate method.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    m::Integer,
    variable::P,
    model::AbstractModel,
)</code></pre><p>Return in non-compressible modes.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    m::Integer,
    variable::P,
    model::Compressible,
)</code></pre><p>Update the mass-weighted potential temperature with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).</p><pre><code class="language-julia hljs">update!(state::State, dt::AbstractFloat, m::Integer, tracersetup::NoTracer)</code></pre><p>Return for configurations without tracer transport.</p><pre><code class="language-julia hljs">update!(
    state::State,
    dt::AbstractFloat,
    m::Integer,
    tracersetup::AbstractTracer,
)</code></pre><p>Update the tracers with a Runge-Kutta step on the left-hand sides of the equations with WKB right-hand side terms according to namelists configuration.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>dt</code>: Time step.</p></li><li><p><code>m</code>: Runge-Kutta-stage index.</p></li><li><p><code>variable</code>: Variable to update.</p></li><li><p><code>model</code>: Dynamic equations.</p></li><li><p><code>side</code>: Side of the equation.</p></li><li><p><code>integration</code>: Type of the Euler step.</p></li><li><p><code>rayleigh_factor</code>: Factor by which the Rayleigh-damping coefficient is multiplied.</p></li><li><p><code>tracersetup</code>: General tracer-transport configuration.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.Update.compute_volume_force"><code>PinCFlow.Update.compute_volume_force</code></a></p></li><li><p><a href="#PinCFlow.Update.compute_compressible_wind_factor"><code>PinCFlow.Update.compute_compressible_wind_factor</code></a></p></li><li><p><a href="#PinCFlow.Update.compute_vertical_wind"><code>PinCFlow.Update.compute_vertical_wind</code></a></p></li><li><p><a href="#PinCFlow.Update.compute_buoyancy_factor"><code>PinCFlow.Update.compute_buoyancy_factor</code></a></p></li><li><p><a href="#PinCFlow.Update.compute_pressure_gradient"><code>PinCFlow.Update.compute_pressure_gradient</code></a></p></li><li><p><a href="#PinCFlow.Update.transform"><code>PinCFlow.Update.transform</code></a></p></li><li><p><a href="#PinCFlow.Update.conductive_heating"><code>PinCFlow.Update.conductive_heating</code></a></p></li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../poisson_solver/">« PoissonSolver</a><a class="docs-footer-nextpage" href="../msgwam/">MSGWaM »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 25 September 2025 10:06">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
