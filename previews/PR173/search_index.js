var documenterSearchIndex = {"docs":
[{"location":"reference/update/#Update","page":"Update","title":"Update","text":"","category":"section"},{"location":"reference/update/#PinCFlow.Update","page":"Update","title":"PinCFlow.Update","text":"Update\n\nModule for integrating the prognostic equations.\n\nProvides functions for updating the prognostic variables at the various stages of the semi-implicit time scheme.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\n\n\n\n\n\n","category":"module"},{"location":"reference/update/#PinCFlow.Update.Cartesian","page":"Update","title":"PinCFlow.Update.Cartesian","text":"Cartesian\n\nSingleton for transformations from the terrain-following system to the Cartesian one.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.LHS","page":"Update","title":"PinCFlow.Update.LHS","text":"LHS\n\nSingleton for the integration of the left-hand side of an equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.RHS","page":"Update","title":"PinCFlow.Update.RHS","text":"RHS\n\nSingleton for the integration of the right-hand side of an equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Transformed","page":"Update","title":"PinCFlow.Update.Transformed","text":"Transformed\n\nSingleton for transformations from the Cartesian system to the terrain-following one.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.X","page":"Update","title":"PinCFlow.Update.X","text":"X\n\nSingleton for widehatx-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Y","page":"Update","title":"PinCFlow.Update.Y","text":"Y\n\nSingleton for widehaty-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.Z","page":"Update","title":"PinCFlow.Update.Z","text":"Z\n\nSingleton for widehatz-axis along which a calculation should be performed.\n\n\n\n\n\n","category":"type"},{"location":"reference/update/#PinCFlow.Update.apply_lhs_sponge!","page":"Update","title":"PinCFlow.Update.apply_lhs_sponge!","text":"apply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::AbstractPredictand,\n)\n\nPerform an implicit substep to integrate the Rayleigh-damping term that represents the LHS sponge in the prognostic equation for variable by dispatching to the appropriate model-specific method.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::Rho,\n    model::Boussinesq,\n)\n\nReturn in Boussinesq mode (constant density).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::Rho,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the continuity equation.\n\nThe update is given by\n\nrho rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 left(rho + alpha_mathrmR Delta t overlinerhoright)\n\nwhere alpha_mathrmR is the Rayleigh-damping coefficient computed by PinCFlow.Update.compute_sponges! and Delta t is the time step given as input to this method.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::RhoP,\n    model::Compressible,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the auxiliary equation in compressible mode.\n\nThe update is given by\n\nrho rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 leftrho + alpha_mathrmR Delta t overlinerho left(1 - fracPrho overlinethetaright)right\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::RhoP,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the auxiliary equation in non-compressible modes.\n\nThe update is given by\n\nrho rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 rho\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::U,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the zonal-momentum equation.\n\nThe update is given by\n\nu_i + 1  2 rightarrow left(1 + alpha_mathrmR i + 1  2 Delta tright)^- 1 left(u_i + 1  2 + alpha_mathrmR i + 1  2 Delta t u_mathrmR i + 1  2right)\n\nIf state.namelists.sponge.relax_to_mean is false, u_mathrmR i + 1  2 is computed with state.namelist.sponge.relaxed_u. Otherwise, it is replaced with the average of u_i + 1  2 across the terrain-following coordinate surface.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::V,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the meridional-momentum equation.\n\nThe update is given by\n\nv_j + 1  2 rightarrow left(1 + alpha_mathrmR j + 1  2 Delta tright)^- 1 left(v_j + 1  2 + alpha_mathrmR j + 1  2 Delta t v_mathrmR j + 1  2right)\n\nIf state.namelists.sponge.relax_to_mean is false, v_mathrmR j + 1  2 is computed with state.namelist.sponge.relaxed_v. Otherwise, it is replaced with the average of v_j + 1  2 across the terrain-following coordinate surface.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::W,\n    model::AbstractModel,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the transformed-vertical-momentum equation.\n\nThe update is given by\n\nwidehatw_k + 1  2 rightarrow left(1 + alpha_mathrmR k + 1  2 Delta tright)^- 1 left(widehatw_k + 1  2 + alpha_mathrmR k + 1  2 Delta t widehatw_mathrmR k + 1  2right)\n\nIf state.namelists.sponge.relax_to_mean is false, widehatw_mathrmR k + 1  2 is computed with the functions relaxed_u, relaxed_v and relaxed_w in state.namelists.sponge. Otherwise, it is replaced with the average of widehatw_k + 1  2 across the terrain-following coordinate surface.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::PiP,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes (Exner-pressure fluctuations are only updated in the corrector step).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::PiP,\n    model::Compressible,\n)\n\nUpdate the Exner-pressure fluctuations to account for the Rayleigh damping applied to the mass-weighted potential temperature.\n\nThe update is given by\n\npi rightarrow pi - alpha_mathrmR Delta t P fracpartial pipartial P left(1 - fracoverlinerhorhoright)\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::P,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes (mass-weighted potential temperature is constant in time).\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    variable::P,\n    model::Compressible,\n)\n\nIntegrate the Rayleigh-damping term that represents the LHS sponge in the thermodynamic-energy equation.\n\nThe update is given by\n\nP rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 P left(1 + alpha_mathrmR Delta t fracoverlinerhorhoright)\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    tracer_setup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\napply_lhs_sponge!(\n    state::State,\n    dt::AbstractFloat,\n    time::AbstractFloat,\n    tracer_setup::TracerOn,\n)\n\nIntegrate the Rayleigh-damping terms that represent the LHS sponge in the tracer equations.\n\nIn each tracer equation, the update is given by\n\nleft(rho chiright) rightarrow left(1 + alpha_mathrmR Delta tright)^- 1 leftrho chi + alpha_mathrmR Delta t left(rho chiright)^left(0right)right\n\nArguments\n\nstate: Model state.\ndt: Time step.\ntime: Simulation time.\nvariable: Variable to apply Rayleigh damping to.\nmodel: Dynamic equations.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_buoyancy_factor","page":"Update","title":"PinCFlow.Update.compute_buoyancy_factor","text":"compute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::Union{RhoP, W},\n)::AbstractFloat\n\nCompute the factor by which the buoyancy term should be multiplied at left(i j kright) or left(i j k + 1  2right), by dispatching to a method specific for the dynamic equations and variable, and return the result.\n\nIn pseudo-incompressible mode, rho are deviations of the total density from overlinerho, which describes the reference atmosphere. However, in compressible mode, rho = rho - P  overlinetheta does not reduce to this, i.e. the density background has a spatiotemporal dependence. As a consequence, the right-hand side of the prognostic equation for rho is given by\n\nleft(fracpartial rhopartial tright)_N^2 = f_rho fracN^2 rho wg\n\nwith f_rho = overlinerho  rho in pseudo-incompressible mode and f_rho = P  left(rho overlinethetaright) in compressible mode. This method returns either f_rho at left(i j kright) or f_w, which is the interpolation of f_rho to left(i j k + 1  2right), based on the type of variable.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::RhoP,\n    model::Compressible,\n)::AbstractFloat\n\nReturn f_rho = P  left(rho overlinethetaright) as the factor by which the buoyancy term should be multiplied at left(i j kright) in compressible mode.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::RhoP,\n    model::Union{Boussinesq, PseudoIncompressible},\n)::AbstractFloat\n\nReturn f_rho = overlinerho  rho as the factor by which the buoyancy term should be multiplied at left(i j kright) in pseudo-incompressible mode (this method is also used in Boussinesq mode).\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::Compressible,\n)::AbstractFloat\n\nReturn f_w = left(P  overlinethetaright)_k + 1  2  rho_k + 1  2 as the factor by which the buoyancy term should be multiplied in compressible mode.\n\ncompute_buoyancy_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::Union{Boussinesq, PseudoIncompressible},\n)::AbstractFloat\n\nReturn f_w = overlinerho_k + 1  2  rho_k + 1  2 as the factor by which the buoyancy term should be multiplied at left(i j k + 1  2right) in pseudo-incompressible mode (this method is also used in Boussinesq mode).\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable for which the factor is needed.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_compressible_wind_factor","page":"Update","title":"PinCFlow.Update.compute_compressible_wind_factor","text":"compute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::Union{U, V, W},\n)::AbstractFloat\n\nCompute the factor by which the wind should be multiplied at left(i + 1  2 j kright), left(i j + 1  2 kright) or left(i j k + 1  2right), by dispatching to a method specific for the dynamic equations and the component indicated by variable, and return the result.\n\nIn compressible mode, the Euler steps that are used to integrate the right-hand side of the momentum equation update left(J Pright)_i + 1  2 u_i + 1  2, left(J Pright)_j + 1  2 v_j + 1  2 and left(J Pright)_k + 1  2 widehatw_k + 1  2 instead of u_i + 1  2, v_j + 1  2 and widehatw_k + 1  2.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::Union{U, V, W},\n    model::Union{Boussinesq, PseudoIncompressible},\n)::AbstractFloat\n\nReturn 1 as the factor by which the wind should be multiplied in non-compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_i + 1  2 as the factor by which the zonal wind should be multiplied in compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_j + 1  2 as the factor by which the meridional wind should be multiplied in compressible mode.\n\ncompute_compressible_wind_factor(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    model::Compressible,\n)::AbstractFloat\n\nReturn left(J Pright)_k + 1  2 as the factor by which the transformed vertical wind should be multiplied in compressible mode.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable for which the factor is needed.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_momentum_diffusion_terms","page":"Update","title":"PinCFlow.Update.compute_momentum_diffusion_terms","text":"compute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehatx-direction, i.e.\n\nwidehatleft(boldsymbolnabla uright)^widehatx = fracu_i + 1  2 - u_i - 1  2Delta widehatx + G^13 fracu_k + 1 - u_k - 12Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehaty-direction, i.e.\n\nwidehatleft(boldsymbolnabla uright)^widehaty = fracu_j + 1 - u_j - 12Delta widehaty + G^23 fracu_k + 1 - u_k - 12Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive zonal momentum fluxes in widehatz-direction, i.e.\n\nwidehatleft(boldsymbolnabla uright)^widehatz = G^13fracu_i + 1  2 - u_i - 1  2Delta widehatx + G^23 fracu_j + 1 - u_j - 12 Delta widehaty + G^33 fracu_k + 1 - u_k - 12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehatx-direction, i.e.\n\nwidehatleft(boldsymbolnabla vright)^widehatx = fracv_i + 1 - v_i - 12 Delta widehatx + G^13 fracv_k + 1 - v_k - 12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehaty-direction, i.e.\n\nwidehatleft(boldsymbolnabla vright)^widehaty = fracv_j + 1  2 - v_j - 1  2Delta widehaty + G^23 fracv_k + 1 - v_k - 12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive meridional momentum fluxes in widehatz-direction, i.e.\n\nwidehatleft(boldsymbolnabla vright)^widehatz = G^13fracv_i + 1 - v_i - 12 Delta widehatx + G^23 fracv_j + 1  2 - v_j - 1  2Delta widehaty + G^33 fracv_k + 1 - v_k - 12 Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::X,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehatx-direction, i.e.\n\nwidehatleft(boldsymbolnabla wright)^widehatx = fracw_i + 1 - w_i - 12 Delta widehatx + G^13 fracw_k + 1  2 - w_k - 1  2Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::Y,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehaty-direction, i.e.\n\nwidehatleft(boldsymbolnabla wright)^widehaty = fracw_j + 1 - w_j - 12 Delta widehaty + G^23 fracw_k + 1  2 - w_k - 1  2Delta widehatz\n\ncompute_momentum_diffusion_terms(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    direction::Z,\n)::AbstractFloat\n\nCompute and return the diffusive vertical momentum fluxes in widehatz-direction, i.e.\n\nwidehatleft(boldsymbolnabla wright)^widehatz = G^13 fracw_i + 1 - w_i - 12 Delta widehatx + G^23 fracw_j + 1 - w_j - 12 Delta widehaty + G^33 fracw_k + 1  2 - w_k - 1  2Delta widehatz\n\nArguments\n\nstate: Model state.\ni: Grid-cell index on the widehatx-axis.\nj: Grid-cell index on the widehaty-axis.\nk: Grid-cell index on the widehatz-axis.\nvariable: Wind direction.\ndirection: Direction of the flux.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_pressure_gradient","page":"Update","title":"PinCFlow.Update.compute_pressure_gradient","text":"compute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n)::AbstractFloat\n\nCompute and return the pressure(-difference)-gradient term in the zonal-wind equation at left(i + 1  2 j kright), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nmathcalP^rho u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 fracpi_i + 1  2 k + 1 - pi_i + 1  2 k - 12 Delta widehatz\n\nSince the Exner-pressure is not known in the vertical ghost cells, a different discretization is needed at the vertical boundaries. At k = k_0 (in the first process in widehatz), the alternative second-order-accurate approximation\n\nmathcalP^rho u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 frac- pi_i + 1  2 k + 2 + 4 pi_i + 1  2 k + 1 - 3 pi_i + 1  22 Delta widehatz\n\nis used and, in a similar manner, one has\n\nmathcalP^rho u_i + 1  2 = fracpi_i + 1 - piDelta widehatx + G^13_i + 1  2 fracpi_i + 1  2 k - 2 - 4 pi_i + 1  2 k - 1 + 3 pi_i + 1  22 Delta widehatz\n\nat k = k_1 (in the last process in widehatz). The corresponding pressure-difference-gradient component mathcalD^rho u_i + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_i + 1  2  rho_i + 1  2right).\n\ncompute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n)::AbstractFloat\n\nCompute and return the pressure-gradient term in the meridional-wind equation at left(i j + 1  2 kright), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nmathcalP^rho v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 fracpi_j + 1  2 k + 1 - pi_j + 1  2 k - 12 Delta widehatz\n\nAnalogous to the component in the zonal-wind equation, one has\n\nmathcalP^rho v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 frac- pi_j + 1  2 k + 2 + 4 pi_j + 1  2 k + 1 - 3 pi_j + 1  22 Delta widehatz\n\nat k = k_0 (in the first process in widehatz) and\n\nmathcalP^rho v_j + 1  2 = fracpi_j + 1 - piDelta widehaty + G^23_j + 1  2 fracpi_j + 1  2 k - 2 - 4 pi_j + 1  2 k - 1 + 3 pi_j + 1  22 Delta widehatz\n\nat k = k_1 (in the last process in widehatz). The corresponding pressure-difference-gradient component mathcalD^rho v_j + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_j + 1  2  rho_j + 1  2right).\n\ncompute_pressure_gradient(\n    state::State,\n    pip::AbstractArray{<:AbstractFloat, 3},\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n)::AbstractFloat\n\nCompute and return the pressure(-difference)-gradient term in the transformed-vertical-wind equation at left(i j k + 1  2right), using the pressure(-difference) field pip.\n\nThe pressure-gradient component is given by\n\nbeginalign*\n    mathcalP^rho widehatw_k + 1  2  = G^13_k + 1  2 fracpi_i + 1 k + 1  2 - pi_i - 1 k + 1  22 Delta widehatx + G^23_k + 1  2 fracpi_j + 1 k + 1  2 - pi_j - 1 k + 1  22 Delta widehaty\n     quad + G^33_k + 1  2 fracpi_k + 1 - piDelta widehatz\n endalign*\n\nAt k = k_0 - 1 (in the first process in widehatz) and k = k_1 (in the last process in widehatz), it is set to zero. The corresponding pressure-difference-gradient component mathcalD^rho widehatw_k + 1  2 is obtained by replacing pi with Delta pi. The returned quantity also includes the factor c_p left(P_k + 1  2  rho_k + 1  2right).\n\nArguments\n\nstate: Model state.\npip: Pressure field.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Equation in which the respective pressure-gradient component is needed.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_sponges!","page":"Update","title":"PinCFlow.Update.compute_sponges!","text":"compute_sponges!(state::State, dt::AbstractFloat, time::AbstractFloat)\n\nCompute the Rayleigh-damping coefficients of the two sponges.\n\nThe coefficients are computed with the functions lhs_sponge and rhs_sponge in state.namelists.sponge.\n\nArguments\n\nstate: Model state.\ndt: Time step.\ntime: Simulation time.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_stress_tensor","page":"Update","title":"PinCFlow.Update.compute_stress_tensor","text":"compute_stress_tensor(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    mu::Integer,\n    nu::Integer,\n    state::State,\n)::AbstractFloat\n\nCompute and return the element left(mu nuright) of the Cartesian stress tensor at the grid point left(i j kright).\n\nThe discretized elements of the Cartesian stress tensor are given by\n\nbeginalign*\n    Pi^1 1  = frac2Delta widehatx left(u_i + 1  2 - u_i - 1  2right) + fracG^1 3Delta widehatz left(u_k + 1 - u_k - 1right) - frac23 delta\n    Pi^1 2  = frac12 Delta widehaty left(u_j + 1 - u_j - 1right) + fracG^2 32 Delta widehatz left(u_k + 1 - u_k - 1right) + frac12 Delta widehatx left(v_i + 1 - v_i - 1right) + fracG^1 32 Delta widehatz left(v_k + 1 - v_k - 1right)\n    Pi^1 3  = frac12 J Delta widehatz left(u_k + 1 - u_k - 1right) + frac12 Delta widehatx left(w_i + 1 - w_i - 1right) + fracG^1 3Delta widehatz left(w_k + 1  2 - w_k - 1  2right)\n    Pi^2 2  = frac2Delta widehaty left(v_j + 1  2 - v_j - 1  2right) + fracG^2 3Delta widehatz left(v_k + 1 - v_k - 1right) - frac23 delta\n    Pi^2 3  = frac12 J Delta widehatz left(v_k + 1 - v_k - 1right) + frac12 Delta widehaty left(w_j + 1 - w_j - 1right) + fracG^2 3Delta widehatz left(w_k + 1  2 - w_k - 1  2right)\n    Pi^3 3  = frac2J Delta widehatz left(w_k + 1  2 - w_k - 1  2right) - frac23 delta\nendalign*\n\nwhere\n\nbeginalign*\n    delta  = frac1J leftfrac1Delta widehatx left(J_i + 1  2 u_i + 1  2 - J_i - 1  2 u_i - 1  2right) + frac1Delta widehaty left(J_j + 1  2 v_j + 1  2 - J_j - 1  2 v_j - 1  2right)right\n     qquad quad + leftfrac1Delta widehatz left(J_k + 1  2 widehatw_k + 1  2 - J_k - 1  2 widehatw_k - 1  2right)right\nendalign*\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nmu: First contravariant tensor index.\nnu: Second contravariant tensor index.\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_vertical_wind","page":"Update","title":"PinCFlow.Update.compute_vertical_wind","text":"compute_vertical_wind(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    state::State,\n)::AbstractFloat\n\nCompute and return the Cartesian vertical wind at the grid point left(i j k + 1  2right).\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.transform\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.compute_volume_force","page":"Update","title":"PinCFlow.Update.compute_volume_force","text":"compute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::Union{U, V, W, P, Chi},\n)::AbstractFloat\n\nReturn the volume force in the equation specified by variable, by dispatching to an equation-and-WKB-mode specific method.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::Union{U, V, W, Chi},\n    wkb_mode::NoWKB,\n)::AbstractFloat\n\nReturn 0 as the volume force in non-WKB configurations (for all variables except the mass-weighted potential temperature).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::U,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::AbstractFloat\n\nReturn the gravity-wave drag on the zonal momentum, interpolated to left(i + 1  2 j kright).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::V,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::AbstractFloat\n\nReturn the gravity-wave drag on the meridional momentum, interpolated to left(i j + 1  2 kright).\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::W,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::AbstractFloat\n\nReturn the gravity-wave drag on the transformed vertical momentum, interpolated to left(i j k + 1  2right), as given by\n\nleft(fracpartial widehatwpartial tright)_mathrmw = leftG^1 3 left(fracpartial upartial tright)_mathrmwright_k + 1  2 + leftG^2 3 left(fracpartial vpartial tright)_mathrmwright_k + 1  2\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::P,\n    wkb_mode::NoWKB,\n)::AbstractFloat\n\nReturn the conductive heating.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variable::P,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::AbstractFloat\n\nReturn the sum of gravity-wave impact on the mass-weighted potential temperature and conductive heating.\n\ncompute_volume_force(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    variables::Chi,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::AbstractFloat\n\nReturn the tracer flux convergence due to gravity waves.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nvariable: Variable (equation) of choice.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.conductive_heating","page":"Update","title":"PinCFlow.Update.conductive_heating","text":"conductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::AbstractFloat\n\nCompute and return the conductive heating by dispatching to specialized methods dependent on the model.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::Boussinesq,\n)::AbstractFloat\n\nReturn 0 as conductive heating in Boussinesq mode.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::PseudoIncompressible,\n)::AbstractFloat\n\nReturn 0 as conductive heating in PseudoIncompressible mode.\n\nconductive_heating(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    model::Compressible,\n)::AbstractFloat\n\nCompute and return the conductive heating as the convergence of potential temperature fluxes (weighted by the density), i.e.\n\nleft(fracpartial Ppartial tright)_lambda = - fracrhoJ left(fracmathcalF_i + 1  2^theta widehatx - mathcalF_i - 1  2^theta widehatxDelta widehatx + fracmathcalF_j + 1  2^theta widehaty - mathcalF_j - 1  2^theta widehatyDelta widehaty + fracmathcalF_k + 1  2^theta widehatz - mathcalF_k - 1  2^theta widehatzDelta widehatzright)\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.transform","page":"Update","title":"PinCFlow.Update.transform","text":"transform(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    uedger::AbstractFloat,\n    uuedger::AbstractFloat,\n    uedgel::AbstractFloat,\n    uuedgel::AbstractFloat,\n    vedgef::AbstractFloat,\n    vuedgef::AbstractFloat,\n    vedgeb::AbstractFloat,\n    vuedgeb::AbstractFloat,\n    wedgeu::AbstractFloat,\n    coordinate::Cartesian,\n    state::State,\n)::AbstractFloat\n\nPerform the transformation of a vertical-wind-like variable from the transformed system to the Cartesian one, given the wind-like components at the grid points surrounding left(i j k + 1  2right), and return the result.\n\nThe discretized transformation rule for the vertical wind is given by\n\nw_k + 1  2 = J_k + 1  2 left- left(G^1 3 uright)_k + 1  2 - left(G^2 3 vright)_k + 1  2 + widehatw_k + 1  2right\n\ntransform(\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    uedger::AbstractFloat,\n    uuedger::AbstractFloat,\n    uedgel::AbstractFloat,\n    uuedgel::AbstractFloat,\n    vedgef::AbstractFloat,\n    vuedgef::AbstractFloat,\n    vedgeb::AbstractFloat,\n    vuedgeb::AbstractFloat,\n    wedgeu::AbstractFloat,\n    coordinate::Transformed,\n    state::State,\n)::AbstractFloat\n\nPerform the transformation of a vertical-wind-like variable from the Cartesian system to the transformed one, given the wind-like components at the grid points surrounding left(i j k + 1  2right), and return the result.\n\nThe discretized transformation rule for the vertical wind is given by\n\nwidehatw_k + 1  2 = left(G^1 3 uright)_k + 1  2 + left(G^2 3 vright)_k + 1  2 + fracw_k + 1  2J_k + 1  2\n\nArguments\n\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\nuedger: Zonal-wind equivalent at left(i + 1  2 j kright).\nuuedger: Zonal-wind equivalent at left(i + 1  2 j k + 1right).\nuedgel: Zonal-wind equivalent at left(i - 1  2 j kright).\nuuedgel: Zonal-wind equivalent at left(i - 1  2 j k + 1right).\nvedgef: Meridional-wind equivalent at left(i j + 1  2 kright).\nvuedgef: Meridional-wind equivalent at left(i j + 1  2 k + 1right).\nvedgeb: Meridional-wind equivalent at left(i j - 1  2 kright).\nvuedgeb: Meridional-wind equivalent at left(i j - 1  2 k + 1right).\nwedgeu: Transformed-vertical-wind equivalent at left(i j k + 1  2right)\ncoordinate: Coordinate system to transform to.\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/update/#PinCFlow.Update.update!","page":"Update","title":"PinCFlow.Update.update!","text":"update!(state::State, dt::AbstractFloat, m::Integer, variable::Rho)\n\nUpdate the density if the atmosphere is not Boussinesq by dispatching to the appropriate method.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::Rho,\n    model::Boussinesq,\n)\n\nReturn in Boussinesq mode (the density is constant).\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::Rho,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nUpdate the density with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).\n\nThe update is given by\n\nbeginalign*\n    q^rho  rightarrow - fracDelta tJ left(fracmathcalF^rho widehatx_i + 1  2 - mathcalF^rho widehatx_i - 1  2Delta widehatx + fracmathcalF^rho widehaty_j + 1  2 - mathcalF^rho widehaty_j - 1  2Delta widehaty + fracmathcalF^rho widehatz_k + 1  2 - mathcalF^rho widehatz_k - 1  2Delta widehatzright) + alpha_mathrmRK q^rho\n    rho  rightarrow rho + beta_mathrmRK q^rho\nendalign*\n\nwhere Delta t is the time step given as input to this method.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::RhoP, side::LHS)\n\nUpdate the density fluctuations with a Runge-Kutta step on the left-hand-side of the equation.\n\nThe update is given by\n\nbeginalign*\n    q^rho  rightarrow - fracDelta tJ left(fracmathcalF^rho widehatx_i + 1  2 - mathcalF^rho widehatx_i - 1  2Delta widehatx + fracmathcalF^rho widehaty_j + 1  2 - mathcalF^rho widehaty_j - 1  2Delta widehaty + fracmathcalF^rho widehatz_k + 1  2 - mathcalF^rho widehatz_k - 1  2Delta widehatzright) + alpha_mathrmRK q^rho\n    rho  rightarrow rho + beta_mathrmRK q^rho\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    q^rho  rightarrow Delta t left- frac1J left(fracmathcalF^rho widehatx_i + 1  2 - mathcalF^rho widehatx_i - 1  2Delta widehatx + fracmathcalF^rho widehaty_j + 1  2 - mathcalF^rho widehaty_j - 1  2Delta widehaty + fracmathcalF^rho widehatz_k + 1  2 - mathcalF^rho widehatz_k - 1  2Delta widehatzright) + fracF^Poverlinethetaright + alpha_mathrmRK q^rho\n    rho  rightarrow rho + beta_mathrmRK q^rho\nendalign*\n\nin compressible mode.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the density fluctuations with an explicit Euler step the on right-hand side of the equation, without the Rayleigh-damping term.\n\nThe update is given by\n\nrho rightarrow - fracrhog left(b - Delta t N^2 fracoverlinerhorho wright)\n\nin Boussinesq/pseudo-incompressible mode and\n\nrho rightarrow - fracrhog leftb - Delta t N^2 fracP  overlinethetarho left(fracW_k + 1  2left(J Pright)_k + 1  2right)right\n\nin compressible mode, where b = - g rho  rho.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the density fluctuations with an implicit Euler step on the right-hand side of the equation.\n\nThe update is given by\n\nbeginalign*\n    rho  rightarrow - fracrhog left1 + beta_mathrmR Delta t + fracoverlinerhorho left(N Delta tright)^2right^- 1\n     quad times left- fracoverlinerhorho N^2 Delta t J leftwidehatw_mathrmold + Delta t left(- left(c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatwright) + left(fracF_k + 1  2^rho widehatwrho_k + 1  2right)right)right + left(1 + beta_mathrmR Delta tright) bright\n     qquad quad + leftfracoverlinerhorho N^2 Delta t J left(1 + beta_mathrmR Delta tright) left(G^13 u + G^23 vright)vphantomleftleft(fracF_k + 1  2^rho widehatwrho_k + 1  2right)rightright\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    rho  rightarrow - fracrhog left1 + beta_mathrmR Delta t + fracP  overlinethetarho left(N Delta tright)^2right^- 1\n     quad times left- fracP  overlinethetarho N^2 Delta t J leftleft(fracwidehatW_mathrmold k + 1  2left(J Pright)_k + 1  2right) + Delta t left(- left(c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatwright) + left(fracF_k + 1  2^rho widehatwrho_k + 1  2right)right)rightright\n     qquad quad + left(1 + beta_mathrmR Delta tright) b + fracP  overlinethetarho N^2 Delta t J left(1 + beta_mathrmR Delta tright)\n     qquad quad times leftleftG^13 left(fracU_i + 1  2left(J Pright)_i + 1  2right) + G^23 left(fracV_j + 1  2left(J Pright)_j + 1  2right)rightright\nendalign*\n\nin compressible mode, where widehatw_mathrmold is the transformed vertical wind stored in state.variables.backups.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::U, side::LHS)\n\nUpdate the zonal momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nThe update is given by\n\nbeginalign*\n    q^rho u_i + 1  2  rightarrow Delta t left- frac1J_i + 1  2 left(fracmathcalF^rho u widehatx_i + 1 - mathcalF^rho u widehatxDelta widehatx + fracmathcalF^rho u widehaty_i + 1  2 j + 1  2 - mathcalF^rho u widehaty_i + 1  2 j - 1  2Delta widehatyrightright\n     qquad qquad qquad qquad + leftleftfracmathcalF^rho u widehatz_i + 1  2 k + 1  2 - mathcalF^rho u widehatz_i + 1  2 k - 1  2Delta widehatzright) + f left(rho_mathrmold vright)_i + 1  2right + alpha_mathrmRK q^rho u_i + 1  2\n    u_i + 1  2  rightarrow rho_i + 1  2^- 1 left(rho_mathrmold i + 1  2 u_i + 1  2 + beta_mathrmRK q^rho u_i + 1  2right)\nendalign*\n\nwhere rho_mathrmold is the density stored in state.variables.backups.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the zonal wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nThe update is given by\n\nu_i + 1  2 rightarrow u_i + 1  2 + Delta t left(- c_p fracP_i + 1  2rho_i + 1  2 mathcalP_i + 1  2^rho u + fracF_i + 1  2^rho urho_i + 1  2right)\n\nin Boussinesq/pseudo-incompressible mode and\n\nU_i + 1  2 rightarrow U_i + 1  2 + Delta t left(J Pright)_i + 1  2 left(- c_p fracP_i + 1  2rho_i + 1  2 mathcalP_i + 1  2^rho u + fracF_i + 1  2^rho urho_i + 1  2right)\n\nin compressible mode.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the zonal wind with an implicit Euler step on the right-hand side of the equation.\n\nThe update is given by\n\nu_i + 1  2 rightarrow left(1 + beta_mathrmR i + 1  2 Delta tright)^- 1 leftu_i + 1  2 + Delta t left(- c_p fracP_i + 1  2rho_i + 1  2 mathcalP_i + 1  2^rho u + fracF_i + 1  2^rho urho_i + 1  2right)right\n\nin Boussinesq/pseudo-incompressible mode and\n\nU_i + 1  2 rightarrow left(1 + beta_mathrmR i + 1  2 Delta tright)^- 1 leftU_i + 1  2 + Delta t left(J Pright)_i + 1  2 left(- c_p fracP_i + 1  2rho_i + 1  2 mathcalP_i + 1  2^rho u + fracF_i + 1  2^rho urho_i + 1  2right)right\n\nin compressible mode.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::V, side::LHS)\n\nUpdate the meridional momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nThe update is given by\n\nbeginalign*\n    q^rho v_j + 1  2  rightarrow Delta t left- frac1J_j + 1  2 left(fracmathcalF^rho v widehatx_i + 1  2 j + 1  2 - mathcalF^rho v widehatx_i - 1  2 j + 1  2Delta widehatx + fracmathcalF^rho v widehaty_j + 1 - mathcalF^rho v widehatyDelta widehatyrightright\n     qquad qquad qquad qquad + leftleftfracmathcalF^rho v widehatz_j + 1  2 k + 1  2 - mathcalF^rho v widehatz_j + 1  2 k - 1  2Delta widehatzright) - f left(rho_mathrmold u_mathrmoldright)_j + 1  2right + alpha_mathrmRK q^rho v_j + 1  2\n    v_j + 1  2  rightarrow rho_j + 1  2^- 1 left(rho_mathrmold j + 1  2 v_j + 1  2 + beta_mathrmRK q^rho v_j + 1  2right)\nendalign*\n\nwhere rho_mathrmold and u_mathrmold i + 1  2 are the density and zonal wind stored in state.variables.backups.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the meridional wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nThe update is given by\n\nv_i + 1  2 rightarrow v_j + 1  2 + Delta t left(- c_p fracP_j + 1  2rho_j + 1  2 mathcalP_j + 1  2^rho v + fracF_j + 1  2^rho vrho_j + 1  2right)\n\nin Boussinesq/pseudo-incompressible mode and\n\nV_j + 1  2 rightarrow V_j + 1  2 + Delta t left(J Pright)_j + 1  2 left(- c_p fracP_j + 1  2rho_j + 1  2 mathcalP_j + 1  2^rho v + fracF_j + 1  2^rho vrho_j + 1  2right)\n\nin compressible mode.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the meridional wind with an implicit Euler step on the right-hand side of the equation.\n\nThe update is given by\n\nv_j + 1  2 rightarrow left(1 + beta_mathrmR j + 1  2 Delta tright)^- 1 leftv_j + 1  2 + Delta t left(- c_p fracP_j + 1  2rho_j + 1  2 mathcalP_j + 1  2^rho v + fracF_j + 1  2^rho vrho_j + 1  2right)right\n\nin Boussinesq/pseudo-incompressible mode and\n\nV_j + 1  2 rightarrow left(1 + beta_mathrmR j + 1  2 Delta tright)^- 1 leftV_j + 1  2 + Delta t left(J Pright)_j + 1  2 left(- c_p fracP_j + 1  2rho_j + 1  2 mathcalP_j + 1  2^rho v + fracF_j + 1  2^rho vrho_j + 1  2right)right\n\nin compressible mode.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::W, side::LHS)\n\nUpdate the transformed vertical momentum with a Runge-Kutta step on the left-hand side of the equation.\n\nThe update is given by\n\nbeginalign*\n    q^rho widehatw_k + 1  2  rightarrow Delta t left- leftG^13 left(frac1J_i + 1  2 left(fracmathcalF^rho u widehatx_i + 1 - mathcalF^rho u widehatxDelta widehatx + fracmathcalF^rho u widehaty_i + 1  2 j + 1  2 - mathcalF^rho u widehaty_i + 1  2 j - 1  2Delta widehatyrightrightrightright\n     qquad qquad qquad qquad qquad qquad + leftleftleftfracmathcalF^rho u widehatz_i + 1  2 k + 1  2 - mathcalF^rho u widehatz_i + 1  2 k - 1  2Delta widehatzright)right)right_k + 1  2\n     qquad qquad - leftG^23 left(frac1J_j + 1  2 left(fracmathcalF^rho v widehatx_i + 1  2 j + 1  2 - mathcalF^rho v widehatx_i - 1  2 j + 1  2Delta widehatx + fracmathcalF^rho v widehaty_j + 1 - mathcalF^rho v widehatyDelta widehatyrightrightright\n     qquad qquad qquad qquad qquad qquad + leftleftleftfracmathcalF^rho v widehatz_j + 1  2 k + 1  2 - mathcalF^rho v widehatz_j + 1  2 k - 1  2Delta widehatzright)right)right_k + 1  2\n     qquad qquad - frac1J_k + 1  2^2 left(fracmathcalF^rho w widehatx_i + 1  2 k + 1  2 - mathcalF^rho w widehatx_i - 1  2 k + 1  2Delta widehatx + fracmathcalF^rho w widehaty_j + 1  2 k + 1  2 - mathcalF^rho w widehaty_j - 1  2 k + 1  2Delta widehatyright\n     qquad qquad qquad qquad quad + leftfracmathcalF^rho w widehatz_k + 1 - mathcalF^rho w widehatzDelta widehatzright)\n     qquad qquad + leftG^13 f left(rho_mathrmold v_mathrmoldright)_k + 1  2 - G^23 f left(rho_mathrmold u_mathrmoldright)_k + 1  2vphantom- frac1J^2 left(fracmathcalF^rho w widehatz_k + 1 - mathcalF^rho w widehatzDelta widehatzright)right + alpha_mathrmRK q^rho widehatw_k + 1  2\n    widehatw_k + 1  2  rightarrow rho_k + 1  2^- 1 left(rho_mathrmold k + 1  2 widehatw_k + 1  2 + beta_mathrmRK q^rho widehatw_k + 1  2right)\nendalign*\n\nwhere rho_mathrmold, u_mathrmold i + 1  2 and v_mathrmold j + 1  2 are the density, zonal wind and meridional wind stored in state.variables.backups.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    side::RHS,\n    integration::Explicit,\n)\n\nUpdate the transformed vertical wind with an explicit Euler step on the right-hand side of the equation, without the Rayleigh-damping term.\n\nThe update is given by\n\nwidehatw_k + 1  2 rightarrow widehatw_k + 1  2 + Delta t left- c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatw + left(fracb_mathrmoldJright)_k + 1  2 + fracF_k + 1  2^rho widehatwrho_k + 1  2right\n\nin Boussinesq/pseudo-incompressible mode and\n\nwidehatW_k + 1  2 rightarrow widehatW_k + 1  2 + Delta t left(J Pright)_k + 1  2 left- c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatw + left(fracb_mathrmoldJright)_k + 1  2 + fracF_k + 1  2^rho widehatwrho_k + 1  2right\n\nin compressible mode, where b_mathrmold = - g rho_mathrmold  rho, with rho_mathrmold being the density fluctuations stored in state.variables.backups.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    side::RHS,\n    integration::Implicit,\n    rayleigh_factor::AbstractFloat,\n)\n\nUpdate the transformed vertical wind with an implicit Euler step on the right-hand side of the equation.\n\nThe update is given by\n\nbeginalign*\n    widehatw_k + 1  2  rightarrow left1 + beta_mathrmR k + 1  2 Delta t + fracoverlinerho_k + 1  2rho_k + 1  2 N^2_k + 1  2 left(Delta tright)^2right^- 1\n     quad times leftwidehatw_k + 1  2 + Delta t left(- c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatw + left(fracbJright)_k + 1  2 + fracF_k + 1  2^rho widehatwrho_k + 1  2right)right\n     qquad quad + leftfracoverlinerho_k + 1  2rho_k + 1  2 N^2_k + 1  2 left(Delta tright)^2 leftleft(G^13 uright)_k + 1  2 + left(G^2 3 vright)_k + 1  2rightvphantomleft(fracF_k + 1  2^rho widehatwrho_k + 1  2right)right\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    widehatW_k + 1  2  rightarrow left1 + beta_mathrmR k + 1  2 Delta t + fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 N^2_k + 1  2 left(Delta tright)^2right^- 1\n     quad times leftwidehatW_k + 1  2 + Delta t left(J Pright)_k + 1  2 left(- c_p fracP_k + 1  2rho_k + 1  2 mathcalP_k + 1  2^rho widehatw + left(fracbJright)_k + 1  2 + fracF_k + 1  2^rho widehatwrho_k + 1  2right)right\n     qquad quad + left(J Pright)_k + 1  2 fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 N^2_k + 1  2 left(Delta tright)^2\n     qquad quad times leftleftleft(G^13 left(fracU_i + 1  2left(J Pright)_i + 1  2right)right)_k + 1  2 + left(G^2 3 left(fracV_j + 1  2left(J Pright)_j + 1  2right)right)_k + 1  2rightvphantomleft(fracF_k + 1  2^rho widehatwrho_k + 1  2right)right\nendalign*\n\nin compressible mode.\n\nupdate!(state::State, dt::AbstractFloat, variable::PiP)\n\nUpdate the Exner-pressure if the atmosphere is compressible by dispatching to the appropriate method.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    variable::PiP,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes.\n\nupdate!(state::State, dt::AbstractFloat, variable::PiP, model::Compressible)\n\nUpdate the Exner-pressure such that it is synchronized with the updated mass-weighted potential temperature.\n\nThe update is given by\n\nbeginalign*\n    pi  rightarrow pi + Delta t left(fracpartial pipartial Pright) left- frac1J left(fracU_mathrmold i + 1  2 - U_mathrmold i - 1  2Delta widehatx + fracV_mathrmold j + 1  2 - V_mathrmold j - 1  2Delta widehatyrightright\n     qquad qquad qquad qquad qquad qquad + leftleftfracwidehatW_mathrmold k + 1  2 - widehatW_mathrmold k - 1  2Delta widehatzright) + F^Pright\nendalign*\n\nwhere U_mathrmold i + 1  2, V_mathrmold j + 1  2 and widehatW_mathrmold k + 1  2 are the transformed wind components (including the factor J P) stored in state.variables.backups.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, variable::P)\n\nUpdate the mass-weighted potential temperature if the atmosphere is compressible by dispatching to the appropriate method.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::P,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes.\n\nupdate!(\n    state::State,\n    dt::AbstractFloat,\n    m::Integer,\n    variable::P,\n    model::Compressible,\n)\n\nUpdate the mass-weighted potential temperature with a Runge-Kutta step on the left-hand side of the equation (the right-hand side is zero).\n\nThe update is given by\n\nbeginalign*\n    q^P  rightarrow Delta t left- frac1J left(fracmathcalF^P widehatx_i + 1  2 - mathcalF^P widehatx_i - 1  2Delta widehatx + fracmathcalF^P widehaty_j + 1  2 - mathcalF^P widehaty_j - 1  2Delta widehaty + fracmathcalF^P widehatz_k + 1  2 - mathcalF^P widehatz_k - 1  2Delta widehatzright) + F^Pright + alpha_mathrmRK q^P\n    P  rightarrow P + beta_mathrmRK q^P\nendalign*\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, tracer_setup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nupdate!(state::State, dt::AbstractFloat, m::Integer, tracer_setup::TracerOn)\n\nUpdate the tracers with a Runge-Kutta step on the left-hand sides of the equations with WKB right-hand side terms according to namelists configuration.\n\nThe update is given by\n\nbeginalign*\n    q^rho chi  rightarrow Delta t left- frac1J left(fracmathcalF^rho chi widehatx_i + 1  2 - mathcalF^rho chi widehatx_i - 1  2Delta widehatx + fracmathcalF^rho chi widehaty_j + 1  2 - mathcalF^rho chi widehaty_j - 1  2Delta widehaty + fracmathcalF^rho chi widehatz_k + 1  2 - mathcalF^rho chi widehatz_k - 1  2Delta widehatzright) + F^rho chiright + alpha_mathrmRK q^rho chi\n    left(rho chiright)  rightarrow left(rho chiright) + beta_mathrmRK q^rho chi\nendalign*\n\nArguments\n\nstate: Model state.\ndt: Time step.\nm: Runge-Kutta-stage index.\nvariable: Variable to update.\nmodel: Dynamic equations.\nside: Side of the equation.\nintegration: Type of the Euler step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\ntracer_setup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.Update.compute_volume_force\nPinCFlow.Update.compute_compressible_wind_factor\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.Update.compute_buoyancy_factor\nPinCFlow.Update.compute_pressure_gradient\nPinCFlow.Update.transform\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"PinCFlow.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact with one of the principal developers first (see Authors).\n\nPinCFlow.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"section"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"The following text was taken from https://developercertificate.org:\n\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"section"},{"location":"reference/boundaries/#Boundaries","page":"Boundaries","title":"Boundaries","text":"","category":"section"},{"location":"reference/boundaries/#PinCFlow.Boundaries","page":"Boundaries","title":"PinCFlow.Boundaries","text":"Boundaries\n\nModule for enforcing boundary conditions for different variable types and field dimensions.\n\nHandles periodic boundaries in the horizontal and solid-wall boundaries in the vertical, as well as MPI communication in all dimensions.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/boundaries/#PinCFlow.Boundaries.AbstractBoundaryVariables","page":"Boundaries","title":"PinCFlow.Boundaries.AbstractBoundaryVariables","text":"AbstractBoundaryVariables\n\nAbstract type for boundary-variable categories.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.AbstractBoundaryWKBVariables","page":"Boundaries","title":"PinCFlow.Boundaries.AbstractBoundaryWKBVariables","text":"AbstractBoundaryWKBVariables <: AbstractBoundaryVariables\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryFluxes","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryFluxes","text":"BoundaryFluxes <: AbstractBoundaryVariables\n\nBoundary-variable category for flux fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryPredictands","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryPredictands","text":"BoundaryPredictands <: AbstractBoundaryVariables\n\nBoundary-variable category for predictand fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryReconstructions","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryReconstructions","text":"BoundaryReconstructions <: AbstractBoundaryVariables\n\nBoundary-variable category for reconstruction fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryWKBIntegrals","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryWKBIntegrals","text":"BoundaryWKBIntegrals <: AbstractBoundaryWKBVariables\n\nBoundary-variable category for gravity-wave-integral fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.BoundaryWKBTendencies","page":"Boundaries","title":"PinCFlow.Boundaries.BoundaryWKBTendencies","text":"BoundaryWKBTendencies <: AbstractBoundaryVariables\n\nBoundary-variable category for gravity-wave-tendency fields.\n\n\n\n\n\n","category":"type"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_boundaries!","text":"set_boundaries!(\n    state::State,\n    variables::Union{\n        BoundaryPredictands,\n        BoundaryReconstructions,\n        AbstractBoundaryWKBVariables,\n    },\n)\n\nEnforce all boundary conditions for non-flux fields.\n\nset_boundaries!(state::State, variables::BoundaryFluxes)\n\nEnforce vertical boundary conditions for flux fields (horizontal boundaries are taken care of at the reconstruction stage).\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries!\nPinCFlow.Boundaries.set_meridional_boundaries!\nPinCFlow.Boundaries.set_vertical_boundaries!\nPinCFlow.Boundaries.set_tracer_zonal_boundaries!\nPinCFlow.Boundaries.set_tracer_meridional_boundaries!\nPinCFlow.Boundaries.set_tracer_vertical_boundaries!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_meridional_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_meridional_boundaries!","text":"set_meridional_boundaries!(\n    state::State,\n    variables::Union{BoundaryPredictands, BoundaryReconstructions},\n)\n\nEnforce meridional boundary conditions for predictands or reconstructions by dispatching to the appropriate method.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Boussinesq,\n)\n\nEnforce meridional boundary conditions for predictands in Boussinesq mode.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::PseudoIncompressible,\n)\n\nEnforce meridional boundary conditions for predictands in pseudo-incompressible mode.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Compressible,\n)\n\nEnforce meridional boundary conditions for predictands in compressible mode.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Boussinesq,\n)\n\nEnforce meridional boundary conditions for reconstructions in Boussinesq mode.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nEnforce meridional boundary conditions for reconstructions in non-Boussinesq modes.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::AbstractBoundaryWKBVariables,\n)\n\nEnforce meridional boundary conditions for WKB variables by dispatching to the appropriate method.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce meridional boundary conditions for WKB integrals needed in SingleColumn and SteadyState configurations.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce meridional boundary conditions for WKB integrals needed in MultiColumn configurations.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce meridional boundary conditions for WKB tendencies needed in SingleColumn and SteadyState configurations.\n\nset_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce meridional boundary conditions for WKB tendencies needed in MultiColumn configurations.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_meridional_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_meridional_boundaries_of_field!","text":"set_meridional_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce meridional boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npy > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_meridional_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_meridional_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_meridional_boundaries!","text":"set_tracer_meridional_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n)\n\nEnforce meridional boundary conditions for tracers by dispatching to the appropriate method.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n    tracer_setup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracer_setup::TracerOn,\n)\n\nEnforce meridional boundary conditions for tracer predictands.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracer_setup::TracerOn,\n)\n\nEnforce meridional boundary conditions for tracer reconstructions.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::AbstractBoundaryWKBVariables,\n    tracer_setup::TracerOn,\n)\n\nEnforce meridional boundary conditions for tracer WKB quantities by dispatching to the appropriate method.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce meridional boundary conditions for tracer WKB integrals.\n\nset_tracer_meridional_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce meridional boundary conditions for tracer WKB tendencies.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracer_setup: General tracer-transport configuration.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_vertical_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_vertical_boundaries!","text":"set_tracer_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n)\n\nEnforce vertical boundary conditions for tracers by dispatching to the appropriate method.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n    tracer_setup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracer_setup::TracerOn,\n)\n\nEnforce vertical boundary conditions for tracer predictands.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracer_setup::TracerOn,\n)\n\nEnforce vertical boundary conditions for tracer reconstructions.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    tracer_setup::TracerOn,\n)\n\nEnforce vertical boundary conditions for vertical tracer fluxes.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::AbstractBoundaryWKBVariables,\n    tracer_setup::TracerOn,\n)\n\nEnforce vertical boundary conditions for tracer WKB quantities by dispatching to the appropriate method.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce vertical boundary conditions for tracer WKB integrals.\n\nset_tracer_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce vertical boundary conditions for tracer WKB tendencies.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracer_setup: General tracer-transport configuration.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_tracer_zonal_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_tracer_zonal_boundaries!","text":"set_tracer_zonal_boundaries!(state::State, variables::AbstractBoundaryVariables)\n\nEnforce zonal boundary conditions for tracers by dispatching to the appropriate method.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::AbstractBoundaryVariables,\n    tracer_setup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    tracer_setup::TracerOn,\n)\n\nEnforce zonal boundary conditions for tracer predictands.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    tracer_setup::TracerOn,\n)\n\nEnforce zonal boundary conditions for tracer reconstructions.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::AbstractBoundaryWKBVariables,\n    tracer_setup::TracerOn,\n)\n\nEnforce zonal boundary conditions for tracer WKB quantities by dispatching to the appropriate method.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce zonal boundary conditions for tracer WKB integrals.\n\nset_tracer_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nEnforce zonal boundary conditions for tracer WKB tendencies.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\ntracer_setup: General tracer-transport configuration.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_vertical_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_vertical_boundaries!","text":"set_vertical_boundaries!(\n    state::State,\n    variables::Union{\n        BoundaryPredictands,\n        BoundaryReconstructions,\n        BoundaryFluxes,\n    },\n)\n\nEnforce vertical boundary conditions for predictands, reconstructions or fluxes, by dispatching to the appropriate method.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Boussinesq,\n)\n\nEnforce vertical boundary conditions for predictands in Boussinesq mode.\n\nThe symmetry conditions are as follows:\n\nDensity fluctuations (rhop): point reflection (-)\nVertical velocity (w): point reflection (-) on the staggered grid\nHorizontal velocities (u, v): line reflection (+)\nExner-pressure fluctuations (pip): line reflection (+)\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::PseudoIncompressible,\n)\n\nEnforce vertical boundary conditions for predictands in pseudo-incompressible mode.\n\nIn contrast to Boussinesq mode, this includes the density (rho). Since it is offset by the background, it is point-reflected, like the density fluctuations.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Compressible,\n)\n\nEnforce vertical boundary conditions for predictands in compressible mode.\n\nIn contrast to pseudo-incompressible modes, this includes the mass-weighted potential temperature (p), which is line-reflected.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Boussinesq,\n)\n\nEnforce vertical boundary conditions for reconstructions in Boussinesq mode.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nEnforce vertical boundary conditions for reconstructions in non-Boussinesq modes.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    model::Boussinesq,\n)\n\nEnforce vertical boundary conditions for vertical fluxes in Boussinesq mode.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    model::PseudoIncompressible,\n)\n\nEnforce vertical boundary conditions for vertical fluxes in pseudo-incompressible mode.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryFluxes,\n    model::Compressible,\n)\n\nEnforce vertical boundary conditions for vertical fluxes in compressible mode.\n\nset_vertical_boundaries!(state::State, variables::AbstractBoundaryWKBVariables)\n\nEnforce vertical boundary conditions for WKB variables by dispatching to the appropriate method.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce vertical boundary conditions for WKB integrals needed in SingleColumn and SteadyState configurations, using line reflection.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce vertical boundary conditions for WKB integrals needed in MultiColumn configurations, using line reflection.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce vertical boundary conditions for WKB tendencies needed in SingleColumn and SteadyState configurations, using line reflection.\n\nset_vertical_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce vertical boundary conditions for WKB tendencies needed in MultiColumn configurations, using line reflection.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_vertical_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_vertical_boundaries_of_field!","text":"set_vertical_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain,\n    mode::Function;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n    staggered = false,\n)\n\nEnforce vertical boundary conditions for a 3D array (assuming solid-wall boundaries).\n\nHalo exchange is used for multi-process domains (npz > 1). Use mode = + (mode = -) for line-reflected (point-reflected) ghost-cell values.\n\nset_vertical_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange halo values of a 5D array if multiple processes are used in the vertical (npz > 1).\n\nThis method is applied to reconstruction arrays. Vertical boundary conditions are not enforced for these but for the fluxes determined from them.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmode: Method used for setting the boundary-cell values.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\nstaggered: A switch for whether or not the field is on the staggered vertical grid.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_zonal_boundaries!","page":"Boundaries","title":"PinCFlow.Boundaries.set_zonal_boundaries!","text":"set_zonal_boundaries!(\n    state::State,\n    variables::Union{BoundaryPredictands, BoundaryReconstructions},\n)\n\nEnforce zonal boundary conditions for predictands or reconstructions by dispatching to the appropriate method.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Boussinesq,\n)\n\nEnforce zonal boundary conditions for predictands in Boussinesq mode.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::PseudoIncompressible,\n)\n\nEnforce zonal boundary conditions for predictands in pseudo-incompressible mode.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryPredictands,\n    model::Compressible,\n)\n\nEnforce zonal boundary conditions for predictands in compressible mode.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Boussinesq,\n)\n\nEnforce zonal boundary conditions for reconstructionss in Boussinesq mode.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryReconstructions,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nEnforce zonal boundary conditions for reconstructions in non-Boussinesq modes.\n\nset_zonal_boundaries!(state::State, variables::AbstractBoundaryWKBVariables)\n\nEnforce zonal boundary conditions for WKB variables by dispatching to the appropriate method.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce zonal boundary conditions for WKB integrals needed in SingleColumn and SteadyState configurations.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBIntegrals,\n    wkb_mode::MultiColumn,\n)\n\nEnforce zonal boundary conditions for WKB integrals needed in MultiColumn configurations.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::Union{SteadyState, SingleColumn},\n)\n\nEnforce zonal boundary conditions for WKB tendencies needed in SingleColumn and SteadyState configurations.\n\nset_zonal_boundaries!(\n    state::State,\n    variables::BoundaryWKBTendencies,\n    wkb_mode::MultiColumn,\n)\n\nEnforce zonal boundary conditions for WKB tendencies needed in MultiColumn configurations.\n\nArguments\n\nstate: Model state.\nvariables: Boundary-variable category.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/boundaries/#PinCFlow.Boundaries.set_zonal_boundaries_of_field!","page":"Boundaries","title":"PinCFlow.Boundaries.set_zonal_boundaries_of_field!","text":"set_zonal_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce zonal boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npx > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_zonal_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#MPIOperations","page":"MPIOperations","title":"MPIOperations","text":"","category":"section"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations","page":"MPIOperations","title":"PinCFlow.MPIOperations","text":"MPIOperations\n\nModule for operations that require communication between MPI processes.\n\nProvides halo exchange functions for maintaining field continuity across process boundaries, as well as global reduction operations.\n\nSee also\n\nPinCFlow.Types\n\n\n\n\n\n","category":"module"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.compute_global_dot_product","page":"MPIOperations","title":"PinCFlow.MPIOperations.compute_global_dot_product","text":"compute_global_dot_product(\n    a::AbstractArray{<:AbstractFloat, 3},\n    b::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n)::AbstractFloat\n\nCompute and return the dot product boldsymbola cdot boldsymbolb = sum_i a_i cdot b_i of two 3D arrays distributed across MPI processes.\n\nArguments\n\na: First input array.\nb: Second input array (must have the same shape as a).\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_meridional_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_meridional_halos_of_field!","text":"set_meridional_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all meridional halo values of a matrix by performing bidirectional MPI communication between backward and forward neighbor processes.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_vertical_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_vertical_halos_of_field!","text":"set_vertical_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 3D array by performing MPI communication between downward and upward neighbor processes.\n\nSolid walls are assumed at the vertical boundaries of the domain. The corresponding ghost-cell values are not changed.\n\nset_vertical_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 5D array with an algorithm similar to that implemented in the above method.\n\nThe vertical domain boundaries are treated as described above. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/mpi_operations/#PinCFlow.MPIOperations.set_zonal_halos_of_field!","page":"MPIOperations","title":"PinCFlow.MPIOperations.set_zonal_halos_of_field!","text":"set_zonal_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all zonal halo values of a matrix by performing bidirectional MPI communication between left and right neighbor processes.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PoissonSolver","page":"PoissonSolver","title":"PoissonSolver","text":"","category":"section"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver","page":"PoissonSolver","title":"PinCFlow.PoissonSolver","text":"PoissonSolver\n\nModule for solving the Poisson equation and performing a corrector step.\n\nProvides the functions needed to solve the Poisson equation of the semi-implicit time scheme, using a preconditioned BiCGSTAB algorithm, and correcting the Exner-pressure, momentum and density fluctuations accordingly.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\nPinCFlow.Boundaries\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.Horizontal","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.Horizontal","text":"Horizontal\n\nSingleton for dispatch to application of the horizontal part of the linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.Total","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.Total","text":"Total\n\nSingleton for dispatch to application of the full linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_bicgstab!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_bicgstab!","text":"apply_bicgstab!(state::State, tolref::AbstractFloat)::Tuple{Bool, <:Integer}\n\nSolve the Poisson equation using a preconditioned BiCGSTAB algorithm and return a tuple containing an error flag and the number of iterations.\n\nArguments\n\nstate: Model state.\ntolref: Reference tolerance for convergence criterion.\n\nSee also\n\nPinCFlow.PoissonSolver.apply_operator!\nPinCFlow.PoissonSolver.apply_preconditioner!\nPinCFlow.MPIOperations.compute_global_dot_product\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_corrector!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_corrector!","text":"apply_corrector!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n)::Tuple{Bool, <:Integer}\n\nPerform the corrector step and return a tuple containing an error flag and the number of BiCGSTAB iterations.\n\nThe left-hand side and the linear operator of the discrete Poisson equation are calculated. The equation is then solved for Exner-pressure differences, using a preconditioned BiCGSTAB algorithm. Finally, the Exner-pressure, wind and density fluctuations are corrected accordingly.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.PoissonSolver.compute_lhs!\nPinCFlow.PoissonSolver.solve_poisson!\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.Boundaries.set_vertical_boundaries_of_field!\nPinCFlow.PoissonSolver.correct!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_operator!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_operator!","text":"apply_operator!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    ls::AbstractArray{<:AbstractFloat, 3},\n    hortot::Total,\n    state::State,\n)\n\nApply the total linear operator to the solution array sin.\n\nBefore the operator is applied, the boundary/halo values of sin are set, using set_zonal_boundaries_of_field!, set_meridional_boundaries_of_field! and set_vertical_halos_of_field!. Note that in the vertical, only halo values need to be set (if the domain is parallelized in that direction), due to the solid-wall boundaries.\n\napply_operator!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    ls::AbstractArray{<:AbstractFloat, 3},\n    hortot::Horizontal,\n    state::State,\n)\n\nApply the \"horizontal part\" of the linear operator (excluding the lower, center and upper diagonal) to the solution array sin.\n\nBefore the operator is applied, the boundary/halo values of sin are set, in the same way as in the method applying the total operator.\n\nArguments\n\nsin: Solution array.\nls: Result of applying the operator to the solution array.\nhortot: Linear-operator mode.\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.apply_preconditioner!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.apply_preconditioner!","text":"apply_preconditioner!(\n    sin::AbstractArray{<:AbstractFloat, 3},\n    sout::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n)\n\nApply a preconditioner to the Poisson problem.\n\nThis preconditioner integrates the auxiliary equation\n\nfracmathrmd smathrmd eta = mathcalL_mathrmh left(sright) + mathcalL_mathrmv left(sright) - b\n\nwhere s is the iterative solution, eta is a pseudo-time variable, mathcalL_mathrmv contains the lower, center and upper diagonals of the linear operator, mathcalL_mathrmh contains all remaining elements, and b is the left-hand side. The integration is performed in a semi-implicit manner, following\n\nleft(1 - Delta eta mathcalL_mathrmvright) left(s^left(m + 1right)right) = left(1 + Delta eta mathcalL_mathrmhright) left(s^left(mright)right) - Delta eta b\n\nwhere Delta eta = Delta tau  2 leftleft(Delta widehatxright)^- 2 + left(Delta widehatyright)^- 2right^- 1, with Delta tau being a namelist parameter (state.namelist.poisson.dtau). Therein, the implicit problem is solved with the Thomas algorithm for tridiagonal matrices. The number of iterations is given by state.namelist.poisson.preconditioner_iterations. Since the Thomas algorithm consists of an upward elimination sweep and a downward pass, this method performs sequential one-way MPI communication if the domain is parallelized in the vertical.\n\nArguments\n\nsin: Residual array.\nsout: Solution of the preconditioner.\nstate: Model state.\n\nSee also\n\nPinCFlow.PoissonSolver.apply_operator!\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.compute_lhs!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.compute_lhs!","text":"compute_lhs!(state::State)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation and return a reference tolerance for the convergence criterion by dispatching to a model-specific method.\n\ncompute_lhs!(\n    state::State,\n    model::Union{Boussinesq, PseudoIncompressible},\n)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation in pseudo-incompressible/Boussinesq mode and return a reference tolerance for the convergence criterion.\n\nThe scaled left-hand side is given by\n\nbeginalign*\n    b  = fracsqrtoverlinerhoP frac1J c_p leftfrac1Delta widehatx leftleft(J Pright)_i + 1  2 u_i + 1  2 - left(J Pright)_i - 1  2 u_i - 1  2rightright\n     qquad qquad quad + frac1Delta widehaty leftleft(J Pright)_j + 1  2 v_j + 1  2 - left(J Pright)_j - 1  2 v_j - 1  2right\n     qquad qquad quad + leftfrac1Delta widehatz leftleft(J Pright)_k + 1  2 widehatw_k + 1  2 - left(J Pright)_k - 1  2 widehatw_k - 1  2rightright\nendalign*\n\nand the reference tolerance is given by\n\ntau_mathrmref = fracsum_i j k b_i j k^2sum_i j k left(b_u i j k^2 + b_v i j k^2 + b_widehatw i j k^2right)\n\nwhere b_u, b_v and b_widehatw are the zonal, meridional and vertical parts of b, respectively. Note that in Boussinesq mode, P = P_0 will cancel out, so that the appropriate divergence constraint remains.\n\ncompute_lhs!(state::State, model::Compressible)::AbstractFloat\n\nCompute the scaled left-hand side of the Poisson equation in compressible mode and return a reference tolerance for the convergence criterion.\n\nThe scaled left-hand side is given by\n\nbeginalign*\n    b  = fracsqrtoverlinerhoP frac1J c_p left(fracU_i + 1  2 - U_i - 1  2Delta widehatx + fracV_j + 1  2 - V_j - 1  2Delta widehaty + fracwidehatW_k + 1  2 - widehatW_k - 1  2Delta widehatzright) - fracsqrtoverlinerhoP F^P\nendalign*\n\nwhere F^P is the diabatic heating, as computed by compute_volume_force, and the reference tolerance is computed in the same way as in the method for pseudo-incompressible/Boussinesq mode, with b_F i j k^2 added to the sum in the denominator, representing the heating term.\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\nSee also\n\nPinCFlow.Update.compute_volume_force\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.compute_operator!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.compute_operator!","text":"compute_operator!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n)\n\nCompute the tensor elements of the linear operator on the right-hand side of the Poisson equation.\n\nThe operator is obtained by rewriting the scaled Poisson equation\n\nfracsqrtoverlinerhoP mathrmLHS = fracsqrtoverlinerhoP mathrmRHS left(fracsqrtoverlinerhoP sright)\n\nas\n\nfracsqrtoverlinerhoP mathrmLHS = sum_lambda mu nu A_i + lambda j + mu k + nu s_i + lambda j + mu k + nu\n\nwhere the Exner-pressure differences are given by Delta pi = left(sqrtoverlinerho  Pright) left(s  Delta tright).\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.Update.compute_buoyancy_factor\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.correct!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.correct!","text":"correct!(state::State, dt::AbstractFloat, rayleigh_factor::AbstractFloat)\n\nCorrect the Exner-pressure, wind and density fluctuations such that the divergence constraint is satisfied, using the Exner-pressure differences obtained from the solution to the Poisson problem.\n\nThis method calls specific methods for the correction of each individual variable.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::U,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the zonal wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nu_i + 1  2 rightarrow u_i + 1  2 - mathcalC_i + 1  2^rho u\n\nin Boussinesq/pseudo-incompressible mode and\n\nU_i + 1  2 rightarrow U_i + 1  2 - left(J Pright)_i + 1  2 mathcalC_i + 1  2^rho u\n\nin compressible mode, with\n\nmathcalC_i + 1  2^rho u = left(1 + beta_mathrmR i + 1  2 Delta tright)^- 1 Delta t c_p fracP_i + 1  2rho_i + 1  2 mathcalD_i + 1  2^rho u\n\nTherein, Delta t is the fractional time step given as input to this method and c_p left(P_i + 1  2  rho_i + 1  2right) mathcalD_i + 1  2^rho u is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::V,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the meridional wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nv_j + 1  2 rightarrow v_j + 1  2 - mathcalC_j + 1  2^rho v\n\nin Boussinesq/pseudo-incompressible mode and\n\nV_j + 1  2 rightarrow V_j + 1  2 - left(J Pright)_j + 1  2 mathcalC_j + 1  2^rho v\n\nin compressible mode, with\n\nmathcalC_j + 1  2^rho v = left(1 + beta_mathrmR j + 1  2 Delta tright)^- 1 Delta t c_p fracP_j + 1  2rho_j + 1  2 mathcalD_j + 1  2^rho v\n\nwhere c_p left(P_j + 1  2  rho_j + 1  2right) mathcalD_j + 1  2^rho v is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::W,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the transformed vertical wind to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nbeginalign*\n    widehatw_k + 1  2  rightarrow widehatw_k + 1  2 - left1 + beta_mathrmR k + 1  2 Delta t + fracoverlinerho_k + 1  2rho_k + 1  2 N_k + 1  2^2 left(Delta tright)^2right^- 1\n     quad times leftDelta t c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^rho widehatw + fracoverlinerho_k + 1  2rho_k + 1  2 N_k + 1  2^2 left(Delta tright)^2right\n     qquad quad times leftleftleft(G^1 3 mathcalC^rho uright)_k + 1  2 + left(G^23 mathcalC^rho vright)_k + 1  2rightvphantomfracP_k + 1  2rho_k + 1  2right\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    widehatW_k + 1  2  rightarrow widehatW_k + 1  2 - left1 + beta_mathrmR k + 1  2 Delta t + fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 N_k + 1  2^2 left(Delta tright)^2right^- 1\n     quad times leftDelta t c_p left(J Pright)_k + 1  2 fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^rho widehatw vphantomfracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 + left(J Pright)_k + 1  2 fracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2 N_k + 1  2^2 left(Delta tright)^2right\n     qquad quad times leftleftleft(G^1 3 mathcalC^rho uright)_k + 1  2 + left(G^23 mathcalC^rho vright)_k + 1  2rightvphantomfracleft(P  overlinethetaright)_k + 1  2rho_k + 1  2right\nendalign*\n\nin compressible mode, where c_p left(P_k + 1  2  rho_k + 1  2right) mathcalD_k + 1  2^rho widehatw is computed with compute_pressure_gradient.\n\ncorrect!(\n    state::State,\n    dt::AbstractFloat,\n    variable::RhoP,\n    rayleigh_factor::AbstractFloat,\n)\n\nCorrect the density fluctuations to account for the pressure differences obtained from the solution to the Poisson problem.\n\nThe correction is given by\n\nbeginalign*\n    rho  rightarrow rho + fracrhog left1 + beta_mathrmR Delta t + fracoverlinerhorho left(N Delta tright)^2right^- 1\n     quad times left- fracoverlinerhorho left(N Delta tright)^2 J left(c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^rho widehatwright)right\n     qquad quad + leftfracoverlinerhorho N^2 Delta t J left(1 + beta_mathrmR Delta tright) left(G^1 3 mathcalC^rho u + G^2 3 mathcalC^rho vright)right\nendalign*\n\nin Boussinesq/pseudo-incompressible mode and\n\nbeginalign*\n    rho  rightarrow rho + fracrhog left1 + beta_mathrmR Delta t + fracP  overlinethetarho left(N Delta tright)^2right^- 1\n     quad times left- fracP  overlinethetarho left(N Delta tright)^2 J left(c_p fracP_k + 1  2rho_k + 1  2 mathcalD_k + 1  2^rho widehatwright)right\n     qquad quad + leftfracP  overlinethetarho N^2 Delta t J left(1 + beta_mathrmR Delta tright) left(G^1 3 mathcalC^rho u + G^2 3 mathcalC^rho vright)right\nendalign*\n\nin compressible mode, where c_p left(P_k + 1  2  rho_k + 1  2right) mathcalD_k + 1  2^rho widehatw and c_p left(P_k - 1  2  rho_k - 1  2right) mathcalD_k - 1  2^rho widehatw are computed with compute_pressure_gradient, and used to interpolate to left(i j kright).\n\ncorrect!(state::State, variable::PiP)\n\nUpdate the Exner-pressure fluctuations with the differences obtained from the solution to the Poisson problem.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nvariable: Variable to correct.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\n\nSee also\n\nPinCFlow.Update.compute_pressure_gradient\nPinCFlow.Update.compute_compressible_wind_factor\nPinCFlow.Update.compute_buoyancy_factor\n\n\n\n\n\n","category":"function"},{"location":"reference/poisson_solver/#PinCFlow.PoissonSolver.solve_poisson!","page":"PoissonSolver","title":"PinCFlow.PoissonSolver.solve_poisson!","text":"solve_poisson!(\n    state::State,\n    dt::AbstractFloat,\n    rayleigh_factor::AbstractFloat,\n    tolref::AbstractFloat,\n)::Tuple{Bool, <:Integer}\n\nSolve the Poisson equation and return a tuple containing an error flag and the number of iterations.\n\nGiven a left-hand side and reference tolerance, this method computes the elements of the linear operator and solves the Poisson equation, using a preconditioned BiCGSTAB algorithm. Both the Exner-pressure differences and the entire equation are scaled with sqrtoverlinerho  P in advance (the left-hand side has already been scaled at this point), so that the equation\n\nfracsqrtoverlinerhoP mathrmLHS = fracsqrtoverlinerhoP mathrmRHS left(fracsqrtoverlinerhoP sright)\n\nis solved for s. The Exner-pressure differences are then given by Delta pi = left(sqrtoverlinerho  Pright) left(s  Delta tright).\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\ntolref: Reference tolerance for convergence criterion.\n\nSee also\n\nPinCFlow.PoissonSolver.compute_operator!\nPinCFlow.PoissonSolver.apply_bicgstab!\n\n\n\n\n\n","category":"function"},{"location":"code_of_conduct/#Code-of-Conduct","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Ulrich Achatz, Stamen Dolaptchiev, or any other of the principal developers responsible for enforcement listed in Authors. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","category":"section"},{"location":"reference/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"reference/output/#PinCFlow.Output","page":"Output","title":"PinCFlow.Output","text":"Output\n\nModule for I/O of simulation data.\n\nProvides functions for writing the model state and initializing the model with data from a previous simulation.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/output/#PinCFlow.Output.create_output","page":"Output","title":"PinCFlow.Output.create_output","text":"create_output(state::State)\n\nCreate an HDF5 output file with one dataset for each variable.\n\nThe dimensions of the datasets are set to those of the domain, whereas the chunks are set to the dimensions of the MPI subdomains, in preparation for parallel output. Datasets for the grid, i.e. the fields x, y and zc of state.grid, the time and the fields of state.atmosphere are always created, regardless of the specifications in state.namelists.output. The one exception to this is the Boussinesq mode, in which no datasets are created for the fields of state.atmosphere, since they do not have a spatial dependence.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/output/#PinCFlow.Output.read_input!","page":"Output","title":"PinCFlow.Output.read_input!","text":"read_input!(state::State)\n\nRead initial values for all prognostic variables from an HDF5 input file.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/output/#PinCFlow.Output.write_output","page":"Output","title":"PinCFlow.Output.write_output","text":"write_output(\n    state::State,\n    time::AbstractFloat,\n    iout::Integer,\n    machine_start_time::DateTime,\n)::Integer\n\nWrite the current simulation state to a previously created HDF5 output file and return the advanced output counter iout.\n\nThe output is written in parallel, using the chunking prepared by create_output. The grid, i.e. the fields x, y and zc of state.grid, as well as the fields of state.atmosphere are only written if iout == 1 (which should only be the case for the initial output). In Boussinesq mode, the fields of state.atmosphere do not have a spatial dependence and are therefore not written at all. In compressible mode, the mass-weighted potential temperature and squared buoyancy frequency have a temporal dependence and are therefore written even if iout != 1. Any other field is only written if it is listed in state.namelists.output.output_variables or if it is essential for restarts and state.namelists.output.prepare_restart == true.\n\nThe list of available output variables (as specified in state.namelists.output.output_variables) is as follows.\n\n:rhop: Density fluctuations (restart variable).\n:u: Zonal wind.\n:us: Staggered zonal wind (restart variable).\n:v: Meridional wind.\n:vs: Staggered meridional wind (restart variable).\n:w: Vertical wind (computed with compute_vertical_wind).\n:ws: Staggered vertical wind (computed with compute_vertical_wind).\n:wt: Transformed vertical wind.\n:wts: Staggered transformed vertical wind (restart variable).\n:thetap: Potential-temperature fluctuations.\n:pip: Exner-pressure fluctuations (restart variable).\n:dudt: Zonal-momentum drag due to unresolved gravity waves.\n:dvdt: Meridional-momentum drag due to unresolved gravity waves.\n:dthetadt: Mass-weighted potential-temperature tendency due to unresolved gravity waves.\n:dchidt: Leading-order tracer impact of unresolved gravity waves.\n:uchi: Zonal tracer fluxes due to unresolved gravity waves.\n:vchi: Meridional tracer fluxes due to unresolved gravity waves.\n:wchi: Vertical tracer fluxes due to unresolved gravity waves.\n\nAn output of all ray-volume properties is provided if state.namelists.output.save_ray_volumes == true and/or state.namelists.output.prepare_restart == true.\n\nAll output variables are re-dimensionalized with the scale parameters stored in state.constants.\n\nArguments\n\nstate: Model state.\ntime: Simulation time.\niout: Output counter. This is the temporal index of the output. It is advanced before the output is written, so that the first call of write_output should receive iout = 0.\nmachine_start_time: Wall-clock start time.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"PinCFlow.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"section"},{"location":"changelog/#Release-1.1.1","page":"Changelog","title":"Release 1.1.1","text":"A bug has been fixed where uold was not being assigned correctly in update.","category":"section"},{"location":"changelog/#Release-1.1.0","page":"Changelog","title":"Release 1.1.0","text":"Potential-temperature fluxes due to heat conduction are no longer computed in pseudo-incompressible or Boussinesq mode.\nTwo bugs that prevented MS-GWaM from being run in SingleColumn or SteadyState mode have been fixed.\nA bug that prevented the helper function replace_assignments (used in the tests) from properly overwriting variables with strings has been fixed. This function now also issues a warning if an assignment wasn't found.\nThe writing of attributes to the model output file has been serialized. This fixes a bug that led to occasional HDF5 errors in parallel simulations.\nA bug has been fixed in the averaging of orographic wavenumbers in apply_blocked_layer_scheme!.\nThe developer guide has been extended with information on running and updating tests, and instructions for creating new releases.\nThe behavior of the default value of the output-namelist parameter iin has been changed, so that it no longer results in an error but in the selection of the last record in the input file.\nSeveral bugs have been fixed in the scripts for the wave-packet examples.\nA record of the configured namelists is now included in the model output.","category":"section"},{"location":"changelog/#Release-1.0.0","page":"Changelog","title":"Release 1.0.0","text":"The documentation has been updated, corrected and improved.\nThe density reconstructions and fluxes have been removed in Boussinesq mode.\nThe sponges are now configured with functions.\nThe following sponge-namelist parameters have been removed.\nsponge_extent\nalpharmax\nbetarmax\nlateral_sponge\nsponge_type\nsponge_order\ncosmo_steps\nperturbation_period\nperturbation_amplitude\nrelaxation wind\nThe following sponge-namelist parameters have been added.\nlhs_sponge\nrhs_sponge\nrelaxed_u\nrelaxed_v\nrelaxed_w\nEach of these must be a function that takes the three spatial coordinates, the time and the time step as arguments and returns a single value. The functions lhs_sponge and rhs_sponge are used to compute the respective Rayleigh-damping coefficients, whereas the other three functions define the wind obtained through the relaxation enforced by the LHS sponge (if the parameter relax_to_mean is set to false).\nThe internal horizontal-coordinate arrays have been parallelized, making the model slightly more efficient.\nA bug has been fixed in the construction of the Realistic atmospheric background.\nA bug has been fixed in the re-dimensionalization of the GW tracer fluxes and tracer flux convergence.\nMetadata has been added to the output, including long variable names, dimensions and labels in LaTeX format.\nA bug has been fixed in the computation of the ray-volume-array size (this only had an impact in configurations with wave_modes > 1).\nType constraints for structure fields have been improved. Namelist parameters that previously had to be of a subtype of AbstractFloat now need to be of a subtype of Real.\nThe following atmospheric backgrounds (only available in Boussinesq mode) have been renamed.\nUniformBoussinesq rightarrow NeutralStratification\nStratifiedBoussinesq rightarrow StableStratification\nThe function check_rays no longer triggers exit() calls but instead raises errors. The error messages now provide more details.\nFixed a bug that resulted in an incorrect initialization of nonzero density fluctuations in Boussinesq mode.\nFixed a bug in the initialization of the mass-weighted potential temperature in compressible mode. This only had an impact when the model was initialized with nonzero density or potential-temperature fluctuations.\nThe following atmosphere-namelist parameters have been removed.\ninitial_thetap\nThe initial potential-temperature fluctuations are now always such that P = overlinerho overlinetheta.\nThe visualization function plot_contours of PinCFlow.jl's CairoMakie extension has been replaced with the function plot_output, with the following changes.\nIt has a simplified call signature.\nIt can also visualize ray volumes.\nA bug has been fixed in the setting of colorbar-tick labels.\nThe space and time units are configurable.\nMultiple variables can be visualized in one figure.\nThe colorbar labels are set automatically.\nThe background color of plots in x-z or y-z plane is black.\nThe following new examples have been added.\nA 2D cold bubble\nA 2D hot bubble\nA 2D vortex\nA 3D wave packet\nA 3D WKB wave packet\nThe existing examples have been modified slightly. The run and visualization scripts have been merged.\nThe default values of the domain-namelist parameters x_size, y_size and z_size have been changed to 1.","category":"section"},{"location":"changelog/#Release-0.1.0","page":"Changelog","title":"Release 0.1.0","text":"First public release of PinCFlow.jl.","category":"section"},{"location":"authors/#Authors","page":"Authors","title":"Authors","text":"PinCFlow.jl's development is coordinated by a group of principal developers, who are also its main contributors and who can be contacted in case of questions about PinCFlow. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form \"The PinCFlow.jl Authors\" as mentioned under License.","category":"section"},{"location":"authors/#Principal-Developers","page":"Authors","title":"Principal Developers","text":"Ulrich Achatz, Goethe University Frankfurt\nStamen Dolaptchiev, Goethe University Frankfurt\nFelix Jochum, Goethe University Frankfurt\nIrmgard Knop, Goethe University Frankfurt","category":"section"},{"location":"authors/#Contributors","page":"Authors","title":"Contributors","text":"The following people contributed major additions or modifications to PinCFlow.jl and are listed in alphabetical order:\n\nUlrich Achatz\nMarco Artiano\nArpit Babbar\nGergely B&ouml;l&ouml;ni\nStamen Dolaptchiev\nNiklas Ehlert\nFelix Jochum\nYoung-Ha Kim\nSandra Klewinghaus\nIrmgard Knop\nHendrik Ranocha\nJonas Rothermel\nFelix Rieper\nFabienne Schmid\nGeorg Sebastian Voelker\nJunhong Wei\nJan Weinkaemmerer\nJannik Wilhelm","category":"section"},{"location":"reference/flux_calculator/#FluxCalculator","page":"FluxCalculator","title":"FluxCalculator","text":"","category":"section"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator","page":"FluxCalculator","title":"PinCFlow.FluxCalculator","text":"FluxCalculator\n\nModule for flux calculation.\n\nProvides functions for MUSCL reconstruction and flux computation.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.apply_1d_muscl!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.apply_1d_muscl!","text":"apply_1d_muscl!(\n    phi::AbstractVector{<:AbstractFloat},\n    phitilde::AbstractMatrix{<:AbstractFloat},\n    phisize::Integer,\n    limiter_type::MCVariant,\n)\n\nApply the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) for reconstruction in one dimension.\n\nThe reconstruction to the left is given by\n\nwidetildephi^mathrmL = begincases\n    phi  mathrmif quad phi = phi_i - 1 quad mathrmor quad phi = phi_i + 1\n    phi - frac12 eta left(fracphi_i + 1 - phiphi - phi_i - 1right) left(phi - phi_i - 1right)  mathrmelse\nendcases\n\nand that to the right is given by\n\nwidetildephi^mathrmR = begincases\n    phi  mathrmif quad phi = phi_i - 1 quad mathrmor quad phi = phi_i + 1\n    phi + frac12 eta left(fracphi - phi_i - 1phi_i + 1 - phiright) left(phi_i + 1 - phiright)  mathrmelse\nendcases\n\nwhere\n\neta left(xiright) = max left0 min left(2 xi frac2 + xi3 2right)right\n\nis the monotonized-centered variant limiter.\n\nArguments\n\nphi: Input vector.\nphitilde: Output matrix with reconstructed values. The two columns of phitilde contain the reconstructions to the left and right. No reconstruction is computed for the first and last row of phitilde.\nphisize: Length of the input vector phi.\nlimiter_type: Type of flux limiter to use.\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.apply_3d_muscl!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.apply_3d_muscl!","text":"apply_3d_muscl!(\n    phi::AbstractArray{<:AbstractFloat, 3},\n    phitilde::AbstractArray{<:AbstractFloat, 5},\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n    limiter_type::AbstractLimiter,\n)\n\nApply the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) for reconstruction in three dimensions.\n\nArguments\n\nphi: Input array.\nphitilde: Output array with reconstructed values. The fourth dimension represents the directions in which the input was reconstructed and the fifth dimension the reconstructions to the left and right.\nnxx: Size of phi in widehatx-direction.\nnyy: Size of phi in widehaty-direction.\nnzz: Size of phi in widehatz-direction.\nlimiter_type: Type of flux limiter to use.\n\nSee also\n\nPinCFlow.FluxCalculator.apply_1d_muscl!\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.compute_flux","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.compute_flux","text":"compute_flux(\n    usurf::AbstractFloat,\n    phiup::AbstractFloat,\n    phidown::AbstractFloat,\n)::AbstractFloat\n\nCompute and return the upstream flux from reconstructed values, based on the sign of the transporting velocity.\n\nArguments\n\nusurf: Transporting velocity.\nphiup: Upstream reconstruction for usurf > 0.\nphidown: Downstream reconstruction for usurf > 0.\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.compute_fluxes!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.compute_fluxes!","text":"compute_fluxes!(state::State, predictands::Predictands)\n\nCompute fluxes by dispatching to specialized methods for each prognostic variable.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::Rho)\n\nCompute the density fluxes in all three directions, by dispatching to a model-specific method.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    variable::Rho,\n    model::Boussinesq,\n)\n\nReturn in Boussinesq mode.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    variable::Rho,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nCompute the density fluxes in all three directions.\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^rho widehatx_i + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1^mathrmLright\n    mathcalF^rho widehaty_j + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 1^mathrmBright\n    mathcalF^rho widehatz_k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_k + 1^mathrmDright\nendalign*\n\nwhere\n\nbeginalign*\n    tau_widehatx  = left(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2\n    tau_widehaty  = left(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2\n    tau_widehatz  = left(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2\nendalign*\n\nare the transporting velocities (weighted by the Jacobian) and widetildephi is the reconstruction of rho  P_mathrmold. More specifically, the superscripts mathrmR, mathrmL, mathrmF, mathrmB, mathrmU and mathrmD indicate reconstructions at the right, left, forward, backward, upward and downward cell interfaces of the respective grid points, respectively. Quantities with the subscript mathrmold are obtained from a previous state, which is partially passed to the method via predictands.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::RhoP)\n\nCompute the density-fluctuations fluxes in all three directions.\n\nThe computation is analogous to that of the density fluxes.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    model::Union{Boussinesq, PseudoIncompressible},\n    variable::P,\n)\n\nReturn in non-compressible modes.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    model::Compressible,\n    variable::P,\n)\n\nCompute the mass-weighted potential-temperature fluxes in all three directions.\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^P widehatx_i + 1  2  = left(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2\n    mathcalF^P widehaty_j + 1  2  = left(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2\n    mathcalF^P widehatz_k + 1  2  = left(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::U)\n\nCompute the zonal-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho u widehatx_i + 1  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_i + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 3  2^mathrmLright\n    mathcalF^rho u widehaty_i + 1  2 j + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_i + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_i + 1  2 j + 1^mathrmBright\n    mathcalF^rho u widehatz_i + 1  2 k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_i + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_i + 1  2 k + 1^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_i + 1  2 j + 1  2\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_i + 1  2 k + 1  2\nendalign*\n\nand widetildephi being the reconstruction of rho_i + 1  2 u_i + 1  2  P_mathrmold i + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho u widehatx_i + 1  rightarrow mathcalF^rho u widehatx_i + 1 - eta_i + 1 left(J widehatPi^11right)_i + 1\n    mathcalF^rho u widehaty_i + 1  2 j + 1  2  rightarrow mathcalF^rho u widehaty_i + 1  2 j + 1  2 - eta_i + 1  2 j + 1  2 left(J widehatPi^12right)_i + 1  2 j + 1  2\n    mathcalF^rho u widehatz_i + 1  2 k + 1  2  rightarrow mathcalF^rho u widehatz_i + 1  2 k + 1  2 - eta_i + 1  2 k + 1  2 left(J widehatPi^13right)_i + 1  2 k + 1  2\nendalign*\n\nFinally, if the diffusivity mu is nonzero, the diffusive parts (weighted by the Jacobian) are added, i.e.\n\nbeginalign*\n    mathcalF^rho u widehatx_i + 1  rightarrow mathcalF^rho u widehatx_i + 1 - mu_i + 1 leftJ widehatleft(boldsymbolnabla uright)^widehatxright_i + 1\n    mathcalF^rho u widehaty_i + 1  2 j + 1  2  rightarrow mathcalF^rho u widehaty_i + 1  2 j + 1  2 - mu_i + 1  2 j + 1  2 leftJ widehatleft(boldsymbolnabla uright)^widehatyright_i + 1  2 j + 1  2\n    mathcalF^rho u widehatz_i + 1  2 k + 1  2  rightarrow mathcalF^rho u widehatz_i + 1  2 k + 1  2 - mu_i + 1  2 k + 1  2 leftJ widehatleft(boldsymbolnabla uright)^widehatzright_i + 1  2 k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::V)\n\nCompute the meridional-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho v widehatx_i + 1  2 j + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_j + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1 j + 1  2^mathrmLright\n    mathcalF^rho v widehaty_j + 1  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_j + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 3  2^mathrmBright\n    mathcalF^rho v widehatz_j + 1  2 k + 1  2  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_j + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_j + 1  2 k + 1^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1  2 j + 1  2\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_j + 1\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_j + 1  2 k + 1  2\nendalign*\n\nand widetildephi being the reconstruction of rho_j + 1  2 v_j + 1  2  P_mathrmold j + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho v widehatx_i + 1  2 j + 1  2  rightarrow mathcalF^rho v widehatx_i + 1  2 j + 1  2 - eta_i + 1  2 j + 1  2 left(J widehatPi^12right)_i + 1  2 j + 1  2\n    mathcalF^rho v widehaty_j + 1  rightarrow mathcalF^rho v widehaty_j + 1 - eta_j + 1 left(J widehatPi^22right)_j + 1\n    mathcalF^rho v widehatz_j + 1  2 k + 1  2  rightarrow mathcalF^rho v widehatz_j + 1  2 k + 1  2 - eta_j + 1  2 k + 1  2 left(J widehatPi^23right)_j + 1  2 k + 1  2\nendalign*\n\nFinally, if the diffusivity mu is nonzero, the diffusive parts (weighted by the Jacobian) are added, i.e.\n\nbeginalign*\n    mathcalF^rho v widehatx_i + 1  2 j + 1  2  rightarrow mathcalF^rho v widehatx_i + 1  2 j + 1  2 - mu_i + 1  2 j + 1  2 leftJ widehatleft(boldsymbolnabla vright)^widehatxright_i + 1  2 j + 1  2\n    mathcalF^rho v widehaty_j + 1  rightarrow mathcalF^rho v widehaty_j + 1 - mu_j + 1 leftJ widehatleft(boldsymbolnabla vright)^widehatyright_j + 1\n    mathcalF^rho v widehatz_j + 1  2 k + 1  2  rightarrow mathcalF^rho v widehatz_j + 1  2 k + 1  2 - mu_j + 1  2 k + 1  2 leftJ widehatleft(boldsymbolnabla vright)^widehatzright_j + 1  2 k + 1  2\nendalign*\n\ncompute_fluxes!(state::State, old_predictands::Predictands, variable::W)\n\nCompute the vertical-momentum fluxes in all three directions.\n\nThe fluxes are first set to the advective parts\n\nbeginalign*\n    mathcalF^rho w widehatx_i + 1  2 k + 1  2  = fractau_widehatx2 leftleft1 + mathrmsgn left(tau_widehatxright)right widetildephi_k + 1  2^mathrmR + left1 - mathrmsgn left(tau_widehatxright)right widetildephi_i + 1 k + 1  2^mathrmLright\n    mathcalF^rho w widehaty_j + 1  2 k + 1  2  = fractau_widehaty2 leftleft1 + mathrmsgn left(tau_widehatyright)right widetildephi_k + 1  2^mathrmF + left1 - mathrmsgn left(tau_widehatyright)right widetildephi_j + 1 k + 1  2^mathrmBright\n    mathcalF^rho w widehatz_k + 1  = fractau_widehatz2 leftleft1 + mathrmsgn left(tau_widehatzright)right widetildephi_k + 1  2^mathrmU + left1 - mathrmsgn left(tau_widehatzright)right widetildephi_k + 3  2^mathrmDright\nendalign*\n\nwith\n\nbeginalign*\n    tau_widehatx  = leftleft(J P_mathrmoldright)_i + 1  2 u_mathrmold i + 1  2right_i + 1  2 k + 1  2\n    tau_widehaty  = leftleft(J P_mathrmoldright)_j + 1  2 v_mathrmold j + 1  2right_j + 1  2 k + 1  2\n    tau_widehatz  = leftleft(J P_mathrmoldright)_k + 1  2 widehatw_mathrmold k + 1  2right_k + 1\nendalign*\n\nand widetildephi being the reconstruction of rho_k + 1  2 w_k + 1  2  P_mathrmold k + 1  2. If the viscosity is nonzero, the viscous parts (weighted by the Jacobian) are then added, i.e.\n\nbeginalign*\n    mathcalF^rho w widehatx_i + 1  2 k + 1  2  rightarrow mathcalF^rho w widehatx_i + 1  2 k + 1  2 - eta_i + 1  2 k + 1  2 left(J Pi^13right)_i + 1  2 k + 1  2\n    mathcalF^rho w widehaty_j + 1  2 k + 1  2  rightarrow mathcalF^rho w widehaty_j + 1  2 k + 1  2 - eta_j + 1  2 k + 1  2 left(J Pi^23right)_j + 1  2 k + 1  2\n    mathcalF^rho w widehatz_k + 1  rightarrow mathcalF^rho w widehatz_k + 1 - eta_k + 1 leftleft(J G^13 Pi^13right)_k + 1 - left(J G^23 Pi^23right)_k + 1 - Pi^33_k + 1right\nendalign*\n\nFinally, if the diffusivity mu is nonzero, the diffusive parts (weighted by the Jacobian) are added, i.e.\n\nbeginalign*\n    mathcalF^rho w widehatx_i + 1  2 k + 1  2  rightarrow mathcalF^rho w widehatx_i + 1  2 k + 1  2 - mu_i + 1  2 k + 1  2 leftJ widehatleft(boldsymbolnabla wright)^widehatxright_i + 1  2 k + 1  2\n    mathcalF^rho w widehaty_j + 1  2 k + 1  2  rightarrow mathcalF^rho w widehaty_j + 1  2 k + 1  2 - mu_j + 1  2 k + 1  2 leftJ widehatleft(boldsymbolnabla wright)^widehatyright_j + 1  2 k + 1  2\n    mathcalF^rho w widehatz_k + 1  rightarrow mathcalF^rho w widehatz_k + 1 - mu_k + 1 leftJ widehatleft(boldsymbolnabla wright)^widehatzright_k + 1\nendalign*\n\ncompute_fluxes!(state::State, predictands::Predictands, tracer_setup::NoTracer)\n\nReturn for configurations without tracer transport.\n\ncompute_fluxes!(state::State, predictands::Predictands, tracer_setup::TracerOn)\n\nCompute the tracer fluxes in all three directions.\n\nThe computation is analogous to that of the density fluxes.\n\ncompute_fluxes!(state::State, predictands::Predictands, variable::Theta)\n\nCompute the potential temperature fluxes by dispatching to a model-specific method.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    variable::Theta,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in Boussinesq/pseudo-incompressible mode.\n\ncompute_fluxes!(\n    state::State,\n    predictands::Predictands,\n    variable::Theta,\n    model::Compressible,\n)\n\nCompute the potential temperature fluxes due to heat conduction (weighted by the Jacobian) in compressible mode.\n\nThe fluxes are given by\n\nbeginalign*\n    mathcalF^theta widehatx_i + 1  2  = - lambda_i + 1  2 leftfracJ_i + 1  2Delta widehatx leftleft(fracPrhoright)_i + 1 - fracPrhorightright\n     qquad qquad qquad + leftfracleft(J G^13right)_i + 1  22 Delta widehatz leftleft(fracPrhoright)_i + 1  2 k + 1 - left(fracPrhoright)_i + 1  2 k - 1rightright\n    mathcalF^theta widehaty_j + 1  2  = - lambda_j + 1  2 leftfracJ_j + 1  2Delta widehaty leftleft(fracPrhoright)_j + 1 - fracPrhorightright\n     qquad qquad qquad + leftfracleft(J G^23right)_j + 1  22 Delta widehatz leftleft(fracPrhoright)_j + 1  2 k + 1 - left(fracPrhoright)_j + 1  2 k - 1rightright\n    mathcalF^theta widehatz_k + 1  2  = - lambda_k + 1  2 leftfracleft(J G^13right)_k + 1  22 Delta widehatx leftleft(fracPrhoright)_i + 1 k + 1  2 - left(fracPrhoright)_i - 1 k + 1  2rightright\n     qquad qquad qquad + fracleft(J G^23right)_k + 1  22 Delta widehaty leftleft(fracPrhoright)_j + 1 k + 1  2 - left(fracPrhoright)_j - 1 k + 1  2right\n     qquad qquad qquad + leftfracleft(J G^33right)_k + 1  2Delta widehatz leftleft(fracPrhoright)_k + 1 - fracPrhorightright\nendalign*\n\nwhere lambda is the thermal conductivity (computed from state.namelists.atmosphere.thermal_conductivity).\n\nArguments\n\nstate: Model state.\npredictands/old_predictands: The predictands that are used to compute the transporting velocities.\nmodel: Dynamic equations.\nvariable: Flux variable.\ntracer_setup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.FluxCalculator.compute_flux\nPinCFlow.Update.compute_stress_tensor\nPinCFlow.Update.conductive_heating\n\n\n\n\n\n","category":"function"},{"location":"reference/flux_calculator/#PinCFlow.FluxCalculator.reconstruct!","page":"FluxCalculator","title":"PinCFlow.FluxCalculator.reconstruct!","text":"reconstruct!(state::State)\n\nReconstruct the prognostic variables at the cell interfaces of their respective grids, using the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL).\n\nThis method calls specialized methods for each prognostic variable.\n\nreconstruct!(state::State, variable::Rho)\n\nReconstruct the density by dispatching to a model-specific method.\n\nreconstruct!(state::State, variable::Rho, model::Boussinesq)\n\nReturn in Boussinesq mode.\n\nreconstruct!(\n    state::State,\n    variable::Rho,\n    model::Union{PseudoIncompressible, Compressible},\n)\n\nReconstruct the density in non-Boussinesq modes.\n\nSince the transporting velocity is P widehatboldsymbolu, the density is divided by P before reconstruction.\n\nreconstruct!(state::State, variable::RhoP)\n\nReconstruct the density fluctuations.\n\nSimilar to the density, the density fluctuations are divided by P before reconstruction.\n\nreconstruct!(state::State, variable::U)\n\nReconstruct the zonal momentum.\n\nSince the transporting velocity is P widehatboldsymbolu, the zonal momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, variable::V)\n\nReconstruct the meridional momentum.\n\nSimilar to the zonal momentum, the meridional momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, variable::W)\n\nReconstruct the vertical momentum.\n\nThe vertical momentum is computed with compute_vertical_wind, set_zonal_boundaries_of_field! and set_meridional_boundaries_of_field!. Similar to the zonal and meridional momenta, the vertical momentum is divided by P interpolated to the respective cell interfaces before reconstruction.\n\nreconstruct!(state::State, tracer_setup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nreconstruct!(state::State, tracer_setup::TracerOn)\n\nReconstruct the tracers.\n\nSimilar to the density, the tracers are divided by P before reconstruction.\n\nArguments\n\nstate: Model state.\nvariable: The reconstructed variable.\nmodel: Dynamic equations.\ntracer_setup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.FluxCalculator.apply_3d_muscl!\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"theory/numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"theory/numerics/#Temporal-discretization","page":"Numerics","title":"Temporal discretization","text":"","category":"section"},{"location":"theory/numerics/#Pseudo-incompressible-mode","page":"Numerics","title":"Pseudo-incompressible mode","text":"The pseudo-incompressible equations are integrated with the semi-implicit time scheme\n\nbeginalign*\n    1  rho^n  = rho^n - overlinerho\n    2  left(rho^ rho^ widehatboldsymbolu^right)  = mathrmL_Delta t  2 left(rho^n rho^n widehatboldsymbolu^n widehatboldsymbolu^n alpha_mathrmR^n + 1right)\n    3  left(rho^n + 1  2 widehatboldsymbolu^n + 1  2 pi^n + 1  2right)  = mathrmRI_Delta t  2 left(rho^ rho^ widehatboldsymbolu^ pi^n beta_mathrmR^n + 1right)\n    4  left(rho^* widehatboldsymbolu^*right)  = mathrmRE_Delta t  2 left(rho^n rho^n widehatboldsymbolu^n pi^n + 1  2right)\n    5  left(rho^** rho^** widehatboldsymbolu^**right)  = mathrmL_Delta t left(rho^n rho^* widehatboldsymbolu^* widehatboldsymbolu^n + 1  2 alpha_mathrmR^n + 1right)\n    6  left(rho^n + 1 widehatboldsymbolu^n + 1 pi^n + 1right)  = mathrmRI_Delta t  2 left(rho^** rho^** widehatboldsymbolu^** pi^n + 1  2 2 beta_mathrmR^n + 1right)\nendalign*\n\nwhere the operators mathrmL, mathrmRI and mathrmRE perform an explicit integration of the left-hand sides, an implicit integration of the right-hand sides and an explicit integration of the right-hand sides, each over the time step indicated in its subscript, respectively. The superscripts represent various time levels between those before (n) and after (n + 1) the current time step Delta t = t^n + 1 - t^n. In mathrmL, the fourth argument is the velocity by which the prognostic variables are transported (Benacchio & Klein, 2019; Schmid et al., 2021). A complete description of the exact implementation of these steps follows here.\n\nThe density fluctuations are synchronized with the full density, i.e.\nrho^n = rho^n - overlinerho\nThe left-hand sides are integrated over Delta t  2 with a low-storage RK3 scheme (Williamson, 1980). Fractional implicit Euler steps are used to integrate the Rayleigh-damping terms of the LHS sponge. At every RK3 stage m, the following updates are performed.\nDensity update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(rho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerhoright)\nendalign*\nDensity-fluctuations update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 rho^m + 1\nendalign*\nWind update:\nbeginalign*\n    q^rho u m + 1  = fracDelta t2 left- mathcalA^rho u m n + mathcalV^rho u m + mathcalX^rho u m + f left(rho vright)^mright + left(alpha_mathrmRK q^rho uright)^m\n    u^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho uright)^m + beta_mathrmRK^m q^rho u m + 1right\n    q^rho v m + 1  = fracDelta t2 left- mathcalA^rho v m n + mathcalV^rho v m + mathcalX^rho v m - f left(rho uright)^mright + left(alpha_mathrmRK q^rho vright)^m\n    v^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho vright)^m + beta_mathrmRK^m q^rho v m + 1right\n    q^rho widehatw m + 1  = fracDelta t2 left- mathcalA^rho widehatw m n + mathcalV^rho widehatw m + mathcalX^rho widehatw m + G^13 f left(rho vright)^m - G^23 f left(rho uright)^mright + left(alpha_mathrmRK q^rho widehatwright)^m\n    widehatw^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho widehatwright)^m + beta_mathrmRK^m q^rho widehatw m + 1right\n    widehatboldsymbolu^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(widehatboldsymbolu^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 widehatboldsymbolu_mathrmR^m + 1right)\nendalign*\nTherein, alpha_mathrmRK^m and beta_mathrmRK^m are the RK3 coefficients, with alpha_mathrmRK^m = 0 at the first stage, and f_mathrmRK^m are the ratios between the sizes of the full time step and the RK3 substeps. The advective momentum-flux divergences are given by\nbeginalign*\n    mathcalA^rho u m n  = frac1J leftfracpartial J left(rho uright)^m u^npartial widehatx + fracpartial J left(rho uright)^m v^npartial widehaty + fracpartial J left(rho uright)^m widehatw^npartial widehatzright\n    mathcalA^rho v m n  = frac1J leftfracpartial J left(rho vright)^m u^npartial widehatx + fracpartial J left(rho vright)^m v^npartial widehaty + fracpartial J left(rho vright)^m widehatw^npartial widehatzright\n    mathcalA^rho widehatw m n  = G^13 mathcalA^rho u m n + G^23 mathcalA^rho v m n + frac1J^2 leftfracpartial J left(rho wright)^m u^npartial widehatx + fracpartial J left(rho wright)^m v^npartial widehaty + fracpartial J left(rho wright)^m widehatw^npartial widehatzright\nendalign*\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step. The divergence constraint is then enforced by solving a Poisson equation for Exner-pressure differences Delta pi, which are used to correct the wind, the density fluctuations and the Exner-pressure itself. The details of these substeps are as follows.\nPredictor step:\nbeginalign*\n    u^n + 1  2  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 leftu^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^rho u n + fracF^rho u n + 1rho^right)right\n    v^n + 1  2  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 leftv^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^rho v n + fracF^rho v n + 1rho^right)right\n    widehatw^n + 1  2  = left1 + beta_mathrmR^n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times leftwidehatw^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^rho widehatw n + fracb^J + fracF^rho widehatw n + 1rho^right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right\n     qquad quad + leftfracoverlinerhorho^ fracleft(N Delta tright)^24 left(G^1 3 u^n + 1  2 + G^2 3 v^n + 1  2right)right\n    rho^n + 1  2  = - fracrho^g left1 + beta_mathrmR^n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times left- fracoverlinerhorho^ N^2 fracDelta t2 J leftwidehatw^ + fracDelta t2 left(- c_p fracPrho^ mathcalP^rho widehatw n + fracF^rho widehatw n + 1rho^right)rightright\n     qquad quad + left(1 + beta_mathrmR^n + 1 fracDelta t2right) b^ + fracoverlinerhorho^ N^2 fracDelta t2 J left(1 + beta_mathrmR^n + 1 fracDelta t2right)\n     qquad quad times leftleft(G^1 3 u^n + 1  2 + G^2 3 v^n + 1  2right) vphantomfracoverlinerhorho^ N^2 fracDelta t2right\nendalign*\nPoisson equation:\nbeginalign*\n     frac1J left(fracpartial J P u^n + 1  2partial widehatx + fracpartial J P v^n + 1  2partial widehaty + fracpartial J P widehatw^n + 1  2partial widehatzright)\n     quad = frac1J leftfracpartial J P mathcalC^rho u  n + 1partial widehatx + fracpartial J P mathcalC^rho v  n + 1partial widehaty vphantomleft(fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad + fracpartialpartial widehatz leftleft(1 + beta_mathrmR^n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad qquad quad times left(fracDelta t2 c_p fracJ P^2rho^ mathcalD^rho widehatw + J P fracoverlinerhorho^ fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad quad times leftleftleftleft(G^13 mathcalC^rho u  n + 1 + G^23 mathcalC^rho v  n + 1right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right) vphantomleft(fracoverlinerhorho^ fracleft(N Delta tright)^24right)^- 1rightright\nendalign*\nCorrector step:\nbeginalign*\n    u^n + 1  2  rightarrow u^n + 1  2 - mathcalC^rho u  n + 1\n    v^n + 1  2  rightarrow v^n + 1  2 - mathcalC^rho v  n + 1\n    widehatw^n + 1  2  rightarrow widehatw^n + 1  2 - left1 + beta_mathrmR^n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times leftfracDelta t2 c_p fracPrho^ mathcalD^rho widehatw + fracoverlinerhorho^ fracleft(N Delta tright)^24 left(G^1 3 mathcalC^rho u  n + 1 + G^23 mathcalC^rho v  n + 1right)right\n    rho^n + 1  2  rightarrow rho^n + 1  2 + fracrho^g left1 + beta_mathrmR^n + 1 fracDelta t2 + fracoverlinerhorho^ fracleft(N Delta tright)^24right^- 1\n     quad times left- fracoverlinerhorho^ fracleft(N Delta tright)^24 J c_p fracPrho^ mathcalD^rho widehatw + fracoverlinerhorho^ N^2 fracDelta t2 J left(1 + beta_mathrmR^n + 1 fracDelta t2right)right\n     qquad quad times leftleft(G^1 3 mathcalC^rho u  n + 1 + G^2 3 mathcalC^rho v  n + 1right) vphantomfracoverlinerhorho^ fracleft(N Delta tright)^24right\n    pi^n + 1  2  = pi^n + Delta pi\nendalign*\nTherein, b = - g rho  rho, the pressure-difference gradient is given by\nbeginalign*\n    mathcalD^rho u  = left(fracpartial Delta pipartial widehatx + G^13 fracpartial Delta pipartial widehatzright)\n    mathcalD^rho v  = left(fracpartial Delta pipartial widehaty + G^23 fracpartial Delta pipartial widehatzright)\n    mathcalD^rho widehatw  = left(G^13 fracpartial Delta pipartial widehatx + G^23 fracpartial Delta pipartial widehaty + G^33 fracpartial Delta pipartial widehatzright)\nendalign*\nand the horizontal-wind correction terms are\nbeginalign*\n    mathcalC^rho u  n + 1  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p fracPrho^ mathcalD^rho u\n    mathcalC^rho v  n + 1  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p fracPrho^ mathcalD^rho v\nendalign*\nThe right-hand sides (without the Rayleigh-damping terms) are integrated over Delta t  2 with an explicit Euler step. Therein, the Exner-pressure fluctuations pi^n + 1  2 are used to compute the pressure gradient. The exact updates are\nbeginalign*\n    u^*  = u^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^rho u n + 1  2 + fracF^rho u n + 1rho^nright)\n    v^*  = v^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^rho v n + 1  2 + fracF^rho v n + 1rho^nright)\n    widehatw^*  = widehatw^n + fracDelta t2 left(- c_p fracPrho^n mathcalP^rho widehatw n + 1  2 + fracb^nJ + fracF^rho widehatw n + 1rho^nright)\n    rho^*  = - fracrho^ng leftb^n - fracDelta t2 overlinerho N^2 left(fracwrhoright)^nright\nendalign*\nThe left-hand sides are integrated over Delta t with the low-storage RK3 scheme. Fractional implicit Euler steps are once again used to integrate the Rayleigh-damping terms of the LHS sponge. This step is equivalent to the first one, except for the differences indicated in the compact description above.\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step, followed by the Poisson equation being solved and a correction step being performed. The Rayleigh-damping terms are doubled, since they were left out in the explicit Euler step. This step is equivalent to the second one, except for the differences indicated in the compact description above.","category":"section"},{"location":"theory/numerics/#Boussinesq-mode","page":"Numerics","title":"Boussinesq mode","text":"In Boussinesq mode, the time scheme remains mostly unchanged. As has been mentioned in the description of the physics, the continuity equation is removed, as are the density fluctuations everywhere except in the auxiliary equation and the buoyancy term of the transformed-vertical-momentum equation. Furthermore, overlinerho, overlinetheta, P and N^2 are replaced with rho_0, theta_0, P_0 and N_0^2, respectively.","category":"section"},{"location":"theory/numerics/#Compressible-mode","page":"Numerics","title":"Compressible mode","text":"In compressible mode, the time scheme is changed in several ways, due to the mass-weighted potential temperature having a spatiotemporal dependence and being directly coupled to the Exner-pressure. It may be summarized by\n\nbeginalign*\n    1  rho^n  = rho^n - fracP^noverlinetheta\n    2  left(rho^ rho^ P^ widehatboldsymbolu^ pi^right)  = mathrmL_Delta t  2 left(rho^n rho^n P^n widehatboldsymbolu^n pi^n P^n widehatboldsymbolu^n alpha_mathrmR^n + 1right)\n    3  left(rho^n + 1  2 widehatboldsymbolu^n + 1  2 pi^n + 1  2right)  = mathrmRI_Delta t  2 left(rho^ rho^ P^ widehatboldsymbolu^ pi^ beta_mathrmR^n + 1right)\n    4  left(rho^* widehatboldsymbolu^* pi^*right)  = mathrmRE_Delta t  2 left(rho^n rho^n P^n widehatboldsymbolu^n pi^nright)\n    5  left(rho^** rho^** P^** widehatboldsymbolu^** pi^**right)  = mathrmL_Delta t left(rho^n rho^* P^n widehatboldsymbolu^* pi^n + 1  2 P^ widehatboldsymbolu^n + 1  2 alpha_mathrmR^n + 1right)\n    6  left(rho^n + 1 widehatboldsymbolu^n + 1 pi^n + 1right)  = mathrmRI_Delta t  2 left(rho^** rho^** P^** widehatboldsymbolu^** pi^** 2 beta_mathrmR^n + 1right)\nendalign*\n\n(see Benacchio & Klein, 2019; Chew et al., 2022). Another detailed description follows here.\n\nThe density fluctuations are synchronized with the full density, i.e.\nrho^n = rho^n - fracP^noverlinetheta\nThe left-hand sides are integrated over Delta t  2 with the low-storage RK3 scheme. Fractional implicit Euler steps are used to integrate the Rayleigh-damping terms of the LHS sponge. The updates at every RK3 stage are as follows.\nDensity update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(rho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerhoright)\nendalign*\nDensity-fluctuations update:\nbeginalign*\n    q^rho m + 1  = - fracDelta t2 leftfrac1J left(fracpartial J rho^m u^npartial widehatx + fracpartial J rho^m v^npartial widehaty + fracpartial J rho^m widehatw^npartial widehatzright) + fracF^P n + 1overlinethetaright + left(alpha_mathrmRK q^rhoright)^m\n    rho^m + 1  = rho^m + beta_mathrmRK^m q^rho m + 1\n    rho^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 leftrho^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 overlinerho left1 - fracleft(P  rhoright)^m + 1overlinethetarightright\nendalign*\nMass-weighted potential-temperature update:\nbeginalign*\n    q^P m + 1  = - fracDelta t2 leftfrac1J leftfracpartial J left(P uright)^npartial widehatx + fracpartial J left(P vright)^npartial widehaty + fracpartial J left(P widehatwright)^npartial widehatzright - F^P n + 1right\n     quad + left(alpha_mathrmRK q^Pright)^m\n    P^m + 1  = P^m + beta_mathrmRK^m q^P m + 1\n    P^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 P^m + 1 left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 fracoverlinerhorho^m + 1right)\nendalign*\nWind update:\nbeginalign*\n    q^rho u m + 1  = fracDelta t2 left- mathcalA^rho u m n + mathcalV^rho u m + mathcalX^rho u m + f left(rho vright)^mright + left(alpha_mathrmRK q^rho uright)^m\n    u^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho uright)^m + beta_mathrmRK^m q^rho u m + 1right\n    q^rho v m + 1  = fracDelta t2 left- mathcalA^rho v m n + mathcalV^rho v m + mathcalX^rho v m - f left(rho uright)^mright + left(alpha_mathrmRK q^rho vright)^m\n    v^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho vright)^m + beta_mathrmRK^m q^rho v m + 1right\n    q^rho widehatw m + 1  = fracDelta t2 left- mathcalA^rho widehatw m n + mathcalV^rho widehatw m + mathcalX^rho widehatw m + G^13 f left(rho vright)^m - G^23 f left(rho uright)^mright + left(alpha_mathrmRK q^rho widehatwright)^m\n    widehatw^m + 1  = left(rho^- 1right)^m + 1 leftleft(rho widehatwright)^m + beta_mathrmRK^m q^rho widehatw m + 1right\n    widehatboldsymbolu^m + 1  rightarrow left(1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2right)^- 1 left(widehatboldsymbolu^m + 1 + alpha_mathrmR^n + 1 f_mathrmRK^m fracDelta t2 widehatboldsymbolu_mathrmR^m + 1right)\nendalign*\nAfter the last RK3 step, the Exner-pressure fluctuations are updated according to the Rayleigh damping applied to the mass-weighted potential temperature, i.e.\nbeginalign*\n    pi^ = pi^n - alpha_mathrmR fracDelta t2 left(P fracpartial pipartial Pright)^ left(1 - fracoverlinerhorho^right)\nendalign*\nwhere left(partial P  partial piright)^ = left(gamma - 1right)^- 1 left(R  p_mathrmrefright)^1 - gamma left(P^2 - gammaright)^, with gamma being the ratio between the specific heat capacities and constant pressure and volume, R being the specific gas constant and p_mathrmref being the reference (ground) pressure.\nThe right-hand sides are integrated over Delta t  2 with an implicit Euler step. The divergence constraint is then enforced by solving a Poisson equation for Exner-pressure differences Delta pi, which are used to correct the wind, the density fluctuations and the Exner-pressure itself. In principle, this is the same as in pseudo-incompressible mode, however, instead of widehatboldsymbolu, the predictor step updates widehatboldsymbolU = J P widehatboldsymbolu. The details are as follows.\nPredictor step:\nbeginalign*\n    U^n + 1  2  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 leftU^ + fracDelta t2 J P^ left- c_p left(fracPrhoright)^ mathcalP^rho u n + fracF^rho u n + 1rho^rightright\n    V^n + 1  2  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 leftV^ + fracDelta t2 J P^ left- c_p left(fracPrhoright)^ mathcalP^rho v n + fracF^rho v n + 1rho^rightright\n    widehatW^n + 1  2  = left1 + beta_mathrmR^n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times leftwidehatW^ + fracDelta t2 J P^ left- c_p left(fracPrhoright)^ mathcalP^rho widehatw n + fracb^J + fracF^rho widehatw n + 1rho^rightright\n     qquad quad + leftJ P^fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24 leftG^1 3 fracU^n + 1  2J P^ + G^2 3 fracV^n + 1  2J P^rightright\n    rho^n + 1  2  = - fracrho^g left1 + beta_mathrmR^n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times left- fracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J leftfracwidehatW^J P^ + fracDelta t2 left(- c_p left(fracPrhoright)^ mathcalP^rho widehatw n + fracF^rho widehatw n + 1rho^right)rightright\n     qquad quad  + left(1 + beta_mathrmR^n + 1 fracDelta t2right) b^ + fracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J left(1 + beta_mathrmR^n + 1 fracDelta t2right)\n     qquad quad times leftleft(G^1 3 fracU^n + 1  2J P^ + G^2 3 fracV^n + 1  2J P^right) vphantomleftleft(left(fracPrhoright)^right)rightright\nendalign*\nPoisson equation:\nbeginalign*\n     frac1J leftfracpartial U^n + 1  2partial widehatx + fracpartial V^n + 1  2partial widehaty + fracpartial widehatW^n + 1  2partial widehatzright - F^P n + 1\n     quad = - left(fracpartial Ppartial piright)^ frac2 Delta piDelta t\n     qquad + frac1J leftfracpartial J P^ mathcalC^rho u  n + 1partial widehatx + fracpartial J P^ mathcalC^rho v  n + 1partial widehaty vphantomleftleft(fracleft(P   rhoright)^overlinethetaright)^- 1rightright\n     qquad qquad quad + fracpartialpartial widehatz leftleft(1 + beta_mathrmR^n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right)^- 1right\n     qquad qquad qquad qquad times left(fracDelta t2 J P^ c_p left(fracPrhoright)^ mathcalD^rho widehatw + J P^ fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad qquad times leftleftleftleft(G^13 mathcalC^rho u  n + 1 + G^23 mathcalC^rho v  n + 1right)vphantomleft(fracP^2rhoright)^right) vphantomleft(fracleft(P   rhoright)^overlinethetaright)^- 1rightright\nendalign*\nCorrector step:\nbeginalign*\n    U^n + 1  2  = left(U^n + 1  2 - J P^ mathcalC^rho u  n + 1right)\n    V^n + 1  2  = left(V^n + 1  2 - J P^ mathcalC^rho v  n + 1right)\n    widehatW^n + 1  2  = leftwidehatW^n + 1  2 - left1 + beta_mathrmR^n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1right\n     qquad qquad qquad times leftfracDelta t2 J P^ c_p left(fracPrhoright)^ mathcalD^rho widehatw + J P^ fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right\n     qquad qquad qquad qquad times leftleftleft(G^1 3 mathcalC^rho u  n + 1 + G^23 mathcalC^rho v  n + 1right) vphantomleft(fracP^2rhoright)^right vphantomleftfracleft(P   rhoright)^overlinethetaright^- 1right\n    rho^n + 1  2  rightarrow rho^n + 1  2 + fracrho^g left1 + beta_mathrmR^n + 1 fracDelta t2 + fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24right^- 1\n     quad times left- fracleft(P   rhoright)^overlinetheta fracleft(N Delta tright)^24 J c_p left(fracPrhoright)^ mathcalD^rho widehatwright\n     qquad quad + leftfracleft(P   rhoright)^overlinetheta N^2 fracDelta t2 J left(1 + beta_mathrmR^n + 1 fracDelta t2right)  left(G^1 3 mathcalC^rho u  n + 1 + G^2 3 mathcalC^rho v  n + 1right)right\n    pi^n + 1  2  = pi^n + Delta pi\nendalign*\nThe horizontal-wind correction terms are given by\nbeginalign*\n    mathcalC^rho u  n + 1  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p left(fracPrhoright)^ mathcalD^rho u\n    mathcalC^rho v  n + 1  = left(1 + beta_mathrmR^n + 1 fracDelta t2right)^- 1 fracDelta t2 c_p left(fracPrhoright)^ mathcalD^rho v\nendalign*\nThe right-hand sides (without the Rayleigh-damping terms) are integrated over Delta t  2 with an explicit Euler step. In contrast to the pseudo-incompressible mode, the Exner-pressure fluctuations pi^n are used to compute the pressure gradient. They are themselves also updated with the left-hand side of the prognostic equation for P. Thus, one has\nbeginalign*\n    U^*  = leftU^n + fracDelta t2 J P^n left- c_p left(fracPrhoright)^n mathcalP^rho u n + fracF^rho u n + 1rho^nrightright\n    V^*  = leftV^n + fracDelta t2 J P^n left- c_p left(fracPrhoright)^n mathcalP^rho v n + fracF^rho v n + 1rho^nrightright\n    widehatW^*  = leftwidehatW^n + fracDelta t2 J P^n left- c_p left(fracPrhoright)^n mathcalP^rho widehatw n + fracb^nJ + fracF^rho widehatw n + 1rho^nrightright\n    rho^*  = - fracrho^ng leftb^n - fracDelta t2 N^2 fracleft(P  rhoright)^noverlinetheta fracW^nJ P^nright\n    pi^*  = pi^n - fracDelta t2 left(fracpartial pipartial Pright)^n leftfrac1J leftfracpartial U^npartial widehatx + fracpartial V^npartial widehaty + fracpartial widehatW^npartial widehatzright - F^P n + 1right\nendalign*\nThe left-hand sides are integrated over Delta t with the low-storage RK3 scheme. Fractional implicit Euler steps are once again used to integrate the Rayleigh-damping terms of the LHS sponge. This step is equivalent to the first one, except for the differences indicated in the compact description above.\nThe right-hand sides are integrated over over Delta t  2 with an implicit Euler step, followed by the Poisson equation being solved and a correction step being performed. The Rayleigh-damping terms are doubled, since they were left out in the explicit Euler step. This step is equivalent to the second one, except for the differences indicated in the compact description above.","category":"section"},{"location":"theory/numerics/#Tracer-transport","page":"Numerics","title":"Tracer transport","text":"Since its equation does not have a right-hand side, the tracer is only updated in the second and fifth step of the time scheme, analogous to the update of the mass-weighted potential temperature in compressible mode. At each RK-stage of the second step, one has\n\nbeginalign*\n    q^rho chi m + 1  = - fracDelta t2 leftfrac1J leftfracpartial J left(rho chiright)^m u^npartial widehatx + fracpartial J left(rho chiright)^m v^npartial widehaty + fracpartial J left(rho chiright)^m widehatw^npartial widehatzright - F^rho chi n + 1right + left(alpha_mathrmRK q^rho chiright)^m\n    left(rho chiright)^m + 1  = left(rho chiright)^m + beta_mathrmRK^m q^rho chi m + 1\n    left(rho chiright)^m + 1  rightarrow left(1 + alpha_mathrmR f_mathrmRK^m fracDelta t2right)^- 1 leftleft(rho chiright)^m + 1 + alpha_mathrmR f_mathrmRK^m fracDelta t2 left(rho chiright)^left(0right)right\nendalign*","category":"section"},{"location":"theory/numerics/#MS-GWaM","page":"Numerics","title":"MS-GWaM","text":"At the beginning of each time step, the saturation scheme is applied via integration of the respective term in the phase-space wave-action density equation with an explicit Euler step. i.e.\n\nmathcalN^n + 1 = mathcalN^n + Delta t mathcalS_s^n\n\nThe ray equations are then integrated with the low-storage RK3 scheme, following\n\nbeginalign*\n    q^x m + 1  = Delta t fracpartial Omega^m npartial k + alpha_mathrmRK^m q^x m  x^m + 1  = x^m + beta_mathrmRK^m q^x m + 1\n    q^y m + 1  = Delta t fracpartial Omega^m npartial l  + alpha_mathrmRK^m q^y m  y^m + 1  = y^m + beta_mathrmRK^m q^y m + 1\n    q^z m + 1  = Delta t fracpartial Omega^m npartial m + alpha_mathrmRK^m q^z m  z^m + 1  = z^m + beta_mathrmRK^m q^z m + 1\n    q^k m + 1  = Delta t left(fracpartial Omega^m npartial widehatx + G^13 fracpartial Omega^m npartial widehatzright) + alpha_mathrmRK^m q^k m  k^m + 1  = k^m + beta_mathrmRK^m q^k m + 1\n    q^l m + 1  = Delta t left(fracpartial Omega^m npartial widehaty + G^23 fracpartial Omega^m npartial widehatzright) + alpha_mathrmRK^m q^l m  l^m + 1  = l^m + beta_mathrmRK^m q^l m + 1\n    q^m m + 1  = fracDelta tJ fracpartial Omega^m npartial widehatz + alpha_mathrmRK^m q^m m  m^m + 1  = m^m + beta_mathrmRK^m q^m m + 1\nendalign*\n\nwhere Omega^m n = Omega left(boldsymbolx^m boldsymbolk^m widehatboldsymbolu^nright). At the end of every RK3 stage, the Rayleigh damping of the LHS sponge is applied to the phase-space wave-action density with a fractional implicit Euler step, i.e.\n\nmathcalN^n + 1 rightarrow left(1 + 2 alpha_mathrmR^n + 1 f_mathrmRK^m Delta tright)^- 1 mathcalN^n + 1\n\nNote that the intrinsic frequency does not need to be updated since it is completely determined the other variables. Finally, the mean-flow tendencies for the current time step are calculated from the updated wave-property fields (Jochum et al., 2025).","category":"section"},{"location":"theory/numerics/#Spatial-discretization","page":"Numerics","title":"Spatial discretization","text":"PinCFlow.jl is a finite-volume code that operates on a three-dimensional staggered C-grid (Arakawa & Lamb, 1977), with scalar fields defined at the cell centers and velocity components defined at the respective interfaces (Rieper et al., 2013). Advective-flux divergences are discretized with a monotone upwind scheme for conservation laws (van Leer, 2003) and a monotonized-centered variant limiter (e.g. Kemm, 2010). More specifically, the implementation is such that P widehatboldsymbolu is the carrier flux (based on Klein, 2009; Benacchio et al., 2014; Smolarkiewicz et al., 2014 and Benacchio & Klein, 2019). All other terms are discretized with centered differences (e.g. Durran, 2010). A Cartesian version of this is described in Rieper et al. (2013) and Schmid et al. (2021).\n\nThe spatial discretization of MS-GWaM is based on the definition of ray volumes, six-dimensional cubes in phase space. The ray equations are integrated at the center points and surface midpoints, using trilinear interpolation to get mean-flow information at the locations of interest. To prevent uninhibited growing, ray volumes are split when their extent in any dimension of physical space exceeds the corresponding grid spacing. This is counteracted by merging in spectral space to keep the number of ray volumes below a user-defined threshold. In the computation of the mean-flow impact, the contribution of each ray volume is weighted by the fraction of the local grid cell covered by it. A more detailed description of the algorithm can be found in Muraschko et al. (2014), Boeloeni et al. (2016), Wilhelm et al. (2018), Wei et al. (2019) and Jochum et al. (2025).","category":"section"},{"location":"reference/pincflow/#PinCFlow","page":"PinCFlow","title":"PinCFlow","text":"","category":"section"},{"location":"reference/pincflow/#PinCFlow.PinCFlow","page":"PinCFlow","title":"PinCFlow.PinCFlow","text":"PinCFlow\n\nMain module of PinCFlow.jl.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Integration\n\n\n\n\n\n","category":"module"},{"location":"reference/pincflow/#PinCFlow.plot_output","page":"PinCFlow","title":"PinCFlow.plot_output","text":"plot_output(\n    file::AbstractString,\n    data::HDF5.File,\n    fields::Vararg{\n        Tuple{<:AbstractString, <:Integer, <:Integer, <:Integer, <:Integer},\n    };\n    animate::Bool = false,\n    framerate::Real = 1,\n    number::Integer = 10,\n    colormap_name::Symbol = :seismic,\n    space_unit::AbstractString = \"km\",\n    time_unit::AbstractString = \"h\",\n)\n\nCreate contour plots or an animation of the dataset slices fields in data, display the figure (if not animated) and save it to file.\n\nArguments\n\nfile: File to save the plots to.\ndata: PinCFlow.jl output data.\nfields: Tuples of a variable name and four indices. The first three indices of each tuple define the planes in which the contours are to be plotted, whereas the fourth is the temporal index.\n\nKeywords\n\nanimate: Switch for the creation of an animation.\nframerate: Frames per second of the animation.\nnumber: Number of contour levels.\ncolormap_name: Colormap of choice.\nlabel: Colorbar label for the plots.\nspace_unit: Unit used for the coordinates. Must be \"km\" or \"m\".\ntime_unit: Unit used for the time. Must be \"d\", \"h\", \"min\" or \"s\".\n\n\n\n\n\n","category":"function"},{"location":"reference/pincflow/#PinCFlow.set_visualization_theme!","page":"PinCFlow","title":"PinCFlow.set_visualization_theme!","text":"set_visualization_theme!()\n\nConfigure Makie to use a customized theme.\n\n\n\n\n\n","category":"function"},{"location":"reference/pincflow/#PinCFlow.symmetric_contours","page":"PinCFlow","title":"PinCFlow.symmetric_contours","text":"symmetric_contours(\n    minimum::AbstractFloat,\n    maximum::AbstractFloat;\n    number::Integer = 10,\n    colormap_name::Symbol = :seismic,\n)::Tuple{<:LinRange{<:AbstractFloat, <:Integer}, <:Any}\n\nCompute symmetric contours levels and return them and a correspondingly indexed colormap.\n\nArguments\n\nminimum: Smallest value to be plotted.\nmaximum: Largest value to be plotted.\n\nKeywords\n\nnumber: Number of contour levels.\ncolormap_name: Name under which the chosen colormap is registered.\n\n\n\n\n\n","category":"function"},{"location":"reference/pincflow/#PinCFlow.@ivy","page":"PinCFlow","title":"PinCFlow.@ivy","text":"@ivy(x::Expr)\n\nReturn the expression x with @inbounds and @views in front of it.\n\n\n\n\n\n","category":"macro"},{"location":"license/#License","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2017-present The PinCFlow.jl Authors (see Authors)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"section"},{"location":"reference/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"reference/integration/#PinCFlow.Integration","page":"Integration","title":"PinCFlow.Integration","text":"Integration\n\nModule for integration of the full system.\n\nProvides helper functions for computing the time step, managing time levels and synchronizing fields, as well as the main function for running PinCFlow.jl.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.Update\nPinCFlow.PoissonSolver\nPinCFlow.FluxCalculator\nPinCFlow.Output\nPinCFlow.MSGWaM\n\n\n\n\n\n","category":"module"},{"location":"reference/integration/#PinCFlow.Integration.backup_predictands","page":"Integration","title":"PinCFlow.Integration.backup_predictands","text":"backup_predictands(state::State)::Tuple{<:Predictands, <:TracerPredictands}\n\nReturn a tuple with a copy of the predictands and tracer predictands.\n\nArguments\n\nstate: Model state\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.compute_time_step","page":"Integration","title":"PinCFlow.Integration.compute_time_step","text":"compute_time_step(state::State)::AbstractFloat\n\nCompute and return an adaptive time step based on several stability criteria.\n\nIf state.namelists.discretization.adaptive_time_step is set to true, the returned time step is given by\n\nDelta t = min left(Delta t_mathrmCFL Delta t_mathrmWKB Delta t_mathrmviscous Delta t_maxright)\n\nwhere Delta t_mathrmCFL and Delta t_mathrmWKB are computed from CFL conditions with respect to the resolved flow and unresolved gravity waves, respectively, Delta t_mathrmviscous is determined from a von Neumann condition that takes the viscosity into account and Delta t_max is an upper limit specified in state.namelists.discretization. Otherwise, the returned time step is equal to Delta t_max. If Delta t is smaller than Delta t_min (also specified in state.namelists.discretization), an error is thrown.\n\nThe individual stability criteria are as follows.\n\nCFL condition with respect to the resolved flow (where w is computed with compute_vertical_wind):\nDelta t_mathrmCFL = mu_mathrmCFL minlimits_mathrmglobal leftfracDelta widehatxu_max fracDelta widehatyv_max min left(fracJ Delta widehatzwright)right\nCFL condition with respect to the group velocities of unresolved gravity waves (where J_min is the minimum Jacobian in a one-grid-cell radius and c_mathrmg z is the maximum vertical group velocity within a grid cell):\nDelta t_mathrmWKB = mu_mathrmWKB minlimits_mathrmglobal leftfracDelta widehatxc_mathrmg x max fracDelta widehatyc_mathrmg y max min left(fracJ_min Delta widehatzc_mathrmg zright)right\nVon Neumann condition (with mathrmRe being the Reynolds number):\nDelta t_mathrmviscous = fracmathrmRe2 minlimits_mathrmglobal leftleft(Delta widehatxright)^2 left(Delta widehatyright)^2 left(J Delta widehatzright)^2right\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Update.compute_vertical_wind\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.explicit_integration!","page":"Integration","title":"PinCFlow.Integration.explicit_integration!","text":"explicit_integration!(\n    state::State,\n    p0::Predictands,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    side::LHS,\n)\n\nIntegrate the left-hand sides of the prognostic equations with a Runge-Kutta time step.\n\nAt each Runge-Kutta stage, the prognostic variables are first reconstructed and their advective and diffusive fluxes are calculated. Subsequently, each variable is updated with its integrated left-hand side, followed immediately by an implicit Euler step (the size of which is the fractional time step at the current Runge-Kutta stage) that accounts for the Rayleigh-damping imposed by the LHS sponge. After the Runge-Kutta loop, if the atmosphere is compressible, the Exner-pressure is updated with a full implicit Euler step to account for it being impacted by the Rayleigh damping of the mass-weighted potential temperature.\n\nexplicit_integration!(\n    state::State,\n    p0::Predictands,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    side::RHS,\n)\n\nPerform an explicit Euler step on the right-hand sides of the prognostic equations and, if the atmosphere is compressible, update the Exner-pressure such that it is synchronized with the mass-weighted potential temperature.\n\nArguments\n\nstate: Model state.\np0: The predictands that are used to compute the transporting velocities in the computation of the fluxes.\ndtstage: Fractional time step.\ntime: Simulation time.\nside: Side of the equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.implicit_integration!","page":"Integration","title":"PinCFlow.Integration.implicit_integration!","text":"implicit_integration!(\n    state::State,\n    dtstage::AbstractFloat,\n    time::AbstractFloat,\n    ntotalbicg::Integer,\n    side::RHS,\n    rayleigh_factor::AbstractFloat,\n    iout::Integer,\n    machine_start_time::DateTime,\n)\n\nPerform an implicit Euler step on the right-hand sides of the prognostic equations, solve the Poisson equation and correct the Exner-pressure, momentum and density fluctuations accordingly.\n\nArguments\n\nstate: Model state.\ndtstage: Fractional time step.\ntime: Simulation time.\nntotalbicg: BiCGSTAB-iterations counter.\nside: Side of the equations.\nrayleigh_factor: Factor by which the Rayleigh-damping coefficient is multiplied.\niout: Output counter.\nmachine_start_time: Wall-clock start time.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.integrate","page":"Integration","title":"PinCFlow.Integration.integrate","text":"integrate(namelists::Namelists)\n\nInitialize the model state and integrate it in time.\n\nThis method performs the complete time integration of the governing equations, using a semi-implicit time stepping scheme. It handles initialization, time stepping and output of the simulation data.\n\nThe initialization begins with the construction of the model state (an instance of the composite type State), which involves the setup of the MPI parallelization and the definition of all arrays that are needed repeatedly during the simulation. This is followed by an (optional) initial cleaning, in which the Poisson solver is called to ensure that the initial dynamic fields satisfy the divergence constraint imposed by the thermodynamic energy equation. Afterwards, the initialization of MS-GWaM is completed by adding ray volumes to the previously defined arrays. If the simulation is supposed to start from a previous model state, the fields are then overwritten with the data in the corresponding input file. Finally, the output file is created and the initial state is written into it.\n\nAt the beginning of each time-loop iteration, the time step is determined from several stability criteria, using compute_time_step. In case the updated simulation time is later than the next output time, the time step is corrected accordingly. Subsequently, the damping coefficients of the sponges (which may depend on the time step) are calculated. Following this, MS-GWaM updates the unresolved gravity-wave field and computes the corresponding mean-flow impact. Afterwards, the resolved flow is updated in a semi-implicit time step, comprised of the following stages.\n\nExplicit RK3 integration of LHS over Delta t  2.\nImplicit Euler integration of RHS over Delta t  2.\nExplicit Euler integration of RHS over Delta t  2.\nExplicit RK3 integration of LHS over Delta t.\nImplicit Euler integration of RHS over Delta t  2.\n\nTherein, the left-hand sides of the equations include advective fluxes, diffusion terms, rotation and heating, whereas the pressure gradient, buoyancy term and momentum-flux divergence due to unresolved gravity waves are on the right-hand sides. Boundary conditions are enforced continuously. At the end of the time step, the updated fields are written into the output file if the next output time has been reached.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\nSee also\n\nPinCFlow.Types.State\nPinCFlow.Integration.modify_compressible_wind!\nPinCFlow.Boundaries.set_boundaries!\nPinCFlow.PoissonSolver.apply_corrector!\nPinCFlow.Output.create_output\nPinCFlow.Output.write_output\nPinCFlow.MSGWaM.RayUpdate.initialize_rays!\nPinCFlow.Output.read_input!\nPinCFlow.Integration.synchronize_compressible_atmosphere!\nPinCFlow.Integration.compute_time_step\nPinCFlow.Update.compute_sponges!\nPinCFlow.Integration.wkb_integration!\nPinCFlow.Integration.synchronize_density_fluctuations!\nPinCFlow.Integration.explicit_integration!\nPinCFlow.Integration.implicit_integration!\nPinCFlow.Integration.reset_predictands!\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.modify_compressible_wind!","page":"Integration","title":"PinCFlow.Integration.modify_compressible_wind!","text":"modify_compressible_wind!(state::State, operation::Function)\n\nModify the wind with J P if the atmosphere is compressible by dispatching to the appropriate method.\n\nmodify_compressible_wind!(\n    state::State,\n    operation::Function,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes.\n\nmodify_compressible_wind!(\n    state::State,\n    operation::Function,\n    model::Compressible,\n)\n\nInterpolate J P to the wind grids and replace the wind components with the result of applying operation to them and the interpolations.\n\nArguments\n\nstate: Model state.\noperation: Binary operation used for modification.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.reset_predictands!","page":"Integration","title":"PinCFlow.Integration.reset_predictands!","text":"reset_predictands!(\n    state::State,\n    predictands::Predictands,\n    tracerpredictands::TracerPredictands,\n)\n\nReset fields in state to those in predictands and tracerpredictands by dispatching to specific methods.\n\nreset_predictands!(state::State, tracerpredictands::TracerPredictands)\n\nReset fields in state.tracer.tracerpredictands to those in tracerpredictands.\n\nreset_predictands!(\n    state::State,\n    predictands::Predictands,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReset the density, density fluctuations and wind components in state.variables.predictands to those in predictands.\n\nreset_predictands!(state::State, predictands::Predictands, model::Compressible)\n\nReset the density, density fluctuations, wind components, Exner pressure and mass-weighted potential temperature (i.e. all fields) in state.variables.predictands to those in predictands.\n\nArguments\n\nstate: Model state.\npredictands: Fields to reset to.\ntracerpredictands: Tracer fields to reset to.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.save_backups!","page":"Integration","title":"PinCFlow.Integration.save_backups!","text":"save_backups!(state::State, variables::Vararg{Symbol})\n\nCopy the specified fields in state.variables.predictands to their counterparts in state.variables.backups.\n\nArguments\n\nstate: Model state.\nvariables: Names of the fields to create backups of.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.synchronize_compressible_atmosphere!","page":"Integration","title":"PinCFlow.Integration.synchronize_compressible_atmosphere!","text":"synchronize_compressible_atmosphere!(state::State, predictands::Predictands)\n\nSynchronize state.atmosphere.pbar with predictands.p if the atmosphere is compressible by dispatching to the appropriate method.\n\nsynchronize_compressible_atmosphere!(\n    state::State,\n    predictands::Predictands,\n    model::Union{Boussinesq, PseudoIncompressible},\n)\n\nReturn in non-compressible modes.\n\nsynchronize_compressible_atmosphere!(\n    state::State,\n    predictands::Predictands,\n    model::Compressible,\n)\n\nSynchronize state.atmosphere.pbar with predictands.p.\n\nIn compressible mode, P is time-dependent. In the update of P, only state.variables.predictands.p is changed, so that the old values of P are retained in the respective field of state.atmosphere. When these are no longer needed, this method is used to update the field accordingly.\n\nArguments\n\nstate: Model state.\npredictands: Predictands to use for the synchronization of the mass-weighted potential temperature.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.synchronize_density_fluctuations!","page":"Integration","title":"PinCFlow.Integration.synchronize_density_fluctuations!","text":"synchronize_density_fluctuations!(state::State)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho by dispatching to a model-specific method.\n\nsynchronize_density_fluctuations!(state::State, model::Boussinesq)\n\nReturn in Boussinesq mode.\n\nIn Boussinesq mode, density fluctuations don't require synchronization, since the density is assumed constant except in the buoyancy equation.\n\nsynchronize_density_fluctuations!(state::State, model::PseudoIncompressible)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho.\n\nThe density fluctuations are defined as the product of the mass-weighted potential temperature and the fluctuations of the inverse potential temperature. In pseudo-incompressible mode, P is constant, so that this is reduced to the difference between rho and overlinerho, i.e.\n\nrho = fracPtheta - fracPoverlinetheta = rho - overlinerho\n\nsynchronize_density_fluctuations!(state::State, model::Compressible)\n\nSynchronize the density fluctuations in state.variables.predictands.rhop with the density in state.variables.predictands.rho.\n\nIn compressible mode, P is time-dependent, so that the density fluctuations are not reduced to the difference between rho and overlinerho, i.e.\n\nrho = fracPtheta - fracPoverlinetheta = rho - fracPoverlinetheta\n\nArguments\n\nstate: Model state.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"function"},{"location":"reference/integration/#PinCFlow.Integration.wkb_integration!","page":"Integration","title":"PinCFlow.Integration.wkb_integration!","text":"wkb_integration!(state::State, dtstage::AbstractFloat)\n\nUse MS-GWaM to update the properties of the unresolved gravity-wave field and compute its impact on the resolved flow.\n\nIn the first step, MS-GWaM's saturation scheme is applied to account for the impact of wave breaking on the wave-action field. Next, the ray volumes are propagated via integration of the ray equations with a Runge-Kutta time step. Ray volumes that have grown larger than the cells of the model grid are then split before their array positions are shifted such that they are attributed to the correct grid cells. Afterwards, ray volumes are merged in cells where their count exceeds a specified threshold. Finally, the ray volumes in boundary and halo cells are updated and the mean-flow impact is calculated.\n\nArguments\n\nstate: Model state.\ndtstage: Time step.\n\n\n\n\n\n","category":"function"},{"location":"theory/physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"theory/physics/#Coordinate-system","page":"Physics","title":"Coordinate system","text":"PinCFlow.jl uses a height-based terrain-following coordinate system (Gal-Chen & Somerville, 1975) with vertical stretching. The transformation from the Cartesian system boldsymbolx = left(x y zright)^mathrmT to the model's system widehatboldsymbolx = left(widehatx widehaty widehatzright)^mathrmT is given by\n\nbeginalign*\n    widehatz  = widehatz left(widetildezright)  left(widehatx widehaty widetildezright)  = left(x y L_z fracz - hL_z - hright)   left(x y zright)  = left(widehatx widehaty fracL_z - hL_zwidetildez + hright)\nendalign*\n\nwhere L_z is the vertical extent of the model domain and h is the surface topography. The contravariant basis vectors of the transformed system are\n\nbeginalign*\n    boldsymbolepsilon^widehatx  = boldsymbole^x  boldsymbolepsilon^widehaty  = boldsymbole^y  boldsymbolepsilon^widehatz = fracpartial hpartial widehatx fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez boldsymbole^x + fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez boldsymbole^y + fracL_zL_z - h fracpartial widehatzpartial widetildezboldsymbole^z\nendalign*\n\nThe scalar products of these yield the metric tensor\n\nG^mu nu = beginpmatrix\n    1  0  fracpartial hpartial x fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez\n    0  1  fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez\n    fracpartial hpartial x fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez  fracpartial hpartial y fracwidetildez - L_zL_z - h fracpartial widehatzpartial widetildez  leftleft(fracL_zL_z - hright)^2 + left(fracwidetildez - L_zL_z - hright)^2 leftleft(fracpartial hpartial xright)^2 + left(fracpartial hpartial yright)^2rightright left(fracpartial widehatzpartial widetildezright)^2\nendpmatrix\n\nfrom which the Jacobian\n\nJ = fracL_z - h L_z fracpartial widetildezpartial widehatz\n\ncan be determined. Finally, the transformation rule for the wind reads\n\nleft(widehatu widehatv widehatwright) = left(u v G^13 u + G^23 v + J^- 1 wright)","category":"section"},{"location":"theory/physics/#Pseudo-incompressible-equations","page":"Physics","title":"Pseudo-incompressible equations","text":"The atmosphere is decomposed into a hydrostatic background and deviations from it, specifically\n\nbeginalign*\n    pi left(boldsymbolx tright)  = overlinepi left(zright) + pi left(boldsymbolx tright)\n    theta left(boldsymbolx tright)  = overlinetheta left(zright) + theta left(boldsymbolx tright)\nendalign*\n\nwhere pi, theta and t denote the Exner-pressure, potential temperature and time, respectively, and the background satisfies\n\nbeginalign*\n    overlinepi left(0right) = 1  fracmathrmd overlinepimathrmd z = - fracgc_p overlinetheta^- 1\nendalign*\n\nwith g and c_p being the gravitational acceleration and specific heat capacity at constant pressure, respectively (Benacchio & Klein, 2019). Using this decomposition, the model equations in pseudo-incompressible mode are written as\n\nsmallbeginalign*\n    fracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + alpha_mathrmR left(rho - overlinerhoright)  = 0\n    fracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + alpha_mathrmR rho  = fracN^2 overlinerho wg\n    frac1J left(fracpartial J P upartial widehatx + fracpartial J P vpartial widehaty + fracpartial J P widehatwpartial widehatzright)  = 0\n    fracpartial rho upartial t + mathcalA^rho u - mathcalV^rho u - mathcalX^rho u - f rho v + alpha_mathrmR left(u - u_mathrmRright)  = - c_p P mathcalP^rho u - beta_mathrmR rho u + F^rho u\n    fracpartial rho vpartial t + mathcalA^rho v - mathcalV^rho v - mathcalX^rho v + f rho u + alpha_mathrmR left(v - v_mathrmRright)  = - c_p P mathcalP^rho v - beta_mathrmR rho v + F^rho v\n    fracpartial rho widehatwpartial t + mathcalA^rho widehatw - mathcalV^rho widehatw - mathcalX^rho widehatw - G^13 f rho v + G^23 f rho u + alpha_mathrmR left(widehatw - widehatw_mathrmRright)  = - c_p P mathcalP^rho widehatw - fracg rhoJ - beta_mathrmR rho widehatw + F^rho widehatw\nendalign*\n\nwhere rho left(boldsymbolx tright) = overlinerho left(zright) + rho left(boldsymbolx tright) is the density, P = rho theta = overlinerho overlinetheta is the mass-weighted potential temperature, N^2 = left(g  overlinethetaright) left(mathrmd overlinetheta  mathrmd zright) is the squared buoyancy frequency and f = f_0 is the Coriolis frequency. On the left-hand sides, alpha_mathrmR and left(u_mathrmR v_mathrmR widehatw_mathrmRright)^mathrmR represent the Rayleigh-damping coefficient of a customizable sponge and the transformed wind that is to be obtained via the relaxation in it. In contrast, the Rayleigh-damping coefficient beta_mathrmR on the right-hand side implements a preset sponge. The terms left(F^rho u F^rho v F^rho widehatwright)^mathrmT represent volume forces in the momentum equation, e.g. drag imposed by unresolved gravity waves. The advective momentum-flux divergences are given by\n\nbeginalign*\n    mathcalA^rho u  = frac1J left(fracpartial J rho u upartial widehatx + fracpartial J rho u vpartial widehaty + fracpartial J rho u widehatwpartial widehatzright)\n    mathcalA^rho v  = frac1J left(fracpartial J rho v upartial widehatx + fracpartial J rho v vpartial widehaty + fracpartial J rho v widehatwpartial widehatzright)\n    mathcalA^rho widehatw  = G^13 mathcalA^rho u + G^23 mathcalA^rho v + frac1J^2 left(fracpartial J rho w upartial widehatx + fracpartial J rho w vpartial widehaty + fracpartial J rho w widehatwpartial widehatzright)\nendalign*\n\nand the viscous-flux divergences are\n\nbeginalign*\n    mathcalV^rho u  = frac1J left(fracpartial J eta widehatPi^11partial widehatx + fracpartial J eta widehatPi^12partial widehaty + fracpartial J eta widehatPi^13partial widehatzright)\n    mathcalV^rho v  = frac1J left(fracpartial J eta widehatPi^21partial widehatx + fracpartial J eta widehatPi^22partial widehaty + fracpartial J eta widehatPi^23partial widehatzright)\n    mathcalV^rho widehatw  = G^13 mathcalV^rho u + G^23 mathcalV^rho v + frac1J^2 leftfracpartial J eta Pi^31partial widehatx + fracpartial J eta Pi^32partial widehaty + fracpartialpartial widehatz left(J G^13 eta Pi^13 + J G^23 eta Pi^23 + eta Pi^33right)right\nendalign*\n\nTherein, eta is the dynamic shear viscosity, the elements of the (symmetric) transformed stress tensor are given by\n\nbeginalign*\n    widehatPi^11  = Pi^11\n    widehatPi^12  = Pi^12\n    widehatPi^22  = Pi^22\n    widehatPi^13  = G^13 Pi^11 + G^23 Pi^12 + frac1J Pi^13\n    widehatPi^23  = G^13 Pi^12 + G^23 Pi^22 + frac1J Pi^23\n    widehatPi^33  = left(G^13right)^2 Pi^11 + left(G^23right)^2 Pi^22 + frac1J^2 Pi^33 + 2 left(G^13 G^23 Pi^12 + fracG^13J Pi^13 + fracG^23J Pi^23right)\nendalign*\n\nand those of its Cartesian counterpart are\n\nbeginalign*\n    Pi^11  = 2 left(fracpartial upartial widehatx + G^13 fracpartial upartial widehatzright) - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)\n    Pi^12  = fracpartial upartial widehaty + G^23 fracpartial upartial widehatz + fracpartial vpartial widehatx + G^13 fracpartial vpartial widehatz\n    Pi^13  = frac1J fracpartial upartial widehatz + fracpartial wpartial widehatx + G^13 fracpartial wpartial widehatz\n    Pi^22  = 2 left(fracpartial vpartial widehaty + G^23 fracpartial vpartial widehatzright) - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)\n    Pi^23  = frac1J fracpartial vpartial widehatz + fracpartial wpartial widehaty + G^23 fracpartial wpartial widehatz\n    Pi^33  = frac2J fracpartial wpartial widehatz - frac23 J left(fracpartial J upartial widehatx + fracpartial J vpartial widehaty + fracpartial J widehatwpartial widehatzright)\nendalign*\n\nIn addition, turbulent diffusion is represented by\n\nbeginalign*\n    mathcalX^rho u  = frac1J leftfracpartial J mu widehatleft(boldsymbolnabla uright)^widehatxpartial widehatx + fracpartial J mu widehatleft(boldsymbolnabla uright)^widehatypartial widehaty + fracpartial J mu widehatleft(boldsymbolnabla uright)^widehatzpartial widehatzright\n    mathcalX^rho v  = frac1J leftfracpartial J mu widehatleft(boldsymbolnabla vright)^widehatxpartial widehatx + fracpartial J mu widehatleft(boldsymbolnabla vright)^widehatypartial widehaty + fracpartial J mu widehatleft(boldsymbolnabla vright)^widehatzpartial widehatzright)\n    mathcalX^rho widehatw  = G^13 mathcalX^rho u + G^23 mathcalX^rho v + frac1J^2 leftfracpartial J mu widehatleft(boldsymbolnabla wright)^widehatxpartial widehatx + fracpartial J mu widehatleft(boldsymbolnabla wright)^widehatypartial widehaty + fracpartial J mu widehatleft(boldsymbolnabla wright)^widehatzpartial widehatzright\nendalign*\n\nwhere mu is a constant turbulent viscosity and\n\nbeginalign*\n    widehatleft(boldsymbolnabla phiright)^widehatx  = fracpartial phipartial widehatx + G^13 fracpartial phipartial widehatz\n    widehatleft(boldsymbolnabla phiright)^widehaty  = fracpartial phipartial widehaty + G^23 fracpartial phipartial widehatz\n    widehatleft(boldsymbolnabla phiright)^widehatz  = G^13fracpartial phipartial widehatx + G^23 fracpartial phipartial widehaty + G^33fracpartial phipartial widehatz\nendalign*\n\nAnalogously, the components of the pressure gradient are given by\n\nbeginalign*\n    mathcalP^rho u  = fracpartial pipartial widehatx + G^13 fracpartial pipartial widehatz\n    mathcalP^rho v  = fracpartial pipartial widehaty + G^23 fracpartial pipartial widehatz\n    mathcalP^rho widehatw  = G^13 fracpartial pipartial widehatx + G^23 fracpartial pipartial widehaty + G^33 fracpartial pipartial widehatz\nendalign*\n\n(see Rieper et al., 2013; Schmid et al., 2021).","category":"section"},{"location":"theory/physics/#Boussinesq-equations","page":"Physics","title":"Boussinesq equations","text":"In Boussinesq mode, the continuity equation is removed and the density fluctuations are set to zero everywhere except in the auxiliary equation and the buoyancy term of the transformed-vertical-momentum equation. Moreover, overlinerho, overlinetheta, P and N^2 are replaced with the constant reference values rho_0, theta_0, P_0 and N_0^2.","category":"section"},{"location":"theory/physics/#Compressible-equations","page":"Physics","title":"Compressible equations","text":"In compressible mode, the identity P = overlinerho overlinetheta no longer holds, i.e. the mass-weighted potential temperature has a spatiotemporal dependence. The divergence constraint is thus replaced with the prognostic equation\n\nfracpartial Ppartial t + frac1J left(fracpartial J P upartial widehatx + fracpartial J P vpartial widehaty + fracpartial J P widehatwpartial widehatzright) - F^P + alpha_mathrmR P left(1 - fracoverlinerhorhoright) = 0\n\nwhere the volume force F^P represents a diabatic heating (e.g. due to heat conduction or unresolved gravity waves) that is not allowed in pseudo-incompressible mode. This term must also be represented in the auxiliary equation, which now reads\n\nfracpartial rhopartial t + frac1J left(fracpartial J rho upartial widehatx + fracpartial J rho vpartial widehaty + fracpartial J rho widehatwpartial widehatzright) + fracF^Poverlinetheta + alpha_mathrmR leftrho - overlinerho left(1 - fracPrho overlinethetaright)right = fracN^2 P wg overlinetheta\n\nNote that in addition to the new volume-force term, overlinerho has been replaced with P  overlinetheta, which is due to the density fluctuations being defined as rho = rho - P  overlinetheta (Benacchio & Klein, 2019).","category":"section"},{"location":"theory/physics/#Tracer-transport","page":"Physics","title":"Tracer transport","text":"PinCFlow.jl transports a passive tracer chi governed by\n\nfracpartial rho chipartial t + frac1J left(fracpartial J rho chi upartial widehatx + fracpartial J rho chi vpartial widehaty + fracpartial J rho chi widehatwpartial widehatzright) - F^rho chi + alpha_mathrmR leftrho chi - left(rho chiright)^left(0right)right = 0\n\nwhere F^rho chi represents another volume force, e.g. a tracer-flux divergence due to unresolved gravity waves, and left(rho chiright)^left(0right) is the initial mass-weighted tracer.","category":"section"},{"location":"theory/physics/#MS-GWaM","page":"Physics","title":"MS-GWaM","text":"","category":"section"},{"location":"theory/physics/#3D-transient-theory","page":"Physics","title":"3D transient theory","text":"The gravity-wave dispersion relation is written as omega left(boldsymbolx tright) = Omega leftboldsymbolx t boldsymbolk left(boldsymbolx tright)right, where in\n\nOmega left(boldsymbolx t boldsymbolkright) = boldsymbolk cdot boldsymbolu_mathrmb pm sqrtfracN^2 left(zright) left(k^2 + l^2right) + f^2 m^2leftboldsymbolkright^2\n\nthe spatiotemporal dependence is split into an explicit part due to variations in the (resolved) background wind boldsymbolu_mathrmb = left(u_mathrmb v_mathrmb 0right)^mathrmT and the squared buoyancy frequency N^2, and an implicit part due to variations in the wavevector boldsymbolk = left(k l mright)^mathrmT. Using this decomposition, the eikonal equations are written as\n\nbeginalign*\n    dotomega  = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrixright omega = fracpartial Omegapartial t\ndotboldsymbolk  = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrixright boldsymbolk = beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrix Omega\nendalign*\n\nThey are integrated along rays defined by the group velocity\n\nbeginalign*\n    dotboldsymbolx = boldsymbolc_mathrmg = boldsymbolnabla_boldsymbolk Omega\nendalign*\n\nwhere boldsymbolnabla_boldsymbolk = left(partial_k partial_l partial_mright)^mathrmT. The gravity-wave energy is encoded in the phase-space wave-action density, which is governed by the equation\n\ndotmathcalN = leftfracpartialpartial t + boldsymbolc_mathrmg cdot beginpmatrix\n    partial_widehatx + G^13 partial_widehatz\n    partial_widehaty + G^23 partial_widehatz\n    J^- 1 partial_widehatz\nendpmatrix + dotboldsymbolk cdot boldsymbolnabla_boldsymbolkright mathcalN = sumlimits_s mathcalS_s\n\nwhere mathcalS_s are sinks and sources. This latter equation is integrated along rays defined by left(dotboldsymbolx dotboldsymbolkright)^mathrmT, so that mathcalN is conserved if the right-hand side is zero. The impact of the unresolved gravity waves on the resolved flow is given by\n\nbeginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        J^- 1 partial_widehatz\n    endpmatrix cdot left(overlinerho leftlangle u boldsymbolu rightrangleright) - rho_mathrmb fracfoverlinetheta leftlangle theta v rightrangle\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        J^- 1 partial_widehatz\n    endpmatrix cdot left(overlinerho leftlangle v boldsymbolu rightrangleright) + rho_mathrmb fracfoverlinetheta leftlangle theta u rightrangle\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = - rho_mathrmb beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        0\n    endpmatrix cdot leftlangle theta boldsymbolu rightrangle\nendalign*\n\nwhere rho_mathrmb, widehatboldsymbolu_mathrmb = left(u_mathrmb v_mathrmb widehatw_mathrmbright)^mathrmT and P_mathrmb are the resolved density, transformed wind and mass-weighted potential temperature, respectively, and\n\nbeginalign*\n    overlinerho leftlangle u u rightrangle  = int leftk widehatc_mathrmg x - mathrmsgn left(leftfrightright) frack widehatc_mathrmg x + l widehatc_mathrmg y1 - left(widehatomega  fright)^2right mathcalN  mathrmd V_boldsymbolk\n    overlinerho leftlangle u v rightrangle  = int l widehatc_mathrmg x mathcalN  mathrmd V_boldsymbolk\n    overlinerho leftlangle u w rightrangle  = int frack widehatc_mathrmg z1 - left(f  widehatomegaright)^2 mathcalN  mathrmd V_boldsymbolk\n    overlinerho leftlangle v v rightrangle  = int leftl widehatc_mathrmg y - mathrmsgn left(leftfrightright) frack widehatc_mathrmg x + l widehatc_mathrmg y1 - left(widehatomega  fright)^2right mathcalN  mathrmd V_boldsymbolk\n    overlinerho leftlangle v w rightrangle  = int fracl widehatc_mathrmg z1 - left(f  widehatomegaright)^2 mathcalN  mathrmd V_boldsymbolk\n    leftlangle theta u rightrangle  = fracf overlinethetag overlinerho int fracl m N^2widehatomega leftboldsymbolkright^2 mathcalN  mathrmd V_boldsymbolk\n    leftlangle theta v rightrangle  = - fracf overlinethetag overlinerho int frack m N^2widehatomega leftboldsymbolkright^2 mathcalN  mathrmd V_boldsymbolk\nendalign*\n\nwith widehatomega = omega - boldsymbolk cdot boldsymbolu_mathrmb, widehatboldsymbolc_mathrmg = left(widehatc_mathrmg x widehatc_mathrmg y widehatc_mathrmg zright)^mathrmT = boldsymbolnabla_boldsymbolk widehatomega and mathrmd V_boldsymbolk = mathrmd k mathrmd l mathrmd m being the intrinsic frequency, intrinsic group velocity and spectral volume element, respectively (see Achatz et al., 2017; Achatz et al., 2023; Jochum et al., 2025).","category":"section"},{"location":"theory/physics/#Wave-breaking","page":"Physics","title":"Wave breaking","text":"Wave breaking is captured with a saturation scheme. This scheme assumes that static instability leads to turbulent fluxes that may be described by a turbulent viscosity and diffusivity K in a flux-gradient ansatz (see Lindzen, 1981; Becker, 2004). The divergence of these fluxes has a damping effect on the phase-space wave-action density, which is represented by the sink\n\nmathcalS_mathrms = - 2 K leftboldsymbolkright^2 mathcalN\n\nThis damping is assumed to be such that within one time step Delta t, the instability criterion is no longer fulfilled, which implies\n\nK = fracoverlinerho4 Delta t leftint N^4 left(k^2 + l^2right) m^2 fracmathcalNwidehatomega  mathrmd V_boldsymbolkright^- 1 max left0 frac2overlinerho int fracN^4 left(k^2 + l^2right) m^2widehatomega leftboldsymbolkright^2 mathcalN mathrmd V_boldsymbolk - alpha_mathrms^2 N^4right\n\nwhere alpha_mathrms is a saturation coefficient that accounts for uncertainties of the criterion (Boeloeni et al., 2016; Boeloeni et al., 2021).","category":"section"},{"location":"theory/physics/#Rayleigh-damping","page":"Physics","title":"Rayleigh damping","text":"The Rayleigh damping in the LHS sponge introduced above is represented by the sink\n\nmathcalS_mathrmR = - 2 alpha_mathrmR mathcalN\n\nin the phase-space-wave-action-density equation (Jochum et al., 2025).","category":"section"},{"location":"theory/physics/#1D-transient-theory","page":"Physics","title":"1D transient theory","text":"The 3D transient theory can be reduced to a 1D transient one by removing all horizontal derivatives (in a Cartesian sense) and setting the horizontal components of the group velocity to zero. The eikonal equations then become\n\nbeginalign*\n    dotomega  = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatzright) omega = fracpartial Omegapartial t\n    dotm  = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatzright) m = J^- 1 fracpartial Omegapartial widehatz\nendalign*\n\nand are integrated along rays defined by the vertical group velocity\n\ndotz = c_mathrmg z = fracpartial Omegapartial m\n\nThe phase-space wave-action density equation is reduced to\n\ndotmathcalN = left(fracpartialpartial t + fracc_mathrmg zJ fracpartialpartial widehatz + dotm fracpartialpartial mright) mathcalN = sumlimits_s mathcalS_s\n\nand integrated along rays defined by left(dotz dotmright)^mathrmT. Finally, the impact on the resolved flow becomes\n\nbeginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmbJ overlinerho fracpartialpartial widehatz left(overlinerho leftlangle u w rightrangleright) - rho_mathrmb fracfoverlinetheta leftlangle theta v rightrangle\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmbJ overlinerho fracpartialpartial widehatz left(overlinerho leftlangle v w rightrangleright) + rho_mathrmb fracfoverlinetheta leftlangle theta u rightrangle\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = 0\nendalign*\n\n(e.g. Boeloeni et al., 2016; Boeloeni et al., 2021).","category":"section"},{"location":"theory/physics/#1D-steady-state-theory","page":"Physics","title":"1D steady-state theory","text":"In the 1D steady-state theory, the phase-space-wave-action-density equation from the previous section is integrated over spectral space, the temporal derivative is removed and the quasilinear approximation is used to express the result in terms of the physical-space wave-action densities of individual spectral modes (mathcalA_alpha). This yields\n\nJ^- 1 fracpartialpartial widehatz left(c_mathrmg z alpha mathcalA_alpharight) = sumlimits_s mathcalQ_s alpha\n\nwhere mathcalN = sum_alpha mathcalA_alpha delta left(boldsymbolk - boldsymbolk_alpharight) and mathcalS_s = sum_alpha mathcalQ_s alpha delta left(boldsymbolk - boldsymbolk_alpharight). Similarly, the eikonal equations become\n\nbeginalign*\n    fracc_mathrmg z alphaJ fracpartial omega_alphapartial widehatz  = 0\n    fracc_mathrmg z alphaJ fracpartial m_alphapartial widehatz  = J^- 1 fracpartial Omegapartial widehatz\nendalign*\n\nThus, the intrinsic frequency and vertical wavenumber can be determined from\n\nbeginalign*\n    widehatomega_alpha  = omega_alpha - boldsymbolk_alpha cdot boldsymbolu_mathrmb\n    m_alpha  = - mathrmsgn left(widehatomega_alpharight) sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2\nendalign*\n\nwhere omega_alpha is a constant. Since the wave-action-density equation is solved by vertical integration, the saturation scheme must be amended. Specifically, the saturation sink term mathcalQ_mathrms alpha is integrated over a pseudo-time step J Delta widehatz  c_mathrmg z alpha. Therein, the turbulent viscosity and diffusivity is given by\n\nK = fracoverlinerho4 leftsumlimits_alpha fracJ Delta widehatzc_mathrmg z alpha N^4 left(k_alpha^2 + l_alpha^2right) m_alpha^2 fracmathcalA_alphawidehatomega_alpharight^- 1 max left0 frac2overlinerho sumlimits_alpha fracN^4 left(k_alpha^2 + l_alpha^2right) m_alpha^2widehatomega_alpha leftboldsymbolk_alpharight^2 mathcalA_alpha - alpha_mathrms^2 N^4right\n\n(see Boeloeni et al., 2021; Jochum et al., 2025).","category":"section"},{"location":"theory/physics/#Orographic-source","page":"Physics","title":"Orographic source","text":"The orographic source is a lower-boundary condition for the wave-property fields. Its formulation uses the decomposition\n\nh left(x yright) = h_mathrmb + sumlimits_alpha Re lefth_mathrmw alpha exp lefti varphi_alpha left(x yright)rightright\n\nof the surface topography h, where h_mathrmb and h_mathrmw vary slowly in x and y, as opposed to the quickly varying orographic phase varphi_alpha. By inserting this and the WKB ansatz for the wind into the no-normal-flow condition\n\n0 = boldsymbolu cdot boldsymboln = - u fracpartial hpartial x - v fracpartial hpartial y + w qquad mathrmat quad z = h\n\none obtains\n\nmathcalN = fracoverlinerho2 sumlimits_alpha fracwidehatomega_alpha leftboldsymbolk_alpharight^2k_alpha^2 + l_alpha^2 lefth_mathrmw alpharight^2 delta left(boldsymbolk - boldsymbolk_alpharight) qquad mathrmat quad z = h_mathrmb\n\nThe vertical wavenumber at the source is\n\nm_alpha = - mathrmsgn left(widehatomega_alpharight) sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2\n\n(see Jochum et al., 2025).","category":"section"},{"location":"theory/physics/#Tracer-fluxes","page":"Physics","title":"Tracer fluxes","text":"The leading-order tracer fluxes due to unresolved gravity waves are given by\n\nbeginalign*\n    overlinerho leftlangle chi boldsymbolu rightrangle  = f int fracmwidehatomega leftboldsymbolkright^2 boldsymbolk times beginpmatrix\n        partial_widehatx chi_mathrmb + G^13 partial_widehatz chi_mathrmb\n        partial_widehaty chi_mathrmb + G^23 partial_widehatz chi_mathrmb\n        J^- 1 partial_widehatz chi_mathrmb\n    endpmatrix mathcalN  mathrmd V_boldsymbolk\nendalign*\n\nand the corresponding impact on the large-scale tracer is\n\nbeginalign*\n    left(fracpartial rho_mathrmb chi_mathrmbpartial tright)_mathrmw = - fracrho_mathrmboverlinerho beginpmatrix\n        partial_widehatx + G^13 partial_widehatz\n        partial_widehaty + G^23 partial_widehatz\n        J^- 1 partial_widehatz\n    endpmatrix cdot left(overlinerho leftlangle chi boldsymbolu rightrangleright)\nendalign*","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Cold-bubble","page":"Examples","title":"Cold bubble","text":"The script\n\n# examples/scripts/cold_bubble.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpz = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\n\nlx = 20000.0\nlz = 20000.0\n\nrx = lx / 8\nrz = lz / 8\n\natmosphere = AtmosphereNamelist(;\n    background = Isentropic(),\n    initial_rhop = (x, y, z) -> begin\n        r = sqrt((x / rx)^2 + ((z - 3 * rz) / rz)^2)\n        if r <= 1\n            return 0.005 * (1 + cos(pi * r))\n        else\n            return 0.0\n        end\n    end,\n)\ndiscretization = DiscretizationNamelist(; dtmax = 60.0)\ndomain = DomainNamelist(; x_size = 40, z_size = 40, lx, lz, npx, npz)\noutput = OutputNamelist(;\n    output_variables = (:thetap,),\n    output_file = \"cold_bubble.h5\",\n)\n\nintegrate(Namelists(; atmosphere, discretization, domain, output))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"cold_bubble.h5\") do data\n        plot_output(\n            \"examples/results/cold_bubble.svg\",\n            data,\n            (\"thetap\", 1, 1, 1, 2);\n        )\n        return\n    end\nend\n\n\nsimulates a cold bubble in a 2D pseudo-incompressible isentropic atmosphere and visualizes the potential-temperature fluctuations after one hour integration time (see below).\n\n(Image: )","category":"section"},{"location":"examples/#Hot-bubble","page":"Examples","title":"Hot bubble","text":"The script\n\n# examples/scripts/hot_bubble.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpz = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\n\nlx = 20000.0\nlz = 20000.0\n\nrx = lx / 8\nrz = lz / 8\n\natmosphere = AtmosphereNamelist(;\n    model = Compressible(),\n    background = Isentropic(),\n    initial_rhop = (x, y, z) -> begin\n        r = sqrt((x / rx)^2 + ((z - 5 * rz) / rz)^2)\n        if r <= 1\n            return -0.005 * (1 + cos(pi * r))\n        else\n            return 0.0\n        end\n    end,\n)\ndiscretization = DiscretizationNamelist(; dtmax = 60.0)\ndomain = DomainNamelist(; x_size = 40, z_size = 40, lx, lz, npx, npz)\noutput = OutputNamelist(;\n    output_variables = (:thetap,),\n    output_file = \"hot_bubble.h5\",\n)\n\nintegrate(Namelists(; atmosphere, discretization, domain, output))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"hot_bubble.h5\") do data\n        plot_output(\n            \"examples/results/hot_bubble.svg\",\n            data,\n            (\"thetap\", 1, 1, 1, 2);\n        )\n        return\n    end\nend\n\n\nsimulates a hot bubble in a 2D compressible isentropic atmosphere and visualizes the potential-temperature fluctuations after one hour integration time (see below).\n\n(Image: )","category":"section"},{"location":"examples/#Mountain-wave","page":"Examples","title":"Mountain wave","text":"The script\n\n# examples/scripts/mountain_wave.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpy = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\nnpz = length(ARGS) >= 3 ? parse(Int, ARGS[3]) : 1\n\nh0 = 100.0\nl0 = 1000.0\n\nlx = 20000.0\nly = 20000.0\nlz = 20000.0\ndxr = lx / 2\ndyr = ly / 2\ndzr = lz / 2\nalpharmax = 0.0179\n\natmosphere = AtmosphereNamelist(;\n    coriolis_frequency = 0.0,\n    initial_u = (x, y, z) -> 10.0,\n)\ndomain = DomainNamelist(;\n    x_size = 40,\n    y_size = 40,\n    z_size = 40,\n    lx,\n    ly,\n    lz,\n    npx,\n    npy,\n    npz,\n)\ngrid = GridNamelist(;\n    resolved_topography = (x, y) -> h0 / (1 + (x^2 + y^2) / l0^2),\n)\noutput =\n    OutputNamelist(; output_variables = (:w,), output_file = \"mountain_wave.h5\")\nsponge = SpongeNamelist(;\n    lhs_sponge = (x, y, z, t, dt) -> begin\n        alpharx =\n            abs(x) >= (lx - dxr) / 2 ?\n            sin(pi * (abs(x) - (lx - dxr) / 2) / dxr)^2 : 0.0\n        alphary =\n            abs(y) >= (ly - dyr) / 2 ?\n            sin(pi * (abs(y) - (ly - dyr) / 2) / dyr)^2 : 0.0\n        alpharz =\n            z >= lz - dzr ? sin(pi / 2 * (z - (lz - dzr)) / dzr)^2 : 0.0\n        return alpharmax * (alpharx + alphary + alpharz) / 3\n    end,\n    relaxed_u = (x, y, z, t, dt) -> 10.0,\n)\n\nintegrate(Namelists(; atmosphere, domain, grid, output, sponge))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"mountain_wave.h5\") do data\n        plot_output(\n            \"examples/results/mountain_wave.svg\",\n            data,\n            (\"w\", 20, 20, 10, 2);\n        )\n        return\n    end\nend\n\n\nperforms a 3D mountain-wave simulation. The surface topography is given by\n\nh left(x yright) = frach_01 + left(x^2 + y^2right)  l_0^2\n\nwith h_0 = 100  mathrmm and l_0 = 1  mathrmkm. The atmosphere is isothermal, with the default temperature T_0 = 300  mathrmK and the initial wind boldsymbolu_0 = left(10 0 0right)^mathrmT  mathrmm  s^- 1.\n\nReflections at the upper boundary are prevented by damping the generated mountain waves in a sponge defined by\n\nalpha_mathrmR left(x y zright) = alpha_mathrmR max fracalpha_mathrmR x left(xright) + alpha_mathrmR y left(yright) + alpha_mathrmR z left(zright)3\n\nwith\n\nbeginalign*\n    alpha_mathrmR x left(xright)  = begincases\n        sin^2 leftpi fracleftxright - left(L_x - Delta x_mathrmRright)  2Delta x_mathrmRright  mathrmif quad leftxright geq frac12 left(L_x - Delta x_mathrmRright)\n        0  mathrmelse\n    endcases\n    alpha_mathrmR y left(yright)  = begincases\n        sin^2 leftpi fracleftyright - left(L_y - Delta y_mathrmRright)  2Delta y_mathrmRright  mathrmif quad leftyright geq frac12 left(L_y - Delta y_mathrmRright)\n        0  mathrmelse\n    endcases\n    alpha_mathrmR z left(zright)  = begincases\n        sin^2 leftfracpi2 fracz - left(L_z - Delta z_mathrmRright)Delta z_mathrmRright  mathrmif quad z geq L_z - Delta z_mathrmR\n        0  mathrmelse\n    endcases\nendalign*\n\nwhere alpha_mathrmR max = 00179  mathrms^- 1, Delta x_mathrmR = L_x  2, Delta y_mathrmR = L_y  2 and Delta z_mathrmR = L_z  2. This sponge not only prevents wave reflections at the model top but also provides a damping at the horizontal boundaries. Moreover, it is configured such that the wind is relaxed towards its initial state, so that (in the ideal case) the periodicity in x and y is effectively eliminated by enforcing a constant wind at the domain edges.\n\nAfter the simulation has finished, the vertical wind is visualized in three cross sections of the domain (see below).\n\n(Image: )","category":"section"},{"location":"examples/#Vortex","page":"Examples","title":"Vortex","text":"The script\n\n# examples/scripts/vortex.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpy = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\n\nlx = 20000.0\nly = 20000.0\n\nrx = lx / 4\nry = ly / 4\n\natmosphere = AtmosphereNamelist(;\n    model = Boussinesq(),\n    background = NeutralStratification(),\n    initial_u = (x, y, z) -> begin\n        r = sqrt((x / rx)^2 + (y / ry)^2)\n        if r <= 1\n            return -5 * y / ry * (1 + cos(pi * r)) / 2\n        else\n            return 0.0\n        end\n    end,\n    initial_v = (x, y, z) -> begin\n        r = sqrt((x / rx)^2 + (y / ry)^2)\n        if r <= 1\n            return 5 * x / rx * (1 + cos(pi * r)) / 2\n        else\n            return 0.0\n        end\n    end,\n)\ndomain = DomainNamelist(; x_size = 40, y_size = 40, lx, ly, npx, npy)\noutput = OutputNamelist(;\n    output_variables = (:chi, :u, :v),\n    output_file = \"vortex.h5\",\n)\ntracer = TracerNamelist(;\n    tracer_setup = TracerOn(),\n    initial_tracer = (x, y, z) -> begin\n        r = sqrt(((abs(x) - rx) / rx)^2 + (y / ry)^2)\n        if r <= 1\n            return sign(x) * (1 + cos(pi * r)) / 2\n        else\n            return 0.0\n        end\n    end,\n)\n\nintegrate(Namelists(; atmosphere, domain, output, tracer))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"vortex.h5\") do data\n        plot_output(\"examples/results/vortex.svg\", data, (\"chi\", 1, 1, 1, 2);)\n        return\n    end\nend\n\n\ninitializes two tracer disks and a vortex in a 2D horizontal Boussinesq atmosphere, integrates over one hour and visualizes the resulting tracer distribution (see below).\n\n(Image: )","category":"section"},{"location":"examples/#Wave-packet","page":"Examples","title":"Wave packet","text":"The script\n\n# examples/scripts/wave_packet.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpy = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\nnpz = length(ARGS) >= 3 ? parse(Int, ARGS[3]) : 1\n\nx_size = 40\ny_size = 40\nz_size = 80\n\nlx = 20000.0\nly = 20000.0\nlz = 40000.0\n\nrx = 0.25\nry = 0.25\nrz = 0.25\n\nx0 = 0.0\ny0 = 0.0\nz0 = 20000.0\n\na0 = 0.05\n\nk = 16 * pi / lx\nl = 16 * pi / ly\nm = 32 * pi / lz\n\nbackground = Realistic()\ncoriolis_frequency = 0.0001\n\natmosphere = AtmosphereNamelist(; background, coriolis_frequency)\ndomain = DomainNamelist(; x_size, y_size, z_size, lx, ly, lz, npx, npy, npz)\nauxiliary_state = State(Namelists(; atmosphere, domain))\n(; g, kappa, rsp, lref, tref, rhoref, thetaref) = auxiliary_state.constants\n\ninclude(\"wave_packet_tools.jl\")\n\natmosphere = AtmosphereNamelist(;\n    background,\n    coriolis_frequency,\n    initial_rhop = (x, y, z) ->\n        rhobar(x, y, z) *\n        (1 / (1 + real(bhat(x, y, z) * exp(1im * phi(x, y, z))) / g) - 1),\n    initial_u = (x, y, z) -> real(uhat(x, y, z) * exp(1im * phi(x, y, z))),\n    initial_v = (x, y, z) -> real(vhat(x, y, z) * exp(1im * phi(x, y, z))),\n    initial_w = (x, y, z) -> real(what(x, y, z) * exp(1im * phi(x, y, z))),\n    initial_pip = (x, y, z) ->\n        real(pihat(x, y, z) * exp(1im * phi(x, y, z))),\n)\noutput = OutputNamelist(;\n    output_variables = (:u, :v, :w),\n    output_file = \"wave_packet.h5\",\n    tmax = 900.0,\n    output_interval = 900.0,\n)\n\nintegrate(Namelists(; atmosphere, domain, output))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"wave_packet.h5\") do data\n        plot_output(\n            \"examples/results/wave_packet.svg\",\n            data,\n            (\"u\", 20, 20, 40, 2),\n            (\"v\", 20, 20, 40, 2),\n            (\"w\", 20, 20, 40, 2);\n            time_unit = \"min\",\n        )\n        return\n    end\nend\n\n\ninitializes a resolved gravity-wave packet in the stratosphere of a \"realistic\" atmosphere (isentropic troposphere and isothermal stratosphere) and visualizes the resulting wind after fifteen minutes integration time (see below). For the relatively complex initialization, this script first constructs an auxiliary state that contains the necessary background fields and then uses helper functions that implement the gravity-wave dispersion and polarization relations (included in a separate section below).\n\n(Image: )","category":"section"},{"location":"examples/#WKB-mountain-wave","page":"Examples","title":"WKB mountain wave","text":"The script\n\n# examples/scripts/wkb_mountain_wave.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpy = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\nnpz = length(ARGS) >= 3 ? parse(Int, ARGS[3]) : 1\n\nh0 = 150.0\nl0 = 5000.0\nrl = 10\nrh = 2\n\nlx = 400000.0\nly = 400000.0\nlz = 20000.0\ndxr = lx / 20\ndyr = ly / 20\ndzr = lz / 10\nalpharmax = 0.0179\n\natmosphere = AtmosphereNamelist(;\n    coriolis_frequency = 0.0,\n    initial_u = (x, y, z) -> 10.0,\n)\ndomain = DomainNamelist(;\n    x_size = 40,\n    y_size = 40,\n    z_size = 40,\n    lx,\n    ly,\n    lz,\n    npx,\n    npy,\n    npz,\n)\ngrid = GridNamelist(;\n    resolved_topography = (x, y) ->\n        x^2 + y^2 <= (rl * l0)^2 ?\n        h0 / 2 * (1 + cos(pi / (rl * l0) * sqrt(x^2 + y^2))) * rh / (rh + 1) : 0.0,\n    unresolved_topography = (alpha, x, y) ->\n        x^2 + y^2 <= (rl * l0)^2 ?\n        (\n            pi / l0,\n            0.0,\n            h0 / 2 * (1 + cos(pi / (rl * l0) * sqrt(x^2 + y^2))) / (rh + 1),\n        ) : (0.0, 0.0, 0.0),\n)\noutput = OutputNamelist(;\n    save_ray_volumes = true,\n    output_file = \"wkb_mountain_wave.h5\",\n)\nsponge = SpongeNamelist(;\n    lhs_sponge = (x, y, z, t, dt) ->\n        alpharmax / 3 * (\n            exp((abs(x) - lx / 2) / dxr) +\n            exp((abs(y) - ly / 2) / dyr) +\n            exp((z - lz) / dzr)\n        ),\n    relaxed_u = (x, y, z, t, dt) -> 10.0,\n)\nwkb = WKBNamelist(; wkb_mode = MultiColumn())\n\nintegrate(Namelists(; atmosphere, domain, grid, output, sponge, wkb))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"wkb_mountain_wave.h5\") do data\n        plot_output(\n            \"examples/results/wkb_mountain_wave.svg\",\n            data,\n            (\"nr\", 20, 20, 10, 2);\n        )\n        return\n    end\nend\n\n\nperforms a 3D WKB mountain-wave simulation. The full surface topography is given by\n\nbeginalign*\n    h left(x yright)  = begincases\n        frach_02 left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right leftr_h + cos left(fracpi xl_0right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\nendalign*\n\nwhere h_0 = 150  mathrmm, l_0 = 5  mathrmkm, r_h = 2, and r_l = 10. This is decomposed into a large-scale part h_mathrmb and a small-scale part with the spectral amplitude h_mathrmw, such that\n\nbeginalign*\n    h_mathrmb left(x yright)  = r_h h_mathrmw left(x yright)\n    h_mathrmw left(x yright)  = begincases\n        frach_02 left(r_h + 1right) left1 + cos left(fracpir_l l_0 sqrtx^2 + y^2right)right  mathrmif quad x^2 + y^2 leq r_l^2 l_0^2\n        0  mathrmelse\n    endcases\nendalign*\n\nThe large-scale part is resolved, so that the grid is defined from it, whereas the small-scale part is used by MS-GWaM to parameterize the mountain waves generated by the resolved wind crossing it. As in the first mountain-wave example, the atmosphere is isothermal, with the default temperature T_0 = 300  mathrmK and the initial wind boldsymbolu_0 = left(10 0 0right)^mathrmT  mathrmm  s^- 1.\n\nThe damping coefficient of the sponge is given by\n\nalpha_mathrmR left(x y zright) = fracalpha_mathrmR max3 leftexp left(fracleftxright - L_x  2Delta x_mathrmRright) + exp left(fracleftyright - L_y  2Delta y_mathrmRright) + exp left(fracz - L_zDelta z_mathrmRright)right\n\nwhere alpha_mathrmR max = 00179  mathrms^- 1, Delta x_mathrmR = L_x  20, Delta y_mathrmR = L_y  20 and Delta z_mathrmR = L_z  10. In contrast to the sinusoidal sponge discussed in the first example, this sponge applies a damping everywhere in the domain (weakest at the center of the surface, strongest in the upper corners). Once again, the sponge relaxes the wind to its initial state.\n\nMS-GWaM is used with most of its parameters set to their default values. This means that the orographic source launches exactly one ray volume in each surface grid cell with a nonzero h_mathrmw. Thus, the number of ray volumes allowed per grid cell (before merging is triggered) is multiplication_factor (a parameter of the WKB namelist) cubed, which is 4^3 = 64.\n\nInstead of a contour plot, the above script generates a scatter plot that visualizes the ray volumes, with the color representing the value of the phase-space wave-action density (see below).\n\n(Image: )","category":"section"},{"location":"examples/#WKB-wave-packet","page":"Examples","title":"WKB wave packet","text":"The script\n\n# examples/scripts/wkb_wave_packet.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpy = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\nnpz = length(ARGS) >= 3 ? parse(Int, ARGS[3]) : 1\n\nx_size = 16\ny_size = 16\nz_size = 32\n\nlx = 20000.0\nly = 20000.0\nlz = 40000.0\n\nrx = 0.25\nry = 0.25\nrz = 0.25\n\nx0 = 0.0\ny0 = 0.0\nz0 = 20000.0\n\na0 = 0.05\n\nk = 16 * pi / lx\nl = 16 * pi / ly\nm = 32 * pi / lz\n\nmodel = Compressible()\nbackground = Realistic()\ncoriolis_frequency = 0.0001\n\natmosphere = AtmosphereNamelist(; background, model, coriolis_frequency)\ndomain = DomainNamelist(; x_size, y_size, z_size, lx, ly, lz, npx, npy, npz)\nauxiliary_state = State(Namelists(; atmosphere, domain))\n(; g, kappa, rsp, lref, tref, rhoref, thetaref) = auxiliary_state.constants\n\ninclude(\"wave_packet_tools.jl\")\n\natmosphere = AtmosphereNamelist(; background, model, coriolis_frequency)\noutput = OutputNamelist(;\n    save_ray_volumes = true,\n    output_file = \"wkb_wave_packet.h5\",\n    tmax = 900.0,\n    output_interval = 900.0,\n)\nwkb = WKBNamelist(;\n    wkb_mode = MultiColumn(),\n    initial_wave_field = (alpha, x, y, z) ->\n        (k, l, m, omega(x, y, z), wave_action_density(x, y, z)),\n)\n\nintegrate(Namelists(; atmosphere, domain, output, wkb))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"wkb_wave_packet.h5\") do data\n        plot_output(\n            \"examples/results/wkb_wave_packet.svg\",\n            data,\n            (\"nr\", 8, 8, 16, 2);\n            time_unit = \"min\",\n        )\n        return\n    end\nend\n\n\ninitializes an unresolved gravity-wave packet (i.e. one that is parameterized by MS-GWaM) in the stratosphere of a \"realistic\" compressible atmosphere (isentropic troposphere and isothermal stratosphere) and visualizes the resulting ray-volume distribution after fifteen minutes integration time (see below). Like the wave-packet script discussed above, it constructs an auxiliary state and uses helper functions to satisfy the gravity-wave dispersion and polarization relations.\n\n(Image: )","category":"section"},{"location":"examples/#Wave-packet-helper-functions","page":"Examples","title":"Wave-packet helper functions","text":"The script\n\n# examples/scripts/wave_packet_tools.jl\n\nfunction ijk(x, y, z)\n    i = argmin(abs.(x .- auxiliary_state.grid.x .* lref))\n    j = argmin(abs.(y .- auxiliary_state.grid.y .* lref))\n    k = argmin(abs.(z .- auxiliary_state.grid.zc[i, j, :] .* lref))\n\n    return CartesianIndex(i, j, k)\nend\n\nfunction rhobar(x, y, z)\n    return auxiliary_state.atmosphere.rhobar[ijk(x, y, z)] .* rhoref\nend\n\nfunction thetabar(x, y, z)\n    return auxiliary_state.atmosphere.thetabar[ijk(x, y, z)] .* thetaref\nend\n\nfunction n2(x, y, z)\n    return auxiliary_state.atmosphere.n2[ijk(x, y, z)] ./ tref .^ 2\nend\n\nfunction envelope(x, y, z)\n    r =\n        sqrt(\n            (rx * k * (x - x0))^2 +\n            (ry * l * (y - y0))^2 +\n            (rz * m * (z - z0))^2,\n        ) / pi\n    if r <= 1\n        return (1 + cos(pi * r)) / 2\n    else\n        return 0.0\n    end\nend\n\nfunction phi(x, y, z)\n    return k * x + l * y + m * z\nend\n\nfunction omega(x, y, z)\n    return -sqrt(\n        (n2(x, y, z) * (k^2 + l^2) + coriolis_frequency^2 * m^2) /\n        (k^2 + l^2 + m^2),\n    )\nend\n\nfunction bhat(x, y, z)\n    return a0 * n2(x, y, z) / m * envelope(x, y, z)\nend\n\nfunction uhat(x, y, z)\n    return n2(x, y, z) == 0.0 ? 0.0 :\n           1im / m / n2(x, y, z) * (omega(x, y, z)^2 - n2(x, y, z)) /\n           (omega(x, y, z)^2 - coriolis_frequency^2) *\n           (k * omega(x, y, z) + 1im * l * coriolis_frequency) *\n           bhat(x, y, z)\nend\n\nfunction vhat(x, y, z)\n    return n2(x, y, z) == 0.0 ? 0.0 :\n           1im / m / n2(x, y, z) * (omega(x, y, z)^2 - n2(x, y, z)) /\n           (omega(x, y, z)^2 - coriolis_frequency^2) *\n           (l * omega(x, y, z) - 1im * k * coriolis_frequency) *\n           bhat(x, y, z)\nend\n\nfunction what(x, y, z)\n    return n2(x, y, z) == 0.0 ? 0.0 :\n           1im * omega(x, y, z) / n2(x, y, z) * bhat(x, y, z)\nend\n\nfunction pihat(x, y, z)\n    return n2(x, y, z) == 0.0 ? 0.0 :\n           kappa / rsp / thetabar(x, y, z) * 1im / m *\n           (omega(x, y, z)^2 - n2(x, y, z)) / n2(x, y, z) * bhat(x, y, z)\nend\n\nfunction wave_action_density(x, y, z)\n    return n2(x, y, z) == 0.0 ? 0.0 :\n           rhobar(x, y, z) / 2 * omega(x, y, z) * (k^2 + l^2 + m^2) /\n           n2(x, y, z)^2 / (k^2 + l^2) * bhat(x, y, z)^2\nend\n\n\nprovides helper functions that implement the gravity-wave dispersion and polarization relations needed for the initialization of wave packets. It is to be included below the construction of a corresponding auxiliary state and the extraction of kappa = R  c_p, R and g from its Constants instance.","category":"section"},{"location":"reference/msgwam/#MSGWaM","page":"MSGWaM","title":"MSGWaM","text":"","category":"section"},{"location":"reference/msgwam/#Interpolation","page":"MSGWaM","title":"Interpolation","text":"","category":"section"},{"location":"reference/msgwam/#RayOperations","page":"MSGWaM","title":"RayOperations","text":"","category":"section"},{"location":"reference/msgwam/#RaySources","page":"MSGWaM","title":"RaySources","text":"","category":"section"},{"location":"reference/msgwam/#BoundaryRays","page":"MSGWaM","title":"BoundaryRays","text":"","category":"section"},{"location":"reference/msgwam/#RayUpdate","page":"MSGWaM","title":"RayUpdate","text":"","category":"section"},{"location":"reference/msgwam/#MeanFlowEffect","page":"MSGWaM","title":"MeanFlowEffect","text":"","category":"section"},{"location":"reference/msgwam/#PinCFlow.MSGWaM","page":"MSGWaM","title":"PinCFlow.MSGWaM","text":"MSGWaM\n\n3D transient implementation of MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays\nPinCFlow.MSGWaM.RayUpdate\nPinCFlow.MSGWaM.MeanFlowEffect\n\nExternal links\n\nMuraschko et al. (2014)\nBoeloeni et al. (2016)\nWilhelm et al. (2018)\nWei et al. (2019)\nJochum et al. (2025)\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation","text":"Interpolation\n\nModule for interpolating mean-flow quantities to ray-volume positions.\n\nProvides functions that find the grid points closest to a given ray-volume position and perform trilinear interpolation of mean-flow quantities.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Update\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDX","text":"DChiDX\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDY","text":"DChiDY\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DChiDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DChiDZ","text":"DChiDZ\n\nSingleton for dispatch to interpolation of partial chi_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DN2DZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DN2DZ","text":"DN2DZ\n\nSingleton for dispatch to interpolation of partial N^2  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDX","text":"DUDX\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDY","text":"DUDY\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DUDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DUDZ","text":"DUDZ\n\nSingleton for dispatch to interpolation of partial u_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDX","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDX","text":"DVDX\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial x.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDY","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDY","text":"DVDY\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial y.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.DVDZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.DVDZ","text":"DVDZ\n\nSingleton for dispatch to interpolation of partial v_mathrmb  partial z.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.N2","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.N2","text":"N2\n\nSingleton for dispatch to interpolation of N^2.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.compute_derivatives","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.compute_derivatives","text":"compute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the zonal wind (partial u_mathrmb  partial x) at left(i j k_mathrmDright) and left(i j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial u_mathrmbpartial xright) = fracu_mathrmb i + 1  2 - u_mathrmb i - 1  2Delta widehatx + G^13 fracu_mathrmb k + 1 - u_mathrmb k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the zonal wind (partial u_mathrmb  partial y) at left(i + 1  2 j + 1  2 k_mathrmDright) and left(i + 1  2 j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nbeginalign*\n    left(fracpartial u_mathrmbpartial yright)_i + 1  2 j + 1  2  = fracu_mathrmb i + 1  2 j + 1 - u_mathrmb i + 1  2Delta widehaty + G_i + 1  2 j + 1  2^23 fracu_mathrmb i + 1  2 j + 1  2 k + 1 - u_mathrmb i + 1  2 j + 1  2 k - 12 Delta widehatz\nendalign*\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DUDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the zonal wind (partial u_mathrmb  partial z) at left(i + 1  2 j k_mathrmD + 1  2right) and left(i + 1  2 j k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial u_mathrmbpartial zright)_i + 1  2 k + 1  2 = fracu_mathrmb i + 1  2 k + 1 - u_mathrmb i + 1  2J_i + 1  2 k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the meridional wind (partial v_mathrmb  partial x) at left(i + 1  2 j + 1  2 k_mathrmDright) and left(i + 1  2 j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial xright)_i + 1  2 j + 1  2 = fracv_mathrmb i + 1 j + 1  2 - v_mathrmb j + 1  2Delta widehatx + G_i + 1  2 j + 1  2^13 fracv_mathrmb i + 1  2 j + 1  2 k + 1 - v_mathrmb i + 1  2 j + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the meridional wind (partial v_mathrmb  partial y) at left(i j k_mathrmDright) and left(i j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial yright) = fracv_mathrmb j + 1  2 - v_mathrmb j - 1  2Delta widehaty + G^23 fracv_mathrmb k + 1 - v_mathrmb k - 1 2 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DVDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the meridional wind (partial v_mathrmb  partial z) at left(i j + 1  2 k_mathrmD + 1  2right) and left(i j + 1  2 k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial v_mathrmbpartial zright)_j + 1  2 k + 1  2 = fracv_mathrmb j + 1  2 k + 1 - v_mathrmb j + 1  2J_j + 1  2 k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDX,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the zonal derivative of the tracer field (partial chi_mathrmb  partial x) at left(i + 1  2 j k_mathrmDright) and left(i + 1  2 j k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial xright)_i + 1  2 = fracchi_mathrmb i + 1 - chi_mathrmbDelta widehatx + G_i + 1  2^13 fracchi_mathrmb i + 1  2 k + 1 - chi_mathrmb i + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDY,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the meridional derivative of the tracer field (partial chi_mathrmb  partial y) at left(i j + 1  2 k_mathrmDright) and left(i j + 1  2 k_mathrmUright).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial yright)_j + 1  2 = fracchi_mathrmb j + 1 - chi_mathrmbDelta widehaty + G_j + 1  2^23 fracchi_mathrmb j + 1  2 k + 1 - chi_mathrmb j + 1  2 k - 12 Delta widehatz\n\ncompute_derivatives(\n    state::State,\n    i::Integer,\n    j::Integer,\n    kd::Integer,\n    ku::Integer,\n    phitype::DChiDZ,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the vertical derivative of the tracer field (partial chi_mathrmb  partial z) at left(i j k_mathrmD + 1  2right) and left(i j k_mathrmU + 1  2right).\n\nThe derivative is given by\n\nleft(fracpartial chi_mathrmbpartial zright)_k + 1  2 = fracchi_mathrmb k + 1 - chi_mathrmbJ_k + 1  2 Delta widehatz\n\nAt grid points beyond the vertical boundaries, it is set to zero.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nkd: Lower vertical grid-cell index.\nku: Upper vertical grid-cell index.\nphitype: Type of derivative to compute.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.get_next_half_level","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.get_next_half_level","text":"get_next_half_level(\n    i::Integer,\n    j::Integer,\n    z::AbstractFloat,\n    state::State;\n    dkd::Integer = 0,\n    dku::Integer = 0,\n)::Integer\n\nDetermine and return the index of the next half-level above z at the horizontal position left(i jright).\n\nThis method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.\n\nIn MPI processes at the lower boundary of the domain, the computed index has the lower bound state.domain.k0. In other processes, an error is thrown if it is below 1 + dkd.\nIn MPI processes at the upper boundary of the domain, the computed index has the upper bound state.domain.k1. In other processes, an error is thrown if it is above state.domain.nzz - dku.\n\nIn case an error is thrown, the parameter wkb_cfl_number of the discretization namelist should be set to a smaller value.\n\nArguments\n\ni: Zonal index.\nj: Meridional index.\nz: Vertical position.\nstate: Model state.\n\nKeywords\n\ndkd: Number of levels needed below.\ndku: Number of levels needed above.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.get_next_level","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.get_next_level","text":"get_next_level(\n    i::Integer,\n    j::Integer,\n    z::AbstractFloat,\n    state::State;\n    dkd::Integer = 0,\n    dku::Integer = 0,\n)::Integer\n\nDetermine and return the index of the next level above z at the horizontal position left(i jright).\n\nThis method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.\n\nIn MPI processes at the lower boundary of the domain, the computed index has the lower bound state.domain.k0. In other processes, an error is thrown if it is below 1 + dkd.\nIn MPI processes at the upper boundary of the domain, the computed index has the upper bound state.domain.k1 + 1. In other processes, an error is thrown if it is above state.domain.nzz - dku.\n\nIn case an error is thrown, the parameter wkb_cfl_number of the discretization namelist should be set to a smaller value.\n\nArguments\n\ni: Zonal index.\nj: Meridional index.\nz: Vertical position.\nstate: Model state.\n\nKeywords\n\ndkd: Number of levels needed below.\ndku: Number of levels needed above.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate","text":"interpolate(\n    state::State;\n    philbd::AbstractFloat = NaN,\n    philbu::AbstractFloat = NaN,\n    philfd::AbstractFloat = NaN,\n    philfu::AbstractFloat = NaN,\n    phirbd::AbstractFloat = NaN,\n    phirbu::AbstractFloat = NaN,\n    phirfd::AbstractFloat = NaN,\n    phirfu::AbstractFloat = NaN,\n    zlbd::AbstractFloat = NaN,\n    zlbu::AbstractFloat = NaN,\n    zlfd::AbstractFloat = NaN,\n    zlfu::AbstractFloat = NaN,\n    zrbd::AbstractFloat = NaN,\n    zrbu::AbstractFloat = NaN,\n    zrfd::AbstractFloat = NaN,\n    zrfu::AbstractFloat = NaN,\n    zlc::AbstractFloat = NaN,\n    yb::AbstractFloat = NaN,\n    yf::AbstractFloat = NaN,\n    ylc::AbstractFloat = NaN,\n    xl::AbstractFloat = NaN,\n    xr::AbstractFloat = NaN,\n    xlc::AbstractFloat = NaN,\n)::AbstractFloat\n\nPerform trilinear interpolation to (xlc, ylc, zlc), with values from eight surrounding grid points (two zonal positions, two meridional positions and eight vertical positions), and return the result.\n\nOut of the eight grid points, four each are assumed to be to the left, to the right, behind, in front of, below and above the location of interest. Due to the grid being terrain-following, this includes eight different vertical positions, but only two zonal and two meridional positions. This is handled by performing successive linear interpolations, where the vertical position is interpolated along with the field of interest.\n\nThe exact algorithm is as follows.\n\nInterpolation in x:\nbeginalign*\npsi_mathrmBD  = f_x psi_mathrmLBD + (1 - f_x) psi_mathrmRBD\npsi_mathrmBU  = f_x psi_mathrmLBU + (1 - f_x) psi_mathrmRBU\npsi_mathrmFD  = f_x psi_mathrmLFD + (1 - f_x) psi_mathrmRFD\npsi_mathrmFU  = f_x psi_mathrmLFU + (1 - f_x) psi_mathrmRFU\nendalign*\nInterpolation in y:\nbeginalign*\npsi_mathrmD  = f_y psi_mathrmBD + (1 - f_y) psi_mathrmFD\npsi_mathrmU  = f_y psi_mathrmBU + (1 - f_y) psi_mathrmFU\nendalign*\nInterpolation in z:\nphi_mathrmC = f_z phi_mathrmD + (1 - f_z) phi_mathrmU\n\nTherein, mathrmL, mathrmR, mathrmB, mathrmF, mathrmD and mathrmU denote grid points to the left, to the right, forward, backward, downward and upward of the location of interest (denoted by mathrmC), respectively, psi = left(phi zright) and\n\nf_alpha = begincases\n0  mathrmif quad alpha_beta = alpha_gamma\n1  mathrmif quad alpha_mathrmC  alpha_beta\nfracalpha_gamma - alpha_mathrmCalpha_gamma - alpha_beta  mathrmif quad alpha_beta leq alpha_mathrmC leq alpha_gamma\n0  mathrmif quad alpha_gamma  alpha_mathrmC\nendcases\n\nwhere left(alpha beta gammaright) in leftleft(x mathrmL mathrmRright) left(y mathrmB mathrmFright) left(z mathrmD mathrmUright)right.\n\nDue to their large number, the positions and values are given as keyword arguments with the default value NaN, so that their order does not matter and calls with missing arguments are easy to detect.\n\nArguments\n\nstate: Model state.\n\nKeywords\n\nphilbd: Value at the point to the left, behind and below.\nphilbu: Value at the point to the left, behind and above.\nphilfd: Value at the point to the left, in front and below.\nphilfu: Value at the point to the left, in front and above.\nphirbd: Value at the point to the right, behind and below.\nphirbu: Value at the point to the right, behind and above.\nphirfd: Value at the point to the right, in front and below.\nphirfu: Value at the point to the right, in front and above.\nzlbd: Vertical coordinate of the point to the left, behind and below.\nzlbu: Vertical coordinate of the point to the left, behind and above.\nzlfd: Vertical coordinate of the point to the left, in front and below.\nzlfu: Vertical coordinate of the point to the left, in front and above.\nzrbd: Vertical coordinate of the point to the right, behind and below.\nzrbu: Vertical coordinate of the point to the right, behind and above.\nzrfd: Vertical coordinate of the point to the right, in front and below.\nzrfu: Vertical coordinate of the point to the right, in front and above.\nzlc: Vertical position of interest.\nyb: Meridional coordinate of the points behind.\nyf: Meridional coordinate of the points in front.\nylc: Meridional position of interest.\nxl: Zonal coordinate of the points to the left.\nxr: Zonal coordinate of the points to the right.\nxlc: Zonal position of interest.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow","text":"interpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::U,\n)::AbstractFloat\n\nInterpolate the zonal wind (u_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate u_mathrmb to the location of interest, using interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::V,\n)::AbstractFloat\n\nInterpolate the meridional wind (v_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the zonal wind (u_mathrmb).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::W,\n)::AbstractFloat\n\nInterpolate the vertical wind (w_mathrmb) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate w_mathrmb to the location of interest, using compute_vertical_wind and interpolate. At grid points beyond the vertical boundaries, the values used in the interpolation are replaced with zeros.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the zonal wind (partial u_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial x to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the zonal wind (partial u_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial y to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DUDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the zonal wind (partial u_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate partial u_mathrmb  partial z to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the meridional wind (partial v_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the meridional derivative of the zonal wind (partial u_mathrmb  partial y).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the meridional wind (partial v_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the zonal derivative of the zonal wind (partial u_mathrmb  partial x).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DVDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the meridional wind (partial v_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. The steps that follow are analogous to those in the method for the vertical derivative of the zonal wind (partial u_mathrmb  partial z).\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDX,\n)::AbstractFloat\n\nInterpolate the zonal derivative of the tracer mixing ratio (partial chi_mathrmb  partial x) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx + Delta widehatx  2 and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial x to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDY,\n)::AbstractFloat\n\nInterpolate the meridional derivative of the tracer mixing ratio (partial chi_mathrmb  partial y) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty + Delta widehaty  2 that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial y to the location of interest, using compute_derivatives and interpolate.\n\ninterpolate_mean_flow(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n    phitype::DChiDZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the tracer mixing ratio (partial chi_mathrmb  partial z) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z + J Delta widehatz  2 that are closest to zlc. The resulting eight grid points are used to interpolate partial chi_mathrmb  partial z to the location of interest, using compute_derivatives and interpolate.\n\nArguments\n\nxlc: Zonal position of interest.\nylc: Meridional position of interest.\nzlc: Vertical position of interest.\nstate: Model state.\nphitype: Mean-flow quantity to interpolate.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.interpolate\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\nPinCFlow.Update.compute_vertical_wind\nPinCFlow.MSGWaM.Interpolation.compute_derivatives\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_sponge","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_sponge","text":"interpolate_sponge(\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    state::State,\n)::AbstractFloat\n\nInterpolate the Rayleigh-damping coefficient of the LHS sponge (alpha_mathrmR) to (xlc, ylc, zlc), using a trilinear-interpolation algorithm, and return the result.\n\nThis method first determines the two points in widehatx and widehaty that are closest to xlc and ylc, respectively. For each of these four horizontal positions, it then determines the two points in z that are closest to zlc. The resulting eight grid points are used to interpolate alpha_mathrmR to the location of interest, using interpolate.\n\nArguments\n\nxlc: Zonal position of interest.\nylc: Meridional position of interest.\nzlc: Vertical position of interest.\nstate: Model state.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.interpolate\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.Interpolation.interpolate_stratification","page":"MSGWaM","title":"PinCFlow.MSGWaM.Interpolation.interpolate_stratification","text":"interpolate_stratification(\n    zlc::AbstractFloat,\n    state::State,\n    strtype::N2,\n)::AbstractFloat\n\nInterpolate the squared buoyancy frequency (N^2) to zlc and return the result.\n\nThis method first determines the two points in z that are closest to zlc. As horizontal position, it uses (i0, j0), which is arbitrary, since N^2 has no horizontal dependence. Subsequently, simple linear interpolation is performed to find N^2 at zlc.\n\ninterpolate_stratification(\n    zlc::AbstractFloat,\n    state::State,\n    strtype::DN2DZ,\n)::AbstractFloat\n\nInterpolate the vertical derivative of the squared buoyancy frequency (partial N^2  partial z) to zlc and return the result.\n\nThis method first determines the two points in z + J Delta widehatz  2 that are closest to zlc. As for N^2, (i0, j0) is used as the horizontal position, and simple linear interpolation is performed to find partial N^2  partial z at zlc.\n\nArguments\n\nzlc: Vertical position of interest.\nstate: Model state.\nstrtype: Stratification quantity to interpolate.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_level\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations","text":"RayOperations\n\nModule for various ray-volume operations needed throughout PinCFlow.MSGWaM.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.Interpolation\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.check_rays","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.check_rays","text":"check_rays(state::State)\n\nCheck if all ray volumes are assigned to the correct grid cells.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency","text":"compute_intrinsic_frequency(\n    state::State,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::AbstractFloat\n\nReturn the intrinsic frequency of the ray volume specified by left(r i j kright).\n\nThe intrinsic frequency is calculated from the dispersion relation\n\nwidehatomega_r = sigma sqrtfracN_r^2 left(k_r^2 + l_r^2right) + f^2 m_r^2leftboldsymbolk_rright^2\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray volume's vertical position and sigma is the frequency branch.\n\nArguments\n\nstate: Model state\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_merge_index","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_merge_index","text":"compute_merge_index(\n    wnr::AbstractFloat,\n    wnr_min_p::AbstractFloat,\n    wnr_max_p::AbstractFloat,\n    wnr_min_n::AbstractFloat,\n    wnr_max_n::AbstractFloat,\n    dwnr_mrg_p::AbstractFloat,\n    dwnr_mrg_n::AbstractFloat,\n    nray::Integer,\n)::Integer\n\nReturn the index of the wavenumber wnr on a 1D spectral grid specified by the other arguments.\n\nThis method is used by PinCFlow.MSGWaM.RayUpdate.merge_rays! to sort ray volumes into spectral bins.\n\nArguments\n\nwnr: Wavenumber value.\nwnr_min_p: Minimum positive wavenumber.\nwnr_max_p: Maximum positive wavenumber.\nwnr_min_n: Minimum negative wavenumber.\nwnr_max_n: Maximum negative wavenumber.\ndwnr_mrg_p: Logarithmic spacing of discrete positive wavenumbers.\ndwnr_mrg_n: Logarithmic spacing of discrete negative wavenumbers.\nnray: Number of spectral grid points.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals","text":"compute_saturation_integrals(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{2, <:AbstractFloat}\n\nCompute and return the two spectral integrals S_1 and S_2, as needed by the saturation scheme (in the grid cell left(i j kright)).\n\nComputes the sums\n\nbeginalign*\n    S_1  approx sumlimits_r left(m_r leftb_mathrmw rrightright)^2 f_r\n    S_2  approx sumlimits_r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_r\nendalign*\n\nwhere\n\nf_r = max left(1 fracDelta x_rDelta widehatxright) max left(1 fracDelta y_rDelta widehatyright) max left(1 fracDelta z_rJ Delta widehatzright)\n\nis the maximum grid-cell fraction that can be covered by each ray volume (with left(Delta x_r Delta y_r Delta z_rright) being the ray-volume extents in physical space) and\n\nleftb_mathrmw rright^2 = frac2overlinerho fracN_r^4 left(k_r^2 + l_r^2right)widehatomega_r leftboldsymbolk_rright^2 mathcalN_r Delta k_r Delta l_r Delta m_r\n\nis the squared gravity-wave amplitude of the buoyancy. Therein, N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position (using interpolate_stratification) and left(Delta k_r Delta l_r Delta m_rright) are the ray-volume extents in spectral space.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\nPinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds","text":"compute_spectral_bounds(\n    wavenumbers::AbstractVector{<:AbstractFloat},\n)::NTuple{4, <:AbstractFloat}\n\nCompute the minima and maxima of positive and negative entries in wavenumbers and return them (in the order positive minimum, positive maximum, negative minimum, negative maximum).\n\nThis method is used by PinCFlow.MSGWaM.RayUpdate.merge_rays! to create spectral bins.\n\nArguments\n\nwavenumbers: Vector of wavenumbers in the considered spectral dimension.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral","text":"compute_wave_action_integral(\n    merge_mode::ConstantWaveAction,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n)\n\nReturn the wave action obtained by multiplying the given phase-space wave-action density with the given phase-space volume.\n\nThis method is used to implement conservation of wave action in ray-volume merging.\n\ncompute_wave_action_integral(\n    merge_mode::ConstantWaveEnergy,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n)::AbstractFloat\n\nReturn the wave energy obtained by multiplying the given phase-space wave-action density with the given intrinsic frequency and phase-space volume.\n\nThis method is used to implement conservation of wave energy in ray-volume merging.\n\nArguments\n\nmerge_mode: Merging strategy.\nnr: Phase-space wave-action density.\nomegar: Intrinsic frequency.\nfxk: Phase space factor in the x-k subspace.\nfyl: Phase space factor in the y-l subspace.\nfzm: Phase space factor in the z-m subspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.copy_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.copy_rays!","text":"copy_rays!(\n    rays::Rays,\n    r::Pair{<:Integer, <:Integer},\n    i::Pair{<:Integer, <:Integer},\n    j::Pair{<:Integer, <:Integer},\n    k::Pair{<:Integer, <:Integer},\n)\n\nCopy all properties of the ray volume specified by the first components of the index pairs to that specified by the second components.\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume indices.\ni: Zonal grid-cell indices.\nj: Meridional grid-cell indices.\nk: Vertical grid-cell indices.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_physical_extent","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_physical_extent","text":"get_physical_extent(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the physical extents of the ray volume specified by left(r i j kright) as the tuple (dxr, dyr, dzr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_physical_position","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_physical_position","text":"get_physical_position(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the physical position of the ray volume specified by left(r i j kright) as the tuple (xr, yr, zr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_spectral_extent","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_spectral_extent","text":"get_spectral_extent(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the spectral extents of the ray volume specified by left(r i j kright) as the tuple (dkr, dlr, dmr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_spectral_position","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_spectral_position","text":"get_spectral_position(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nReturn the spectral position of the ray volume specified by left(r i j kright) as the tuple (kr, lr, mr).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.get_surfaces","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.get_surfaces","text":"get_surfaces(\n    rays::Rays,\n    r::Integer,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)::NTuple{3, <:AbstractFloat}\n\nCompute phase-space surface areas of the ray volume specified by left(r i j kright) and return them as the tuple (axk, ayl, azm).\n\nArguments\n\nrays: Collection of ray-volume-property arrays.\nr: Ray-volume index.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.remove_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.remove_rays!","text":"remove_rays!(state::State)\n\nRemove gaps (i.e. zero-wave-action ray volumes between nonzero-wave-action ray volumes) in the ray-volume arrays.\n\nIn each grid cell, this method moves all ray volumes as far to the front of the arrays possible and updates nray accordingly, so that every ray volume in the range 1:nray[i, j, k] has nonzero wave action.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayOperations.update_merged_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayOperations.update_merged_rays!","text":"update_merged_rays!(\n    merge_mode::AbstractMergeMode,\n    merged_rays::MergedRays,\n    bin::Integer,\n    xr::AbstractFloat,\n    dxr::AbstractFloat,\n    yr::AbstractFloat,\n    dyr::AbstractFloat,\n    zr::AbstractFloat,\n    dzr::AbstractFloat,\n    kr::AbstractFloat,\n    dkr::AbstractFloat,\n    lr::AbstractFloat,\n    dlr::AbstractFloat,\n    mr::AbstractFloat,\n    dmr::AbstractFloat,\n    fxk::AbstractFloat,\n    fyl::AbstractFloat,\n    fzm::AbstractFloat,\n    nr::AbstractFloat,\n    omegar::AbstractFloat,\n)\n\nUpdate the fields of merged_rays at bin such that they contain the outermost bounds and total wave action/energy of all contributing ray volumes.\n\nThis method is used to compute the properties of merged ray volumes. It is called for every old ray volume that contributes to the new, merged volume and updates the outermost bounds in physical and spectral space, as well as the total wave action/energy, accordingly.\n\nArguments\n\nmerge_mode: Merging strategy.\nmerged_rays: Properties of merged ray volumes.\nbin: Index of the bin to update.\nxr: Position of the old ray volume in x.\ndxr: Extent of the old ray volume in x.\nyr: Position of the old ray volume in y.\ndyr: Extent of the old ray volume in y.\nzr: Position of the old ray volume in z.\ndzr: Extent of the old ray volume in z.\nkr: Position of the old ray volume in k.\ndkr: Extent of the old ray volume in k.\nlr: Position of the old ray volume in l.\ndlr: Extent of the old ray volume in k.\nmr: Position of the old ray volume in m.\ndmr: Extent of the old ray volume in m.\nfxk: Phase-space factor of the old ray volume in x-k subspace.\nfyl: Phase-space factor of the old ray volume in y-l subspace.\nfzm: Phase-space factor of the old ray volume in z-m subspace.\nnr: Phase-space wave-action density of the old ray volume.\nomegar: Intrinsic frequency of the old ray volume.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_wave_action_integral\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources","text":"RaySources\n\nModule for ray-volume sources.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.RayOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources.activate_orographic_source!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources.activate_orographic_source!","text":"activate_orographic_source!(\n    state::State,\n    omi_ini::AbstractArray{<:AbstractFloat, 4},\n    wnk_ini::AbstractArray{<:AbstractFloat, 4},\n    wnl_ini::AbstractArray{<:AbstractFloat, 4},\n    wnm_ini::AbstractArray{<:AbstractFloat, 4},\n    wad_ini::AbstractArray{<:AbstractFloat, 4},\n)\n\nCompute ray-volume properties in the launch layer (i.e. at k = k0 - 1) for the initialization of MS-GWaM.\n\nSets the launch-layer values of arrays for initial ray-volume properties (intrinsic frequencies, wavenumbers and wave-action densities). For this purpose, the horizontal components of the resolved wind, the background density and the squared buoyancy frequency are vertically averaged between the surface and an approximation for the summits of the unresolved orography. The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking is inferred (see below). Afterwards, the ray-volume properties are obtained by calling compute_orographic_mode with the correspondingly scaled mode of the orographic spectrum and the vertical averages as arguments.\n\nactivate_orographic_source!(state::State)\n\nLaunch ray volumes that represent unresolved orographic gravity waves.\n\nIn each column of MPI processes at the lower boundary, this method first computes vertical averages of the horizontal components of the resolved wind, the background density and the squared buoyancy frequency between h_mathrmb (the surface) and h_mathrmb + Delta h (an approximation for the summits of the unresolved orography, with Delta h = sum_alpha lefth_mathrmw alpharight). The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking, as well as the depth of the blocked layer, is inferred. A loop over the spectral modes of the unresolved orography follows, in which the properties of each mode are computed, using compute_orographic_mode with the scaled mode of the orographic spectrum and vertical averages as arguments, and corresponding ray volumes are launched at k = k0 - 1.\n\nThe parameterization of blocking is built around the non-dimensionalized mountain wave amplitude, or Long number,\n\nmathrmLo = fracN_h Delta hleftboldsymbolu_hright\n\nwhere N_h is the square root of the vertically averaged squared buoyancy frequency and boldsymbolu_h is the vertically averaged resolved horizontal wind. This number is used to estimate the depth of the blocked layer as\n\nDelta z_mathrmB = 2 Delta h max left(0 fracmathrmLo - CmathrmLoright)\n\nwhere C is a critical value represented by the model parameter state.namelists.wkb.long_threshold. The corresponding scaling of the orographic spectrum is given by\n\nr left(mathrmLoright) = frac2 Delta h - Delta z_mathrmB2 Delta h = min left(1 fracCmathrmLoright)\n\nso that Delta z_mathrmB = 2 Delta h left(1 - rright). In addition to the reduction of the mountain-wave amplitude, the present blocked-layer scheme adds a blocked-flow drag to the mean-flow impact. This is implemented in PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!.\n\nThe launch algorithm distinguishes between the following situations (regarding previously launched ray volumes).\n\nThere is no ray volume with nonzero wave-action density. A new ray volume is launched.\nThere is a ray volume with nonzero wave-action density that has at least partially passed through the lower boundary. The ray volume is either clipped or extended, such that its lower edge coincides with the surface, and the part below the surface is discarded. Then, it is assigned to the first model layer k0, i.e. its indices are changed from (r, i, j, k0 - 1) to (rray, i, j, k0), where rray is the new last ray-volume index at (i, j, k0). Finally, a new ray volume is launched.\nThere is a ray volume with nonzero wave-action density, which has not yet crossed the lower boundary. It is replaced with a new one.\n\nArguments\n\nstate: Model state.\nomi_ini: Array for intrinsic frequencies.\nwnk_ini: Array for zonal wavenumbers.\nwnl_ini: Array for meridional wavenumbers.\nwnm_ini: Array for vertical wavenumbers.\nwad_ini: Array for wave-action densities.\n\nSee also\n\nPinCFlow.MSGWaM.RaySources.compute_orographic_mode\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RaySources.compute_orographic_mode","page":"MSGWaM","title":"PinCFlow.MSGWaM.RaySources.compute_orographic_mode","text":"compute_orographic_mode(\n    displm::AbstractFloat,\n    wnk::AbstractFloat,\n    wnl::AbstractFloat,\n    uavg::AbstractFloat,\n    vavg::AbstractFloat,\n    rhoavg::AbstractFloat,\n    bvsavg::AbstractFloat,\n    fc::AbstractFloat,\n    branch::Integer,\n)::NTuple{5, <:AbstractFloat}\n\nCompute and return the properties of an orographic-gravity-wave mode.\n\nCalculates the intrinsic frequency, wavenumbers and wave-action density of a gravity-wave mode generated by flow over topography, using linear mountain-wave theory. The implemented formulas are as follows (where this method's arguments are represented by h_mathrmw alpha, k_h alpha, l_h alpha, u_h, v_h, overlinerho_h, N_h^2, f and sigma).\n\nIntrinsic frequency:\nwidehatomega_alpha = sigma left- k_h alpha u_h - l_h alpha v_hright\nHorizontal wavenumbers:\nbeginalign*\n    k_alpha  = sigma mathrmsgn left(- k_h alpha u_h - l_h alpha v_hright) k_h alpha\n    l_alpha  = sigma mathrmsgn left(- k_h alpha u_h - l_h alpha v_hright) l_h alpha\nendalign*\nVertical wavenumber:\nm_alpha = - sigma sqrtfracleft(k_alpha^2 + l_alpha^2right) left(N_h^2 - widehatomega_alpha^2right)widehatomega_alpha^2 - f^2\nWave-action density:\nmathcalA_alpha = fracoverlinerho_h2 fracwidehatomega_alpha leftboldsymbolk_alpharight^2k_alpha^2 + l_alpha^2 lefth_mathrmw alpharight^2\n\nIf the squared intrinsic frequency is smaller than the squared Coriolis parameter or larger than the squared buoyancy frequency (and thus outside of the gravity-wave spectrum), the vertical wavenumber and wave-action density are set to zero.\n\nArguments\n\ndisplm: Topographic displacement.\nwnk: Zonal wavenumber from the topographic spectrum.\nwnl: Meridional wavenumber from the topographic spectrum.\nuavg: Vertically averaged resolved zonal wind.\nvavg: Vertically averaged resolved meridional wind.\nrhoavg: Vertically averaged background density.\nbvsavg: Vertically averaged squared buoyancy frequency.\nfc: Coriolis parameter.\nbranch: Frequency branch.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays","text":"BoundaryRays\n\nModule for enforcing boundary conditions for ray volumes.\n\nProvides functions for configurations that are serial or parallel in any dimension of physical space. Assumes periodicity in the horizontal and solid-wall boundaries in the vertical.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MPIOperations\nPinCFlow.Boundaries\nPinCFlow.MSGWaM.RayOperations\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!","text":"set_boundary_rays!(state::State)\n\nEnforce boundary conditions for ray volumes by dispatching to a WKB-mode-specific method.\n\nset_boundary_rays!(state::State, wkb_mode::NoWKB)\n\nReturn for non-WKB configurations.\n\nset_boundary_rays!(state::State, wkb_mode::SteadyState)\n\nEnforce horizontal boundary conditions for \"ray volumes\" in steady-state mode.\n\nZonal (meridional) boundary conditions are only enforced if state.namelists.domain.x_size > 1 (state.namelists.domain.y_size > 1).\n\nset_boundary_rays!(state::State, wkb_mode::Union{SingleColumn, MultiColumn})\n\nEnforce horizontal and vertical boundary conditions for ray volumes in single-column or multi-column mode.\n\nZonal (meridional) boundary conditions are only enforced if state.namelists.domain.x_size > 1 (state.namelists.domain.y_size > 1).\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!","text":"set_meridional_boundary_rays!(state::State)\n\nSet the ray volumes at the meridional boundaries.\n\nThis method first enforces meridional boundary conditions for state.wkb.nray (by applying set_meridional_boundaries_of_field! to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in widehaty, ray volumes are communicated between MPI processes, using set_meridional_halo_rays!. At the meridional boundaries of the domain, the y-coordinates of ray volumes are adjusted such that shifting works properly.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_meridional_boundaries_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!","text":"set_meridional_halo_rays!(state::State)\n\nExchange ray volumes in meridional halo cells.\n\nPerforms bidirectional MPI communication between backward and forward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the backward and forward boundaries of the MPI subdomains.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!","text":"set_vertical_boundary_rays!(state::State)\n\nEnforce vertical boundary conditions for ray volumes.\n\nIf the domain is parallelized in widehatz, ray-volume counts and the ray volumes themselves are first communicated between MPI processes, using set_vertical_halos_of_field! and set_vertical_halo_rays!, respectively. The vertical boundary conditions are then enforced by cutting (removing) ray volumes that have partially (fully) crossed the upper boundary and reflecting ray volumes (by adjusting the vertical position and wavenumber) that have at least partially crossed the lower boundary from above.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!","text":"set_vertical_halo_rays!(state::State)\n\nExchange ray volumes in vertical halo cells.\n\nPerforms MPI communication between downward and upward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the downward and upward boundaries of the MPI subdomains. Solid walls are assumed at the vertical boundaries of the full domain. The corresponding ghost-cell ray volumes are not changed.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!","text":"set_zonal_boundary_rays!(state::State)\n\nSet the ray volumes at the zonal boundaries.\n\nThis method first enforces zonal boundary conditions for state.wkb.nray (by applying set_zonal_boundaries_of_field! to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in widehatx, ray volumes are communicated between MPI processes, using set_zonal_halo_rays!. At the zonal boundaries of the domain, the x-coordinates of ray volumes are adjusted such that shifting works properly.\n\nArguments\n\nstate: Model state.\n\nSee also\n\nPinCFlow.Boundaries.set_zonal_boundaries_of_field!\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!","text":"set_zonal_halo_rays!(state::State)\n\nExchange ray volumes in zonal halo cells.\n\nPerforms bidirectional MPI communication between left and right neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the left and right boundaries of the MPI subdomains.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate","text":"RayUpdate\n\nModule for the integration of the ray equations.\n\nIn addition to ray-volume initialization and propagation, functions for tracking ray volumes on the model grid and controlling their count, as well as a saturation scheme for capturing wave breaking, are provided.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.MSGWaM.BoundaryRays\nPinCFlow.MSGWaM.Interpolation\nPinCFlow.MSGWaM.RayOperations\nPinCFlow.MSGWaM.RaySources\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.X","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.X","text":"X\n\nSingleton for dispatch to operations in x-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.XYZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.XYZ","text":"XYZ\n\nSingleton for dispatch to operations in all directions.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.XZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.XZ","text":"XZ\n\nSingleton for dispatch to operations in x- and z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.Y","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.Y","text":"Y\n\nSingleton for dispatch to operations in y-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.YZ","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.YZ","text":"YZ\n\nSingleton for dispatch to operations in y- and z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.Z","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.Z","text":"Z\n\nSingleton for dispatch to operations in z-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!","text":"apply_saturation_scheme!(state::State, dt::AbstractFloat)\n\nApply the saturation scheme by dispatching to a WKB-mode-specific method.\n\napply_saturation_scheme!(\n    state::State,\n    dt::AbstractFloat,\n    wkb_mode::Union{NoWKB, SteadyState},\n)\n\nReturn for configurations without WKB / with steady-state WKB.\n\nIn steady-state mode, saturation is handled by PinCFlow.MSGWaM.RayUpdate.propagate_rays!.\n\napply_saturation_scheme!(\n    state::State,\n    dt::AbstractFloat,\n    wkb_mode::Union{SingleColumn, MultiColumn},\n)\n\nApply the saturation scheme.\n\nSaturation is assumed to occur when the static-instability criterion\n\nsumlimits_r left(m_r leftb_mathrmw rrightright)^2 f_r geq alpha_mathrms^2 N^4\n\nis locally fulfilled (i.e. within a grid cell). Therein, leftb_mathrmw rright^2 is the squared gravity-wave amplitude of the buoyancy, f_r is the maximum grid-cell fraction each ray volume can cover and alpha_mathrms is a saturation coefficient that represents the uncertainties of the criterion. The phase-space wave-action density is then reduced in accordance with\n\nfracDelta leftb_mathrmw rright^2Delta t = - 2 K leftboldsymbolk_rright^2 leftb_mathrmw rright^2\n\nwhich is based on the assumption that wave breaking leads to turbulent fluxes that may be parameterized with a flux-gradient ansatz. The turbulent viscosity and diffusivity\n\nK = left2 Delta tsumlimits_r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_rright^- 1 max left0 sum_r left(m_r leftb_mathrmw rrightright)^2 f_r - alpha_mathrms^2 N^4right\n\nis such that wave action is reduced exactly to the saturation threshold. The two sums involved in this scheme (discretizations of spectral integrals) are computed with compute_spectral_integrals.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_saturation_integrals\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.RayOperations.remove_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.initialize_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.initialize_rays!","text":"initialize_rays!(state::State)\n\nComplete the initialization of MS-GWaM by dispatching to a WKB-mode-specific method.\n\ninitialize_rays!(state::State, wkb_mode::NoWKB)\n\nReturn for non-WKB configurations.\n\ninitialize_rays!(\n    state::State,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nComplete the initialization of MS-GWaM.\n\nIn each grid cell, wave_modes wave modes are computed, using state.namelists.wkb.initial_wave_field, as well as activate_orographic_source! for mountain waves. For each of these modes, nrx * nry * nrz * nrk * nrl * nrm ray volumes are then defined such that they evenly divide the volume one would get for nrx = nry = nrz = nrk = nrl = nrm = 1 (the parameters are taken from state.namelists.wkb). Finally, the maximum group velocities are determined for the corresponding CFL condition that is used in the computation of the time step.\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RaySources.activate_orographic_source!\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.Interpolation.interpolate_mean_flow\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.merge_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.merge_rays!","text":"merge_rays!(state::State)\n\nMerge ray volumes by dispatching to a WKB-mode-specific method.\n\nmerge_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})\n\nReturn for configurations without WKB / with steady-state WKB.\n\nmerge_rays!(state::State, wkb_mode::Union{SingleColumn, MultiColumn})\n\nMerge ray volumes in grid cells in which their count exceeds a threshold.\n\nThis method checks in each grid cell if the number of ray volumes exceeds a maximum that was determined from namelist parameters (state.wkb.nray_max). If it does, the ray volumes in that cell are merged such that the new count is smaller or equal to the threshold. This is done by binning them on a spectral grid with logarithmic spacing, defined from the minima and maxima of the contributing negative and positive wavenumbers in all spectral dimensions. The merging is performed such that the bounds of the new ray volumes coincide with the outermost bounds of the old ray volumes and wave action (or wave energy, depending on the merging strategy) is conserved.\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.compute_spectral_bounds\nPinCFlow.MSGWaM.RayOperations.get_physical_position\nPinCFlow.MSGWaM.RayOperations.get_spectral_position\nPinCFlow.MSGWaM.RayOperations.get_physical_extent\nPinCFlow.MSGWaM.RayOperations.get_spectral_extent\nPinCFlow.MSGWaM.RayOperations.get_surfaces\nPinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency\nPinCFlow.MSGWaM.RayOperations.compute_merge_index\nPinCFlow.MSGWaM.RayOperations.update_merged_rays!\nPinCFlow.MSGWaM.RayOperations.compute_wave_action_integral\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.propagate_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.propagate_rays!","text":"propagate_rays!(state::State, dt::AbstractFloat, rkstage::Integer)\n\nIntegrate the wave-action-density and ray equations by dispatching to a WKB-mode-specific method.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    wkb_mode::NoWKB,\n)\n\nReturn for non-WKB configurations.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    wkb_mode::Union{SingleColumn, MultiColumn},\n)\n\nIntegrate the wave-action-density and ray equations derived from 1D or 3D transient WKB theory.\n\nThe updates of the RK tendencies for the phase-space position of each ray volume are given by\n\nbeginalign*\n    q_r^x  rightarrow Delta t left(u_mathrmb r + k_r fracN_r^2 - widehatomega_r^2widehatomega_r leftboldsymbolk_rright^2right) + alpha_mathrmRK q_r^x\n    q_r^y  rightarrow Delta t left(v_mathrmb r + l_r fracN_r^2 - widehatomega_r^2widehatomega_r leftboldsymbolk_rright^2right) + alpha_mathrmRK q_r^y\n    q_r^z  rightarrow - Delta t fracm_r left(widehatomega_r^2 - f^2right)widehatomega_r leftboldsymbolk_rright^2 + alpha_mathrmRK q_r^z\n    q_r^k  rightarrow - Delta t leftk_r left(fracpartial u_mathrmbpartial xright)_r - l_r left(fracpartial v_mathrmbpartial xright)_rright + alpha_mathrmRK q_r^k\n    q_r^l  rightarrow - Delta t leftk_r left(fracpartial u_mathrmbpartial yright)_r - l_r left(fracpartial v_mathrmbpartial yright)_rright + alpha_mathrmRK q_r^l\n    q_r^m  rightarrow - Delta t leftk_r left(fracpartial u_mathrmbpartial zright)_r - l_r left(fracpartial v_mathrmbpartial zright)_r - frack_r^2 + l_r^22 widehatomega_r leftboldsymbolk_rright^2 left(fracpartial N^2partial zright)_rright + alpha_mathrmRK q_r^m\nendalign*\n\nand the position update is\n\nbeginalign*\n    x_r  = x_r + beta_mathrmRK q_r^x  y_r  rightarrow y_r + beta_mathrmRK q_r^y  z_r  rightarrow z_r + beta_mathrmRK q_r^z\n    k_r  rightarrow k_r + beta_mathrmRK q_r^k  l_r  rightarrow l_r + beta_mathrmRK q_r^l  m_r  rightarrow m_r + beta_mathrmRK q_r^m\nendalign*\n\nwhere the subscript r indicates either a ray-volume property or a mean-flow property interpolated to the ray-volume position, via interpolate_mean_flow and interpolate_stratification. In addition, MS-GWaM updates the ray-volume extents, following\n\nbeginalign*\n    q_r^Delta x  rightarrow Delta t left(u_mathrmb r + - u_mathrmb r -right) + alpha_mathrmRK q_r^Delta x  Delta x_r  rightarrow Delta x_r + beta_mathrmRK q_r^Delta x\n    q_r^Delta y  rightarrow Delta t left(v_mathrmb r + - v_mathrmb r -right) + alpha_mathrmRK q_r^Delta y  Delta y_r  rightarrow Delta y_r + beta_mathrmRK q_r^Delta y\n    q_r^Delta z  rightarrow Delta t left(c_mathrmg z r + - c_mathrmg z r -right) + alpha_mathrmRK q_r^Delta z  Delta z_r  rightarrow Delta z_r + beta_mathrmRK q_r^Delta z\nendalign*\n\nwhere u_mathrmb r pm is the interpolation of u_mathrmb to x_r pm = x_r pm Delta x_r  2 (from before the position update) and v_mathrmb r pm is the equivalent for v_mathrmb in y-direction. In the computation of c_mathrmg z r pm, the intrinsic frequency and squared buoyancy frequency are interpolated to z_r pm = z_r pm Delta z_r  2 (also from before the position update). The update of the spectral ray-volume extents uses the fact that the surfaces in the x-k, y-l and z-m subspaces are conserved. Finally, the update of the phase-space wave-action density reads\n\nmathcalN_r rightarrow left(1 + 2 alpha_mathrmR r f_mathrmRK Delta tright)^- 1 mathcalN_r\n\nwhere alpha_mathrmR r is the interpolation of the Rayleigh-damping coefficient to the updated ray-volume position, obtained from interpolate_sponge.\n\nThe group velocities that are calculated for the propagation in physical space are also used to determine the maxima needed for the WKB-CFL condition used in the time-step computation.\n\npropagate_rays!(\n    state::State,\n    dt::AbstractFloat,\n    rkstage::Integer,\n    wkb_mode::SteadyState,\n)\n\nUpdate the vertical wavenumber and wave-action density, using steady-state WKB theory.\n\nIn steady-state mode, the ray volumes are stationary in physical space. In mountain-wave simulations, this method first updates the ray volumes in the launch layer by calling activate_orographic_source!. Subsequently, it performs a vertical sweep to update all other ray volumes. Therein, the vertical wavenumber is set to\n\nm_r = - sigma sqrtfracleft(k_r^2 + l_r^2right) left(N_r^2 - widehatomega_r^2right)widehatomega_r^2 - f^2\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position (with interpolate_stratification) and widehatomega_r = - k_r u_mathrmb - l_r v_mathrmb (in the case of mountain waves, for which omega_r = 0). The new wave-action-density field is obtained by integrating\n\nfracpartialpartial z left(c_mathrmg z r mathcalA_rright) = - 2 alpha_mathrmR r mathcalA_r - 2 K leftboldsymbolk_rright^2 mathcalA_r\n\nwhere alpha_mathrmR r is the Rayleigh-damping coefficient interpolated to the ray-volume position (using interpolate_sponge) and\n\nK = left2 sumlimits_r fracJ Delta widehatzc_mathrmg z r left(m_r leftb_mathrmw rright leftboldsymbolk_rrightright)^2 f_rright^- 1 max left0 sum_r left(m_r leftb_mathrmw rrightright)^2 f_r - alpha_mathrms^2 N^4right\n\nis the turbulent viscosity and diffusivity due to wave breaking (see PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme! for more details). After the first right-hand-side term has been integrated with the implicit step\n\nmathcalA_r = left1 + frac2 alpha_mathrmR rc_mathrmg z r left(z_r - z_r k - 1right)right^- 1 fracc_mathrmg z r k - 1c_mathrmg z r mathcalA_r k - 1\n\nthe second term is integrated with the pseudo-time step J Delta widehatz  c_mathrmg z r, which corresponds to the substitution mathcalA_r rightarrow left(1 - 2 J Delta widehatz  c_mathrmg z r K leftboldsymbolk_rright^2right) mathcalA_r.\n\nIf the domain is parallelized in the vertical, the integration in vertical subdomains is performed sequentially, with one-way communication providing boundary conditions.\n\nArguments\n\nstate: Model state.\ndt: Time step.\nrkstage: Runge-Kutta-stage index.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.get_physical_position\nPinCFlow.MSGWaM.RayOperations.get_spectral_position\nPinCFlow.MSGWaM.RayOperations.get_physical_extent\nPinCFlow.MSGWaM.RayOperations.get_spectral_extent\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.Interpolation.interpolate_mean_flow\nPinCFlow.MSGWaM.Interpolation.interpolate_sponge\nPinCFlow.MSGWaM.RaySources.activate_orographic_source!\nPinCFlow.MSGWaM.RayOperations.copy_rays!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.shift_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.shift_rays!","text":"shift_rays!(state::State)\n\nShift the array positions of ray volumes such that they are attributed to the correct grid cells by dispatching to a WKB-mode-specific method.\n\nshift_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})\n\nReturn for configurations without WKB / with steady-state WKB.\n\nshift_rays!(state::State, wkb_mode::SingleColumn)\n\nShift the vertical array positions of ray volumes such that they are attributed to the correct grid cells.\n\nThis method enforces the vertical boundary conditions (via set_vertical_boundary_rays!), checks if ray volumes need to be shifted and, if they do, copies them to the correct grid cells and marks them for removal (by dispatching to the appropriate method). A second call of set_vertical_boundary_rays! ensures that ray volumes that have moved across MPI processes are included in the appropriate halo cells. Finally, the gaps that were created by marking ray volumes for removal are filled (via remove_rays!).\n\nshift_rays!(state::State, wkb_mode::MultiColumn)\n\nShift the array positions of ray volumes such that they are attributed to the correct grid cells.\n\nFor each dimension in physical space (with more than one grid point), this method performs the corresponding equivalent of the algorithm that is implemented in the method for single-column mode.\n\nshift_rays!(state::State, direction::X)\n\nFor each ray volume, check if it is attributed to the correct position in widehatx and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes that should be attributed to a halo cell are marked for removal but not copied, since the copies are created from the corresponding halo cell in the adjacent MPI process.\n\nshift_rays!(state::State, direction::Y)\n\nFor each ray volume, check if it is attributed to the correct position in widehaty and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes in halo cells are treated in the same way as in the method for shifting in widehatx.\n\nshift_rays!(state::State, direction::Z)\n\nFor each ray volume, check if it is attributed to the correct position in widehatz and, if it is not, create a copy that is and mark the original for removal.\n\nRay volumes in halo cells are treated in the same way as in the methods for shifting in widehatx and widehatz.\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\ndirection: Shift direction.\n\nSee also\n\nPinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!\nPinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!\nPinCFlow.MSGWaM.RayOperations.remove_rays!\nPinCFlow.MSGWaM.RayOperations.check_rays\nPinCFlow.MSGWaM.RayOperations.copy_rays!\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.RayUpdate.split_rays!","page":"MSGWaM","title":"PinCFlow.MSGWaM.RayUpdate.split_rays!","text":"split_rays!(state::State)\n\nSplit ray volumes that have become larger than the local grid cell by dispatching to a WKB-mode-specific method.\n\nsplit_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})\n\nReturn for configurations without WKB / with steady-state WKB.\n\nsplit_rays!(state::State, wkb_mode::SingleColumn)\n\nSplit ray volumes which have a vertical extent larger than the local vertical grid spacing.\n\nsplit_rays!(state::State, wkb_mode::MultiColumn)\n\nIn each dimension of physical space, split ray volumes which have an extent larger than the local grid spacing.\n\nThe splitting is performed sequentially, such that a ray volume with extents that are all between once and twice as large as allowed is split into exactly eight smaller ray volumes (all of which have the same size).\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::X)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta x_r  Delta widehatx.\n\nThe number of splits is the result of ceiling division of Delta x_r by Delta widehatx. Each split is carried out by adjusting the position and extent of the ray volume, copying it and changing the position of the copy appropriately.\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Y)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta y_r  Delta widehaty.\n\nThe splitting is analogous to that in widehatx.\n\nsplit_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Z)\n\nIn the grid cell specified by left(i j kright), split ray volumes with Delta z_r  J_min Delta widehatz, with J_min being the minimum value of the Jacobian in all grid cells that are at least partially covered by the ray volume (at its true horizontal position on the grid).\n\nThe splitting is analogous to that in widehatx and widehaty.\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\ni: Grid-cell index in widehatx-direction\nj: Grid-cell index in widehaty-direction\nk: Grid-cell index in widehatz-direction\naxis: Axis perpendicular to the split.\n\nSee also\n\nPinCFlow.MSGWaM.RayOperations.copy_rays!\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect","text":"MeanFlowEffect\n\nModule for computing the mean-flow effect of gravity waves.\n\nProvides functions that compute mean-flow tendencies by integrating ray-volume properties in spectral space and mapping the result to physical grid cells. Also provides two filters for smoothing the tendencies, as well as a simple blocked-layer scheme that includes a blocked-flow drag in mountain-wave simulations.\n\nSee also\n\nPinCFlow.Types\nPinCFlow.Boundaries\nPinCFlow.MSGWaM.Interpolation\nPinCFlow.MSGWaM.RayUpdate\n\n\n\n\n\n","category":"module"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.UChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.UChi","text":"UChi\n\nSingleton for dispatch to calculation of zonal gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.VChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.VChi","text":"VChi\n\nSingleton for dispatch to calculation of meridional gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.WChi","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.WChi","text":"WChi\n\nSingleton for dispatch to calculation of vertical gravity-wave-tracer fluxes.\n\n\n\n\n\n","category":"type"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!","text":"apply_blocked_layer_scheme!(state::State)\n\nCompute the blocked-flow drag and adjust the mean-flow impact accordingly.\n\nThe blocked-flow drag is given by\n\nleft(fracpartial boldsymbolu_mathrmbpartial tright)_mathrmB = - D fracleftboldsymbolk_hright leftboldsymbolu_mathrmpright2 pi boldsymbolu_mathrmp\n\nwhere boldsymbolu_mathrmb = left(u_mathrmb v_mathrmb 0right)^mathrmT is the resolved horizontal wind, D is a dimensionless drag coefficient (represented by state.namelists.wkb.drag_coefficient),\n\nboldsymbolk_h = fracsum_alpha lefth_mathrmw alpharight boldsymbolk_h alphasum_alpha lefth_mathrmw alpharight\n\nis a weighted average of the orography's wavevectors boldsymbolk_h alpha (with h_mathrmw alpha being the corresponding spectral modes) and\n\nboldsymbolu_mathrmp = fracleft(boldsymbolu_mathrmb cdot boldsymbolk_hright) boldsymbolk_hleftboldsymbolk_hright^2\n\nis the projection of boldsymbolu_mathrmb onto boldsymbolk_h. This drag replaces the drag due to gravity waves below z_mathrmB, the upper edge of the blocked layer that has been determined by PinCFlow.MSGWaM.RaySources.activate_orographic_source!. In grid cells that contain this upper edge, blocking and gravity waves both contribute to the total drag, weighted by the corresponding grid-cell fractions. The gravity-wave heating is treated similarly, with the \"blocking contribution\" being zero.\n\nArguments\n\nstate: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!","text":"apply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{1},\n)\n\nApply the first-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac14 left(phi_i - 1 + 2 phi_i + phi_i + 1right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{2},\n)\n\nApply the second-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac116 left(- phi_i - 2 + 4 phi_i - 1 + 10 phi_i + 4 phi_i + 1 - phi_i + 2right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{3},\n)\n\nApply the third-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac164 left(phi_i - 3 - 6 phi_i - 2 + 15 phi_i - 1 + 44 phi_i + 15 phi_i + 1 - 6 phi_i + 2 + phi_i + 3right)\n\nwhere phi_i are the elements of input.\n\napply_shapiro_filter!(\n    output::AbstractVector{<:AbstractFloat},\n    input::AbstractVector{<:AbstractFloat},\n    scope::UnitRange{<:Integer},\n    order::Val{4},\n)\n\nApply the fourth-order Shapiro filter to input.\n\nThe elements of output are given by\n\nwidetildephi_i = frac1256 left(- phi_i - 4 + 8 phi_i - 3 - 28 phi_i - 2 + 56 phi_i - 1 + 186 phi_i + 56 phi_i + 1 - 28 phi_i + 2 + 8 phi_i + 3 - phi_i + 4right)\n\nwhere phi_i are the elements of input.\n\nArguments\n\noutput: Filtered output vector.\ninput: Input vector.\nscope: Index range.\norder: Order of the Shapiro filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!","text":"compute_gw_integrals!(state::State)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact by dispatching to a WKB-mode-specific method.\n\ncompute_gw_integrals!(state::State, wkb_mode::MultiColumn)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in multi-column mode.\n\nThis method computes the sums\n\nbeginalign*\n    overlinerho leftlangle u u rightrangle  = overlinerho sum_r lambda mu nu left(F u_mathrmw u_mathrmw^*right)_r i + lambda j + mu k + nu\n    overlinerho leftlangle u v rightrangle  = overlinerho sum_r lambda mu nu left(F u_mathrmw v_mathrmw^*right)_r i + lambda j + mu k + nu\n    overlinerho leftlangle u w rightrangle  = overlinerho sum_r lambda mu nu left(F u_mathrmw w_mathrmw^*right)_r i + lambda j + mu k + nu\n    overlinerho leftlangle v v rightrangle  = overlinerho sum_r lambda mu nu left(F v_mathrmw v_mathrmw^*right)_r i + lambda j + mu k + nu\n    overlinerho leftlangle v w rightrangle  = overlinerho sum_r lambda mu nu left(F v_mathrmw w_mathrmw^*right)_r i + lambda j + mu k + nu\n    leftlangle theta u rightrangle  = sum_r lambda mu nu left(F theta_mathrmw u_mathrmw^*right)_r i + lambda j + mu k + nu\n    leftlangle theta v rightrangle  = sum_r lambda mu nu left(F theta_mathrmw v_mathrmw^*right)_r i + lambda j + mu k + nu\n    mathcalE  = sum_r lambda mu nu left(F mathcalA widehatomegaright)_r i + lambda j + mu k + nu\nendalign*\n\nTherein, left(lambda mu nuright) are index shifts to ray volumes that are at least partially within the grid cell at left(i j kright), F_r i + lambda j + mu k + nu are the corresponding ray volume fractions and left(u_mathrmw v_mathrmw w_mathrmw theta_mathrmwright)_r i + lambda j + mu k + nu are the wave amplitudes of the wind and the potential temperature. The computation is based on the relations\n\nbeginalign*\n    overlinerho u_mathrmw r u_mathrmw r^*  = left(k_r widehatc_mathrmg x r - mathrmsgn left(leftfrightright) frack_r widehatc_mathrmg x r + l_r widehatc_mathrmg y r1 - left(widehatomega_r  fright)^2right) mathcalA_r\n    overlinerho u_mathrmw r v_mathrmw r^*  = l_r widehatc_mathrmg x r mathcalA_r\n    overlinerho u_mathrmw r w_mathrmw r^*  = frack_r widehatc_mathrmg z r1 - left(f  widehatomega_rright)^2 mathcalA_r\n    overlinerho v_mathrmw r v_mathrmw r^*  = left(l_r widehatc_mathrmg y r - mathrmsgn left(leftfrightright) frack_r widehatc_mathrmg x r + l_r widehatc_mathrmg y r1 - left(widehatomega_r  fright)^2right) mathcalA_r\n    overlinerho v_mathrmw r w_mathrmw r^*  = fracl_r widehatc_mathrmg z r1 - left(f  widehatomega_rright)^2 mathcalA_r\n    theta_mathrmw r u_mathrmw r^*  = fracf overlinethetag overlinerho fracl_r m_r N_r^2widehatomega_r leftboldsymbolk_rright^2 mathcalA_r\n    theta_mathrmw r v_mathrmw r^*  = - fracf overlinethetag overlinerho frack_r m_r N_r^2widehatomega_r leftboldsymbolk_rright^2 mathcalA_r\nendalign*\n\nwhere N_r^2 is the squared buoyancy frequency interpolated to the ray-volume position. The components of the intrinsic group velocity are given by\n\nbeginalign*\n    widehatc_mathrmg x r  = frack_r left(N_r^2 - widehatomega_r^2right)widehatomega_r leftboldsymbolk_rright^2\n    widehatc_mathrmg y r  = fracl_r left(N_r^2 - widehatomega_r^2right)widehatomega_r leftboldsymbolk_rright^2\n    widehatc_mathrmg z r  = - fracm_r left(widehatomega_r^2 - f^2right)widehatomega_r leftboldsymbolk_rright^2\nendalign*\n\ncompute_gw_integrals!(state::State, wkb_mode::SingleColumn)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in single-column mode.\n\nThis method computes overlinerho leftlangle u w rightrangle, overlinerho leftlangle v w rightrangle, leftlangle theta u rightrangle, leftlangle theta v rightrangle and mathcalE (see above for details).\n\ncompute_gw_integrals!(state::State, wkb_mode::SteadyState)\n\nCompute the gravity-wave integrals needed for the computation of the mean-flow impact in steady-state mode.\n\nThis method computes the sums overlinerho leftlangle u w rightrangle and overlinerho leftlangle v w rightrangle (see above for details). In contrast to the multi-column and single-column modes, the steady-state mode uses the pseudo-momentum approximation\n\nbeginalign*\n    overlinerho u_mathrmw r w_mathrmw r^*  = k_r widehatc_mathrmg z r mathcalA_r\n    overlinerho v_mathrmw r w_mathrmw r^*  = l_r widehatc_mathrmg z r mathcalA_r\nendalign*\n\nArguments\n\nstate::State: Model state.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.Interpolation.interpolate_stratification\nPinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices\nPinCFlow.MSGWaM.Interpolation.get_next_half_level\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!","text":"compute_gw_tendencies!(state::State)\n\nCompute the gravity-wave impact on the momentum and mass-weighted potential temperature.\n\nCalculates the tendencies that are to be added to the equations for momentum and mass-weighted potential temperature. These are given by\n\nbeginalign*\n    left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho leftfracleft(overlinerho leftlangle u u rightrangleright)_i + 1 - left(overlinerho leftlangle u u rightrangleright)_i - 12 Delta widehatx + G^13 fracleft(overlinerho leftlangle u u rightrangleright)_k + 1 - left(overlinerho leftlangle u u rightrangleright)_k - 12 Delta widehatzright\n     qquad qquad + fracleft(overlinerho leftlangle u v rightrangleright)_j + 1 - left(overlinerho leftlangle u v rightrangleright)_j - 12 Delta widehaty + G^23 fracleft(overlinerho leftlangle u v rightrangleright)_k + 1 - left(overlinerho leftlangle u v rightrangleright)_k - 12 Delta widehatz\n     qquad qquad + leftfracleft(overlinerho leftlangle u w rightrangleright)_k + 1 - left(overlinerho leftlangle u w rightrangleright)_k - 12 J Delta widehatzright - rho_mathrmb fracfoverlinetheta leftlangle theta v rightrangle\n    left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw  = - fracrho_mathrmboverlinerho leftfracleft(overlinerho leftlangle v u rightrangleright)_i + 1 - left(overlinerho leftlangle v u rightrangleright)_i - 12 Delta widehatx + G^13 fracleft(overlinerho leftlangle v u rightrangleright)_k + 1 - left(overlinerho leftlangle v u rightrangleright)_k - 12 Delta widehatzright\n     qquad qquad + fracleft(overlinerho leftlangle v v rightrangleright)_j + 1 - left(overlinerho leftlangle v v rightrangleright)_j - 12 Delta widehaty + G^23 fracleft(overlinerho leftlangle v v rightrangleright)_k + 1 - left(overlinerho leftlangle v v rightrangleright)_k - 12 Delta widehatz\n     qquad qquad + leftfracleft(overlinerho leftlangle v w rightrangleright)_k + 1 - left(overlinerho leftlangle v w rightrangleright)_k - 12 J Delta widehatzright + rho_mathrmb fracfoverlinetheta leftlangle theta u rightrangle\n    left(fracpartial rho_mathrmb widehatw_mathrmbpartial tright)_mathrmw  = G^13 left(fracpartial rho_mathrmb u_mathrmbpartial tright)_mathrmw + G^23 left(fracpartial rho_mathrmb v_mathrmbpartial tright)_mathrmw\n    left(fracpartial P_mathrmbpartial tright)_mathrmw  = - rho_mathrmb leftfracleft(overlinerho leftlangle theta u rightrangleright)_i + 1 - left(overlinerho leftlangle theta u rightrangleright)_i - 12 Delta widehatx + G^13 fracleft(overlinerho leftlangle theta u rightrangleright)_k + 1 - left(overlinerho leftlangle theta u rightrangleright)_k - 12 Delta widehatzright\n     qquad qquad + leftfracleft(overlinerho leftlangle theta v rightrangleright)_j + 1 - left(overlinerho leftlangle theta v rightrangleright)_j - 12 Delta widehaty + G^23 fracleft(overlinerho leftlangle theta v rightrangleright)_k + 1 - left(overlinerho leftlangle theta v rightrangleright)_k - 12 Delta widehatzright\nendalign*\n\nwhere left(u_mathrmb v_mathrmb widehatw_mathrmbright) are the components of the transformed (i.e. terrain-following) resolved wind, rho_mathrmb is the resolved density (including the reference part overlinerho) and P_mathrmb is the resolved mass-weighted potential temperature. For a documentation of the fluxes, see PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!. Below state.namelists.wkb.impact_altitude, all tendencies are set to zero.\n\nArguments\n\nstate::State: Model state.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices","text":"compute_horizontal_cell_indices(\n    state::State,\n    xr::AbstractFloat,\n    yr::AbstractFloat,\n    dxr::AbstractFloat,\n    dyr::AbstractFloat,\n)::NTuple{4, <:Integer}\n\nFrom the given horizontal ray-volume position and extent, determine the indices of the grid cells that contain the ray-volume edges and return them (in the order left, right, backward and forward).\n\nArguments\n\nstate: Model state.\nxr: Ray-volume position in x.\nyr: Ray-volume position in y.\ndxr: Ray-volume extent in x.\ndyr: Ray-volume extent in y.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!","text":"compute_leading_order_tracer_fluxes!(\n    state::State,\n    tracer_setup::NoTracer,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)\n\nReturn for configurations without tracer transport.\n\ncompute_leading_order_tracer_fluxes!(\n    state::State,\n    tracer_setup::TracerOn,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n)\n\nCompute the leading-order gravity-wave tracer fluxes at (i j k).\n\nThe zonal, meridional, and vertical fluxes are given by\n\nbeginalign*\n    overlinerholeftlangle u chirightrangle  = overlinerhosum_r lambdamunuleft(F u_mathrmwchi^*_mathrmwright)_r i + lambda j + mu k + nu\n    overlinerholeftlangle v chirightrangle  = overlinerhosum_r  lambda mu nu left(F v_mathrmw chi^*_mathrmwright)_r i + lambda j + mu k + nu\n    overlinerholeftlangle w chirightrangle  = overlinerhosum_r lambda mu nu left(F w_mathrmw chi^*_mathrmwright)_r i + lambda j + mu k + nu\nendalign*\n\nArguments:\n\nstate: Model state.\ntracer_setup:  General tracer-transport configuration.\nfc: Coriolis parameter.\nomir: Gravity-wave intrinsic frequency.\nwnrk: Zonal wavenumber.\nwnrl: Meridional wavenumber.\nwnrm: Vertical wavenumber.\nwadr: Phase-space wave-action density.\nxlc: Zonal location of the ray-volume.\nylc: Meridional location of the ray-volume.\nzlc: Vertical location of the ray-volume.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\n\nSee also:\n\nPinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!-Tuple{State, Integer, Integer, Integer, TracerOn}","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!","text":"compute_leading_order_tracer_forcing!(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    tracer_setup::TracerOn,\n)\n\nCompute and return the leading-order tracer forcing at left(i j kright).\n\ncompute_leading_order_tracer_forcing!(\n    state::State,\n    i::Integer,\n    j::Integer,\n    k::Integer,\n    tracer_setup::NoTracer,\n)\n\nReturn for configurations without tracer transport.\n\nArguments\n\nstate: Model state.\ni: Zonal grid-cell index.\nj: Meridional grid-cell index.\nk: Vertical grid-cell index.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"method"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!","text":"compute_mean_flow_effect!(state::State)\n\nCalculate the mean-flow impact of unresolved gravity waves by dispatching to a WKB-mode-specific method.\n\ncompute_mean_flow_effect!(state::State, wkb_mode::NoWKB)\n\nReturn for non-WKB configurations.\n\ncompute_mean_flow_effect!(\n    state::State,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)\n\nCalculate the mean-flow impact of unresolved gravity waves.\n\nThis method first computes several spectral integrals (using compute_gw_integrals!), most of which represent gravity-wave fluxes. After the boundary conditions for these have been enforced (using set_boundaries!), the corresponding tendencies are calculated (using compute_gw_tendencies!). These also have boundary conditions that need to be enforced (once again using set_boundaries!) before they are smoothed to remove small-scale features that may occur due to a coarse ray-volume distribution (using smooth_gw_tendencies!). Afterwards, if MS-GWaM parameterizes mountain waves, the tendencies are adjusted to account for the formation of blocked layers (using apply_blocked_layer_scheme!), before the boundary conditions are enforced again.\n\nArguments\n\nstate: Model state.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!\nPinCFlow.Boundaries.set_boundaries!\nPinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!\nPinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!\nPinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes","text":"leading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::UChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the zonal leading-order gravity-wave tracer fluxes overlinerholangle uchirangle.\n\nThe flux-contributions are given by\n\noverlinerho u_mathrmw rchi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftl_r left(fracpartial chi_mathrmbpartial zright)_r - m_r left(fracpartial chi_mathrmbpartial yright)_rright\n\nleading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::VChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the meridional leading-order gravity-wave tracer fluxes overlinerholangle vchirangle.\n\nThe fluxes are given by\n\noverlinerho v_mathrmw r chi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftm_r left(fracpartial chi_mathrmbpartial xright)_r - k_r left(fracpartial chi_mathrmbpartial zright)_rright\n\nleading_order_tracer_fluxes(\n    state::State,\n    fc::AbstractFloat,\n    omir::AbstractFloat,\n    wnrk::AbstractFloat,\n    wnrl::AbstractFloat,\n    wnrm::AbstractFloat,\n    wadr::AbstractFloat,\n    xlc::AbstractFloat,\n    ylc::AbstractFloat,\n    zlc::AbstractFloat,\n    direction::WChi,\n)::AbstractFloat\n\nCompute and return the contribution of a ray volume located at (xlc,ylc,zlc) to the vertical leading-order gravity-wave tracer fluxes overlinerholangle wchirangle.\n\nThe fluxes are given by\n\noverlinerho w_mathrmw r chi^*_mathrmw r = fracfwidehatomega_r fracm_rleftboldsymbolk_rright^2 mathcalA_r leftk_r left(fracpartial chi_mathrmbpartial yright)_r - l_r left(fracpartial chi_mathrmbpartial xright)_rright\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!","text":"set_tracer_field_zero!(state)\n\nReset the gravity-wave-induced tracer fluxes to zero by dispatching over tracer configurations.\n\nset_tracer_field_zero!(state::State, tracer_setup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nset_tracer_field_zero!(state::State, tracer_setup::TracerOn)\n\nSet the gravity-wave-induced tracer fluxes to zero.\n\nArguments:\n\nstate: Model state.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"function"},{"location":"reference/msgwam/#PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!","page":"MSGWaM","title":"PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!","text":"smooth_gw_tendencies!(state::State)\n\nApply spatial smoothing to gravity-wave tendency fields by dispatching to a method specific for the chosen filter (state.namelists.wkb.filter_type) and dimensionality of the domain.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Box,\n    direction::XYZ,\n)\n\nApply a 3D box filter to smooth in all spatial directions.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 3 sumlimits_lambda = i - N_mathrms^i + N_mathrms sumlimits_mu = j - N_mathrms^j + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_lambda mu nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.filter_order).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Box,\n    direction::XZ,\n)\n\nApply a 2D box filter to smooth in widehatx and widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 2 sumlimits_lambda = i - N_mathrms^i + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_lambda j nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.filter_order).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Box,\n    direction::YZ,\n)\n\nApply a 2D box filter to smooth in widehaty and widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 2 sumlimits_mu = j - N_mathrms^j + N_mathrms sumlimits_nu = k - N_mathrms^k + N_mathrms phi_i mu nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.filter_order).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Box,\n    direction::Z,\n)\n\nApply a 1D box filter to smooth in widehatz.\n\nApplies the moving average\n\nwidetildephi_i j k = left(2 N_mathrms + 1right)^- 1 sumlimits_nu = k - N_mathrms^k + N_mathrms phi_i j nu\n\nwhere N_mathrms is the order of the filter (state.namelists.wkb.filter_order).\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::XYZ,\n)\n\nApply a 3D Shapiro filter to smooth in all spatial directions.\n\nA 1D Shapiro filter is applied sequentially in widehatx, widehaty and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::XZ,\n)\n\nApply a 2D Shapiro filter to smooth in widehatx and widehatz.\n\nA 1D Shapiro filter is applied sequentially in widehatx and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::YZ,\n)\n\nApply a 2D Shapiro filter to smooth in widehaty and widehatz.\n\nA 1D Shapiro filter is applied sequentially in widehaty and widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::Z,\n)\n\nApply a 1D Shapiro filter to smooth in widehatz.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::Y,\n)\n\nApply a 1D Shapiro filter to smooth in widehaty.\n\nsmooth_gw_tendencies!(\n    output::AbstractArray{<:AbstractFloat, 3},\n    state::State,\n    filter_type::Shapiro,\n    direction::X,\n)\n\nApply a 1D Shapiro filter to smooth in widehatx.\n\nsmooth_gw_tendencies!(state::State, tracer_setup::TracerOn)\n\nApply smoothing to tracer tendencies.\n\nsmooth_gw_tendencies!(state::State, tracer_setup::NoTracer)\n\nReturn for configurations without tracer transport.\n\nArguments\n\nstate: Model state.\noutput: Field to smooth.\nfilter_type: Filter type.\ndirection: Directions to smooth in.\ntracer_setup: General tracer-transport configuration.\n\nSee also\n\nPinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"reference/types/#NamelistTypes","page":"Types","title":"NamelistTypes","text":"","category":"section"},{"location":"reference/types/#FoundationalTypes","page":"Types","title":"FoundationalTypes","text":"","category":"section"},{"location":"reference/types/#VariableTypes","page":"Types","title":"VariableTypes","text":"","category":"section"},{"location":"reference/types/#PoissonTypes","page":"Types","title":"PoissonTypes","text":"","category":"section"},{"location":"reference/types/#WKBTypes","page":"Types","title":"WKBTypes","text":"","category":"section"},{"location":"reference/types/#TracerTypes","page":"Types","title":"TracerTypes","text":"","category":"section"},{"location":"reference/types/#PinCFlow.Types","page":"Types","title":"PinCFlow.Types","text":"Types\n\nModule for the construction of a single composite type that contains all information on the current model state.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.PoissonTypes\nPinCFlow.Types.VariableTypes\nPinCFlow.Types.WKBTypes\nPinCFlow.Types.TracerTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.AbstractPredictand","page":"Types","title":"PinCFlow.Types.AbstractPredictand","text":"AbstractPredictand\n\nAbstract type for prognostic variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Chi","page":"Types","title":"PinCFlow.Types.Chi","text":"Chi\n\nSingleton that represents the tracer mixing ratio.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Explicit","page":"Types","title":"PinCFlow.Types.Explicit","text":"Explicit\n\nSingleton for explicit integration in time.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Implicit","page":"Types","title":"PinCFlow.Types.Implicit","text":"Implicit\n\nSingleton for implicit integration in time.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.P","page":"Types","title":"PinCFlow.Types.P","text":"P <: AbstractPredictand\n\nSingleton that represents the mass-weighted potential temperature.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PiP","page":"Types","title":"PinCFlow.Types.PiP","text":"PiP <: AbstractPredictand\n\nSingleton that represents the Exner-pressure fluctuations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Rho","page":"Types","title":"PinCFlow.Types.Rho","text":"Rho <: AbstractPredictand\n\nSingleton that represents density fluctuations predicted with the continuity equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.RhoP","page":"Types","title":"PinCFlow.Types.RhoP","text":"RhoP <: AbstractPredictand\n\nSingleton that represents density fluctuations predicted with the auxiliary equation.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.State","page":"Types","title":"PinCFlow.Types.State","text":"State{\n    A <: Namelists,\n    B <: Time,\n    C <: Constants,\n    D <: Domain,\n    E <: Grid,\n    F <: Atmosphere,\n    G <: Sponge,\n    H <: Poisson,\n    I <: Variables,\n    J <: WKB,\n    K <: Tracer,\n}\n\nModel state container.\n\nAn instance of this composite type holds complete information about the model configuration and simulation state, so that it is sufficient as primary input to most methods. The construction of such an instance is the first operation performed in PinCFlow.Integration.integrate, since it almost fully initializes the model.\n\nState(namelists::Namelists)::State\n\nConstruct a State instance and thus initialize the model.\n\nThis method first uses the parameters specified in namelists to construct instances of the composite types defined in FoundationalTypes (i.e. Constants, Time, Domain, Grid, Atmosphere and Sponge). It then uses these instances to prepare the arrays needed for the Poisson solver, the time integration and the parameterization of unresolved gravity waves with MS-GWaM. Afterwards, only three operations of the initialization process remain (these are performed by PinCFlow.Integration.integrate), namely the initial cleaning, the setting of the initial ray-volume properties and the reading of input data in restart simulations.\n\nFields\n\nnamelists::A: Namelists with all model parameters.\ntime::B: Runge-Kutta time integration coefficients.\nconstants::C: Physical constants and reference values.\ndomain::D: Collection of domain-decomposition and MPI-communication parameters.\ngrid::E: Collection of parameters and fields that describe the grid.\natmosphere::F: Atmospheric-background fields.\nsponge::G: Sponge parameters and damping coefficients.\npoisson::H: Workspace and solution arrays for the Poisson solver.\nvariables::I: Arrays needed for the predictions of the prognostic variables.\nwkb::J: Container for WKB ray-tracing data and parameters.\ntracer::K: Tracer setup and parameters.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.Constants\nPinCFlow.Types.FoundationalTypes.Time\nPinCFlow.Types.FoundationalTypes.Domain\nPinCFlow.Types.FoundationalTypes.Grid\nPinCFlow.Types.FoundationalTypes.Atmosphere\nPinCFlow.Types.FoundationalTypes.Sponge\nPinCFlow.Types.PoissonTypes.Poisson\nPinCFlow.Types.VariableTypes.Variables\nPinCFlow.Types.WKBTypes.WKB\nPinCFlow.Types.TracerTypes.Tracer\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.Theta","page":"Types","title":"PinCFlow.Types.Theta","text":"Theta\n\nSingleton that represents the potential temperature.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.U","page":"Types","title":"PinCFlow.Types.U","text":"U <: AbstractPredictand\n\nSingleton that represents the zonal wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.V","page":"Types","title":"PinCFlow.Types.V","text":"V <: AbstractPredictand\n\nSingleton that represents the meridional wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.W","page":"Types","title":"PinCFlow.Types.W","text":"W <: AbstractPredictand\n\nSingleton that represents the (transformed) vertical wind.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes","page":"Types","title":"PinCFlow.Types.NamelistTypes","text":"NamelistTypes\n\nModule that contains all namelist types.\n\nProvides constructors that allow setting only specific parameters and using default values for the rest.\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractBackground","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractBackground","text":"AbstractBackground\n\nAbstract type for atmospheric background configurations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractLimiter","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractLimiter","text":"AbstractLimiter\n\nAbstract type for flux limiters used in the reconstruction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractMergeMode","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractMergeMode","text":"AbstractMergeMode\n\nAbstract type for ray-volume merge algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractModel","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractModel","text":"AbstractModel\n\nAbstract type for levels of compressibility.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractTracer","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractTracer","text":"AbstractTracer\n\nAbstract type for the inclusion of a tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractWKBFilter","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractWKBFilter","text":"AbstractWKBFilter\n\nAbstract type for filtering methods applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AbstractWKBMode","page":"Types","title":"PinCFlow.Types.NamelistTypes.AbstractWKBMode","text":"AbstractWKBMode\n\nAbstract type for approximations in WKB theory.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.AtmosphereNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.AtmosphereNamelist","text":"AtmosphereNamelist{\n    A <: AbstractModel,\n    B <: Bool,\n    C <: Float64,\n    D <: AbstractBackground,\n    E <: Function,\n    F <: Function,\n    G <: Function,\n    H <: Function,\n    I <: Function,\n    J <: Function,\n}\n\nNamelist for parameters used in the definition of the atmospheric background and the initialization of prognostic variables.\n\nAtmosphereNamelist(;\n    model::AbstractModel = PseudoIncompressible(),\n    specify_reynolds_number::Bool = false,\n    inverse_reynolds_number::Real = 0.0E+0,\n    kinematic_viscosity::Real = 1.5E-5,\n    thermal_conductivity::Real = 3.0E-5,\n    kinematic_diffusivity::Real = 0.0E+0,\n    background::AbstractBackground = Isothermal(),\n    buoyancy_frequency::Real = 1.0E-2,\n    potential_temperature::Real = 3.0E+2,\n    temperature::Real = 3.0E+2,\n    ground_pressure::Real = 1.0E+5,\n    coriolis_frequency::Real = 1.0E-4,\n    tropopause_height::Real = 1.0E+4,\n    troposphere_lapse_rate::Real = 6.5E-3,\n    stratosphere_lapse_rate::Real = -5.0E-3,\n    initial_rhop::Function = (x, y, z) -> 0.0,\n    initial_u::Function = (x, y, z) -> 0.0,\n    initial_v::Function = (x, y, z) -> 0.0,\n    initial_w::Function = (x, y, z) -> 0.0,\n    initial_pip::Function = (x, y, z) -> 0.0,\n)::AtmosphereNamelist\n\nConstruct an AtmosphereNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\nmodel::A: Dynamic equations.\nspecify_reynolds_number::B: Flag to specify inverse Reynolds number instead of viscosity.\ninverse_reynolds_number::C: Inverse Reynolds number.\nkinematic_viscosity::C: Kinematic viscosity at the surface.\nthermal_conductivity::C: Thermal conductivity at the surface.\nkinematic_diffusivity::C: Kinematic diffusivity at the surface.\nbackground::D: Atmospheric background.\nbuoyancy_frequency::C: Buoyancy frequency if background == StableStratification().\npotential_temperature::C: Reference potential temperature.\ntemperature::C: Reference temperature.\nground_pressure::C: Reference pressure.\ncoriolis_frequency::C: Coriolis frequency of the f-plane.\ntropopause_height::C: Height of the tropopause for background == Realistic() or background == LapseRates().\ntroposphere_lapse_rate::C: Lapse rate in the troposphere for background == LapseRates().\nstratosphere_lapse_rate::C: Lapse rate in the stratosphere for background == LapseRates().\ninitial_rhop::E: Function used to initialize the density fluctuations.\ninitial_u::F: Function used to initialize the zonal wind.\ninitial_v::G: Function used to initialize the meridional wind.\ninitial_w::H: Function used to initialize the vertical wind.\ninitial_pip::I: Function used to initialize the Exner-pressure fluctuations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Boussinesq","page":"Types","title":"PinCFlow.Types.NamelistTypes.Boussinesq","text":"Boussinesq <: AbstractModel\n\nSingleton for Boussinesq dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Box","page":"Types","title":"PinCFlow.Types.NamelistTypes.Box","text":"Box <: AbstractWKBFilter\n\nSingleton for a box filter as smoothing method applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Compressible","page":"Types","title":"PinCFlow.Types.NamelistTypes.Compressible","text":"Compressible <: AbstractModel\n\nSingleton for compressible dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.ConstantWaveAction","page":"Types","title":"PinCFlow.Types.NamelistTypes.ConstantWaveAction","text":"ConstantWaveAction <: AbstractMergeMode\n\nSingleton for the constant-wave-action ray-volume merging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.ConstantWaveEnergy","page":"Types","title":"PinCFlow.Types.NamelistTypes.ConstantWaveEnergy","text":"ConstantWaveEnergy <: AbstractMergeMode\n\nSingleton for the constant-wave-energy ray-volume merging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.DiscretizationNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.DiscretizationNamelist","text":"DiscretizationNamelist{A <: Float64, B <: Bool, C <: AbstractLimiter}\n\nNamelist for parameters describing the discretization.\n\nDiscretizationNamelist(;\n    cfl_number::Real = 5.0E-1,\n    wkb_cfl_number::Real = 5.0E-1,\n    dtmin::Real = 1.0E-6,\n    dtmax::Real = 1.0E+3,\n    adaptive_time_step::Bool = true,\n    limiter_type::AbstractLimiter = MCVariant(),\n)::DiscretizationNamelist\n\nConstruct a DiscretizationNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\ncfl_number::A: Number used for the CFL condition in the time step computation.\nwkb_cfl_number::A: Number used for the WKB-CFL condition in the time step computation.\ndtmin::A: Minimum time step allowed for the integration.\ndtmax::A: Maximum time step allowed for the integration.\nadaptive_time_step::B: Switch for using stability criteria to determine the time step. If set to false, dtmax is used as a fixed time step.\nlimiter_type::C: Flux limiter used by the MUSCL scheme.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.DomainNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.DomainNamelist","text":"DomainNamelist{A <: Int, B <: Float64, C <: MPI.Comm}\n\nNamelist for parameters describing the model domain.\n\nDomainNamelist(;\n    x_size::Integer = 1,\n    y_size::Integer = 1,\n    z_size::Integer = 1,\n    nbx::Integer = 3,\n    nby::Integer = 3,\n    nbz::Integer = 3,\n    lx::Real = 1.0E+3,\n    ly::Real = 1.0E+3,\n    lz::Real = 1.0E+3,\n    npx::Integer = 1,\n    npy::Integer = 1,\n    npz::Integer = 1,\n    base_comm::MPI.Comm = MPI.COMM_WORLD,\n)::DomainNamelist\n\nConstruct a DomainNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\nx_size::A: Number of grid cells in widehatx-direction.\ny_size::A: Number of grid cells in widehaty-direction.\nz_size::A: Number of grid cells in widehatz-direction.\nnbx::A: Number of boundary/halo cells in widehatx-direction.\nnby::A: Number of boundary/halo cells in widehaty-direction.\nnbz::A: Number of boundary/halo cells in widehatz-direction.\nlx::B: Domain extent in widehatx-direction.\nly::B: Domain extent in widehaty-direction.\nlz::B: Domain extent in widehatz-direction.\nnpx::A: Number of MPI processes in widehatx-direction.\nnpy::A: Number of MPI processes in widehaty-direction.\nnpz::A: Number of MPI processes in widehatz-direction.\nbase_comm::C: MPI base communicator.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.GridNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.GridNamelist","text":"GridNamelist{A <: Float64, B <: Function, C <: Function}\n\nNamelist for parameters describing the grid.\n\nGridNamelist(;\n    stretch_exponent::Real = 1.0E+0,\n    resolved_topography::Function = (x, y) -> 0.0,\n    unresolved_topography::Function = (alpha, x, y) -> (0.0, 0.0, 0.0),\n)::GridNamelist\n\nConstruct a GridNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\nstretch_exponent::A: Vertical-grid-stretching parameter.\nresolved_topography::B: Function that returns the resolved topography at a specified horizontal position.\nresolved_topography::C: Function that returns a specified spectral mode of the unresolved topography at a specified horizontal position.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Isentropic","page":"Types","title":"PinCFlow.Types.NamelistTypes.Isentropic","text":"Isentropic <: AbstractBackground\n\nSingleton for an isentropic atmosphere in pseudo-incompressible or compressible mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Isothermal","page":"Types","title":"PinCFlow.Types.NamelistTypes.Isothermal","text":"Isothermal <: AbstractBackground\n\nSingleton for an isothermal atmosphere in pseudo-incompressible or compressible mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.LapseRates","page":"Types","title":"PinCFlow.Types.NamelistTypes.LapseRates","text":"LapseRates <: AbstractBackground\n\nSingleton for an atmosphere with different lapse rates in the troposphere and stratosphere in pseudo-incompressible or compressible mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.MCVariant","page":"Types","title":"PinCFlow.Types.NamelistTypes.MCVariant","text":"MCVariant <: AbstractLimiter\n\nSingleton for the MC-Variant limiter function (used in reconstruction).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.MultiColumn","page":"Types","title":"PinCFlow.Types.NamelistTypes.MultiColumn","text":"MultiColumn <: AbstractWKBMode\n\nSingleton for the multi-column approximation in MS-GWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Namelists","page":"Types","title":"PinCFlow.Types.NamelistTypes.Namelists","text":"Namelists{\n    A <: DomainNamelist,\n    B <: OutputNamelist,\n    C <: DiscretizationNamelist,\n    D <: PoissonNamelist,\n    E <: AtmosphereNamelist,\n    F <: GridNamelist,\n    G <: SpongeNamelist,\n    H <: WKBNamelist,\n    I <: TracerNamelist,\n}\n\nCollection of all configurable model parameters.\n\nNamelists(;\n    domain::DomainNamelist = DomainNamelist(),\n    output::OutputNamelist = OutputNamelist(),\n    discretization::DiscretizationNamelist = DiscretizationNamelist(),\n    poisson::PoissonNamelist = PoissonNamelist(),\n    atmosphere::AtmosphereNamelist = AtmosphereNamelist(),\n    grid::GridNamelist = GridNamelist(),\n    sponge::SpongeNamelist = SpongeNamelist(),\n    wkb::WKBNamelist = WKBNamelist(),\n    tracer::TracerNamelist = TracerNamelist(),\n)::Namelists\n\nConstruct a Namelists instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ndomain::A: Namelist for parameters describing the model domain.\noutput::B: Namelist for I/O parameters.\ndiscretization::C: Namelist for parameters describing discretization.\npoisson::D: Namelist for parameters used by the Poisson solver.\natmosphere::E: Namelist for parameters describing the atmospheric background.\ngrid::F: Namelist for parameters describing the grid.\nsponge::G: Namelist for parameters describing the sponge.\nwkb::H: Namelist for parameters used by MS-GWaM.\ntracer::I: Namelist for parameters configuring tracer transport.\n\nSee also\n\nPinCFlow.Types.NamelistTypes.DomainNamelist\nPinCFlow.Types.NamelistTypes.OutputNamelist\nPinCFlow.Types.NamelistTypes.DiscretizationNamelist\nPinCFlow.Types.NamelistTypes.PoissonNamelist\nPinCFlow.Types.NamelistTypes.AtmosphereNamelist\nPinCFlow.Types.NamelistTypes.GridNamelist\nPinCFlow.Types.NamelistTypes.SpongeNamelist\nPinCFlow.Types.NamelistTypes.WKBNamelist\nPinCFlow.Types.NamelistTypes.TracerNamelist\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.NeutralStratification","page":"Types","title":"PinCFlow.Types.NamelistTypes.NeutralStratification","text":"NeutralStratification <: AbstractBackground\n\nSingleton for a Boussinesq atmosphere with neutral stratification.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.NoTracer","page":"Types","title":"PinCFlow.Types.NamelistTypes.NoTracer","text":"NoTracer <: AbstractTracer\n\nSingleton for model configurations without a tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.NoWKB","page":"Types","title":"PinCFlow.Types.NamelistTypes.NoWKB","text":"NoWKB <: AbstractWKBMode\n\nSingleton for switching off MS-GWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.OutputNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.OutputNamelist","text":"OutputNamelist{\n    A <: Tuple{Vararg{Symbol}},\n    B <: Bool,\n    C <: Int,\n    D <: Float64,\n    E <: String,\n}\n\nNamelist for I/O parameters.\n\nOutputNamelist(;\n    output_variables::Tuple{Vararg{Symbol}} = (),\n    save_ray_volumes::Bool = false,\n    prepare_restart::Bool = false,\n    restart::Bool = false,\n    iin::Integer = -1,\n    output_steps::Bool = false,\n    nout::Integer = 1,\n    iterations::Integer = 1,\n    output_interval::Real = 3.6E+3,\n    tmax::Real = 3.6E+3,\n    input_file::AbstractString = \"./pincflow_input.h5\",\n    output_file::AbstractString = \"./pincflow_output.h5\",\n)::OutputNamelist\n\nConstruct an OutputNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\noutput_variables::A: A tuple of symbols representing the variables that should be written to the output file.\nsave_ray_volumes::B: A boolean indicating whether to write ray-volume data.\nprepare_restart::B: A boolean indicating whether to write all variables needed for restart simulations.\nrestart::B: A boolean indicating whether to initialize with data from a previous state (as written in input_file).\niin::C: Temporal index in input_file at which to read the data to initialize with in restart simulations. If it's set to the default value -1, the data will be read at the last index.\noutput_steps::B: If set to true, write output every nout time steps.\nnout::C: Output interval (in indices) if output_steps == true.\niterations::C: Maximum number of iterations if output_steps == true.\noutput_interval::D: Output interval (in physical time) if output_steps == false.\ntmax::D: Simulation time if output_steps == false.\ninput_file::E: File from which to read input data in restart simulations.\noutput_file::E: File to which output data is written.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.PoissonNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.PoissonNamelist","text":"PoissonNamelist{A <: Float64, B <: Int, C <: Bool}\n\nNamelist for parameters used by the Poisson solver.\n\nPoissonNamelist(;\n    tolerance::Real = 1.0E-8,\n    poisson_iterations::Integer = 1000,\n    preconditioner::Bool = true,\n    dtau::Real = 1.0E+0,\n    preconditioner_iterations::Integer = 2,\n    initial_cleaning::Bool = true,\n    tolerance_is_relative::Bool = false,\n)::PoissonNamelist\n\nConstruct a PoissonNamelists instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\ntolerance::A: Tolerance for the convergence criterion of the Poisson solver.\npoisson_iterations::B: Maximum number of iterations performed by the Poisson solver before it terminates regardless of convergence.\npreconditioner::C: Whether to use a preconditioner to accelerate the convergence of the Poisson solver.\ndtau::A: Pseudo-time step coefficient used by the preconditioner.\npreconditioner_iterations::B: Number of iterations performed by the preconditioner.\ninitial_cleaning::C: Whether to solve the Poisson problem at initialization to guarantee an initially divergence-free state.\ntolerance_is_relative::C: If set to true, the tolerance used for the convergence criterion is given by tolerance. If set to false, the tolerance is given by tolerance divided by a reference value determined from the right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.PseudoIncompressible","page":"Types","title":"PinCFlow.Types.NamelistTypes.PseudoIncompressible","text":"PseudoIncompressible <: AbstractModel\n\nSingleton for pseudo-incompressible dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Realistic","page":"Types","title":"PinCFlow.Types.NamelistTypes.Realistic","text":"Realistic <: AbstractBackground\n\nSingleton for a realistic atmosphere in pseudo-incompressible or compressible mode (isentropic troposphere and isothermal stratosphere).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.Shapiro","page":"Types","title":"PinCFlow.Types.NamelistTypes.Shapiro","text":"Shapiro <: AbstractWKBFilter\n\nSingleton for a Shapiro filter as smoothing method applied to mean-flow tendencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SingleColumn","page":"Types","title":"PinCFlow.Types.NamelistTypes.SingleColumn","text":"SingleColumn <: AbstractWKBMode\n\nSingleton for the single-column approximation in MS-GWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SpongeNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.SpongeNamelist","text":"SpongeNamelist{\n    A <: Bool,\n    B <: Function,\n    C <: Function,\n    D <: Function,\n    E <: Function,\n    F <: Function,\n}\n\nNamelist for parameters describing the sponge.\n\nSpongeNamelist(;\n    damp_horizontal_wind_on_rhs::Bool = false,\n    relax_to_mean::Bool = false,\n    lhs_sponge::Function = (x, y, z, t, dt) -> 0.0,\n    rhs_sponge::Function = (x, y, z, t, dt) -> 0.0,\n    relaxed_u::Function = (x, y, z, t, dt) -> 0.0,\n    relaxed_v::Function = (x, y, z, t, dt) -> 0.0,\n    relaxed_w::Function = (x, y, z, t, dt) -> 0.0,\n)::SpongeNamelist\n\nConstruct a SpongeNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\ndamp_horizontal_wind_on_rhs::A: Switch for applying the RHS sponge to the horizontal wind.\nrelax_to_mean::A: Switch for relaxing the wind towards its averages on the terrain-following surfaces. If set to false, the relaxation wind is computed with relaxed_u, relaxed_v and relaxed_w.\nlhs_sponge::B: Function used to compute the Rayleigh-damping coefficient of the LHS sponge.\nrhs_sponge::C: Function used to compute the Rayleigh-damping coefficient of the RHS sponge.\nrelaxed_u::D: Function used to compute the zonal relaxation wind if relax_to_mean is set to false.\nrelaxed_v::E: Function used to compute the meridional relaxation wind if relax_to_mean is set to false.\nrelaxed_w::F: Function used to compute the vertical relaxation wind if relax_to_mean is set to false.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.StableStratification","page":"Types","title":"PinCFlow.Types.NamelistTypes.StableStratification","text":"StableStratification <: AbstractBackground\n\nSingleton for a Boussinesq atmosphere with stable stratification.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.SteadyState","page":"Types","title":"PinCFlow.Types.NamelistTypes.SteadyState","text":"SteadyState <: AbstractWKBMode\n\nSingleton for the steady-state approximation in MS-GWaM.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.TracerNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.TracerNamelist","text":"TracerNamelist{A <: AbstractTracer, B <: Bool, C <: Function}\n\nNamelist for the inclusion of a tracer and the calculation of the leading-order gravity-wave impact.\n\nTracerNamelist(;\n    tracer_setup::AbstractTracer = NoTracer(),\n    leading_order_impact::Bool = false,\n    initial_tracer::Function = (x, y, z) -> 0.0,\n)::TracerNamelist\n\nConstruct a TracerNamelist instance with the given keyword arguments as properties.\n\nFields/Keywords\n\ntracer_setup::A: General tracer configuration.\nleading_order_impact::B: Flag to include the leading-order impact of gravity waves when parameterizing waves with the WKB model.\ninitial_tracer::C: Function used to initialize the tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.TracerOn","page":"Types","title":"PinCFlow.Types.NamelistTypes.TracerOn","text":"TracerOn <: AbstractTracer\n\nSingleton for model configurations with an initially linear tracer.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.NamelistTypes.WKBNamelist","page":"Types","title":"PinCFlow.Types.NamelistTypes.WKBNamelist","text":"WKBNamelist{\n    A <: Int,\n    B <: Float64,\n    C <: AbstractMergeMode,\n    D <: Bool,\n    E <: AbstractWKBFilter,\n    F <: AbstractWKBMode,\n    G <: Function,\n}\n\nNamelist for parameters used by MS-GWaM.\n\nWKBNamelist(;\n    nrx::Integer = 1,\n    nry::Integer = 1,\n    nrz::Integer = 1,\n    nrk::Integer = 1,\n    nrl::Integer = 1,\n    nrm::Integer = 1,\n    multiplication_factor::Integer = 4,\n    dkr_factor::Real = 1.0E-1,\n    dlr_factor::Real = 1.0E-1,\n    dmr_factor::Real = 1.0E-1,\n    branch::Integer = -1,\n    merge_mode::AbstractMergeMode = ConstantWaveAction(),\n    filter_order::Integer = 2,\n    smooth_tendencies::Bool = true,\n    filter_type::AbstractWKBFilter = Shapiro(),\n    impact_altitude::Real = 0.0E+0,\n    use_saturation::Bool = true,\n    saturation_threshold::Real = 1.0E+0,\n    wkb_mode::AbstractWKBMode = NoWKB(),\n    blocking::Bool = false,\n    long_threshold::Real = 2.5E-1,\n    drag_coefficient::Real = 1.0E+0,\n    wave_modes::Integer = 1,\n    initial_wave_field::Function = (alpha, x, y, z) ->\n        (0.0, 0.0, 0.0, 0.0, 0.0),\n)::WKBNamelist\n\nConstruct a WKBNamelist instance with the given keyword arguments as properties, converting them to meet the type constraints.\n\nFields/Keywords\n\nnrx::A: Number of ray-volumes launched per grid cell and wave mode in widehatx-direction.\nnry::A: Number of ray-volumes launched per grid cell and wave mode in widehaty-direction.\nnrz::A: Number of ray-volumes launched per grid cell and wave mode in widehatz-direction.\nnrk::A: Number of ray-volumes launched per grid cell and wave mode in k-direction.\nnrl::A: Number of ray-volumes launched per grid cell and wave mode in l-direction.\nnrm::A: Number of ray-volumes launched per grid cell and wave mode in m-direction.\nmultiplication_factor::A: Factor by which ray volumes are allowed to multiply in each dimension of physical space.\ndkr_factor::B: Relative initial ray-volume extent in k.\ndlr_factor::B: Relative initial ray-volume extent in l.\ndmr_factor::B: Relative initial ray-volume extent in m.\nbranch::A: Frequency branch.\nmerge_mode::C: Ray-volume merging strategy (conserved quantity).\nfilter_order::A: Order of the smoothing applied to the mean-flow tendencies.\nsmooth_tendencies::D: Switch for smoothing the mean-flow tendencies.\nfilter_type::E: Filter to use for the smoothing of the mean-flow tendencies.\nimpact_altitude::B: Minimum altitude for ray-tracing and mean-flow impact.\nuse_saturation::D: Switch for the saturation scheme.\nsaturation_threshold::B: Relative saturation threshold.\nwkb_mode::F: Approximations used by MS-GWaM.\nblocking::D: Switch for parameterizing blocking in WKB-mountain-wave simulations.\nlong_threshold::B: Long-number threshold used by the blocked-layer scheme.\ndrag_coefficient::B: Dimensionless (relative) drag coefficient used by the blocked layer scheme.\nwave_modes::A: Number of wave modes per grid cell.\ninitial_wave_field::G: Function used to set the initial wavenumbers, intrinsic frequency and wave-action density of each wave mode.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes","page":"Types","title":"PinCFlow.Types.FoundationalTypes","text":"FoundationalTypes\n\nModule that contains the composite types Time, Constants, Domain, Grid, Atmosphere and Sponge.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Atmosphere","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Atmosphere","text":"Atmosphere{A <: AbstractArray{<:AbstractFloat, 3}}\n\nComposite type for atmospheric background fields.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n)::Atmosphere\n\nCreate an Atmosphere instance by dispatching to a method specific for the background and dynamic equations set in namelists.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Boussinesq,\n    background::NeutralStratification,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a uniform (i.e. neutral) Boussinesq atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    overlinerho  = rho_0  overlinetheta  = theta_0  P  = overlinerho overlinetheta  N^2  = 0\nendalign*\n\nwhere rho_0 and theta_0 are given by constants.rhoref and namelists.atmosphere.potential_temperature, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Boussinesq,\n    background::StableStratification,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a stratified Boussinesq atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    overlinerho  = rho_0  overlinetheta  = theta_0  P  = overlinerho overlinetheta  N^2  = N_0^2\nendalign*\n\nwhere rho_0, theta_0 and N_0 are given by constants.rhoref, namelists.atmosphere.potential_temperature and namelists.atmosphere.buoyancy_frequency, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Union{PseudoIncompressible, Compressible},\n    background::Isothermal,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing an isothermal atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    P left(zright)  = p_0 exp left(- fracsigma zgamma T_0right)\n    overlinetheta left(zright)  = T_0 exp left(frackappa sigma zT_0right)\n    overlinerho left(zright)  = fracP left(zright)overlinetheta left(zright)\n    N^2  = fracgoverlinetheta fracoverlinetheta_k + 1 - overlinetheta_k - 12 J Delta widehatz\nendalign*\n\nwhere p_0, T_0, sigma, gamma and kappa are given by namelists.atmosphere.ground_pressure, namelists.atmosphere.temperature, constants.sig, constants.gamma and constants.kappa, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Union{PseudoIncompressible, Compressible},\n    background::Isentropic,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing an isentropic atmosphere.\n\nThe background fields are given by\n\nbeginalign*\n    P left(zright)  = p_0 left( 1 - frackappasigma ztheta_0right)^frac1gamma - 1  \n    overlinetheta  = theta_0  \n    overlinerholeft(zright)  = fracP left(zright)overlinetheta left(zright)\n    N^2  = 0 \nendalign*\n\nwhere p_0, theta_0, sigma, gamma and kappa are given by namelists.atmosphere.ground_pressure, namelists.atmosphere.potential_temperature, constants.sig, constants.gamma and constants.kappa, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Union{PseudoIncompressible, Compressible},\n    background::Realistic,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a realistic atmosphere with an isentropic troposphere, an isothermal stratosphere, and a tropopause located at the altitude z_mathrmTP.\n\nThe background fields are given by\n\nbeginalign*\n    P left(z right)  =\n    begincases\n        p_0 left( 1 - frackappasigma ztheta_0right)^frac1gamma - 1  z leq z_mathrmTP \n        p_0^kappa p_mathrmTP^1gammaexpleft-fracsigma(z-z_mathrmTP)gamma T_mathrmTPright  z  z_mathrmTP \n    endcases \n    overlinethetaleft(zright)  =\n    begincases\n        theta_0  z leq z_mathrmTP  \n        theta_0 expleftfrackappasigma(z-z_mathrmTP)T_mathrmTPright  z  z_mathrmTP \n    endcases \n    overlinerholeft(zright)  = fracP left(zright)overlinetheta left(zright)\n    N^2  = fracgoverlinetheta fracoverlinetheta_k + 1 - overlinetheta_k - 12 J Delta widehatz\nendalign*\n\nwhere\n\nbeginalign*\n    p_mathrmTP  = p_0 left(1 - frackappasigma z_mathrmTPtheta_0right)^frac1gamma - 1  \n    T_mathrmTP  = theta_0 left(fracp_mathrmTPp_0right)^kappa\nendalign*\n\nand p_0, theta_0, z_mathrmTP, sigma, gamma, and kappa are given by namelists.atmosphere.ground_pressure, namelists.atmosphere.potential_temperature, namelists.atmosphere.tropopause_height, constants.sig, constants.gamma, and constants.kappa, respectively.\n\nAtmosphere(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    model::Union{PseudoIncompressible, Compressible},\n    background::LapseRates,\n)::Atmosphere\n\nCreate an Atmosphere instance with background fields describing a troposphere and a stratosphere with lapse rates Gamma_mathrmTS and Gamma_mathrmTS, respectively, and a tropopause located at the altitude z_mathrmTP.\n\nThe background fields are given by\n\nbeginalign*\n    Tleft(zright)  =\n    begincases\n        T_0 - Gamma_mathrmTS z  z leq z_mathrmTP  \n        T_0 - Gamma_mathrmTS z_mathrmTP - Gamma_mathrmSS left(z - z_mathrmTPright)  z  z_mathrmTP \n    endcases \n    Pleft(zright)  =\n    begincases\n        p_0 left(1 - fracGamma_mathrmTS zT_0right)^fracgR Gamma_mathrmTS  z leq z_mathrmTP    Gamma_mathrmTS neq 0  \n        p_0 expleft(- fracz sigmagamma T_0 right)  z leq z_mathrmTP    Gamma_mathrmTS = 0  \n        p_mathrmTPleft1 - fracGamma_mathrmSS left(z - z_mathrmTP right)T_mathrmTP right^fracgRGamma_mathrmSS  z  z_mathrmTP    Gamma_mathrmSS neq 0  \n        p_mathrmTPexpleft- fracleft(z - z_mathrmTP right)sigmagamma T_mathrmTP right  z  z_mathrmTP    Gamma_mathrmSS = 0 \n    endcases \n    overlinethetaleft(zright)  =\n    begincases\n        Tleft(zright) leftfracp_0Pleft(zright)right^fracRGamma_mathrmTSg  z leq z_mathrmTP    Gamma_mathrmTS neq 0  \n        T_0 expleft(frackappasigma zT_0right)  z leq z_mathrmTP  Gamma_mathrmTS = 0  \n        Tleft(zright)leftfracp_mathrmTPPleft(zright)right^fracRGamma_mathrmSSg  z  z_mathrmTP    Gamma_mathrmSS neq 0  \n        theta_mathrmTPexpleftfrackappasigma left(z-z_mathrmTPright)Tleft(z_mathrmTPright)right  z  z_mathrmTP  Gamma_mathrmSS = 0 \n    endcases \n    overlinerholeft(zright)  = fracP left(zright)overlinetheta left(zright)\n    N^2  = fracgoverlinetheta fracoverlinetheta_k + 1 - overlinetheta_k - 12 J Delta widehatz\nendalign*\n\nwhere\n\nbeginalign*\n    p_mathrmTP  =\n    begincases\n        p_0 left(1 - fracGamma_mathrmTS z_mathrmTPT_0right)^fracgR Gamma_mathrmTS  Gamma_mathrmTS neq 0  \n        p_0 expleft(- fracz_mathrmTPsigmagamma T_0 right)  Gamma_mathrmTS = 0 \n    endcases \n    theta_mathrmTP = T_0 expleft(frackappasigma z_mathrmTPT_0 right)\nendalign*\n\nand p_0, T_0, z_mathrmTP, Gamma_mathrmTS, Gamma_mathrmSS, sigma, gamma, and kappa are given by namelists.atmosphere.ground_pressure, namelists.atmosphere.temperature, namelists.atmosphere.tropopause_height, namelists.atmosphere.troposphere_lapse_rate, namelists.atmosphere.stratosphere_lapse_rate, constants.sig, constants.gamma, and constants.kappa, respectively.\n\nFields\n\npbar::A: Mass-weighted potential temperature P left(zright) (P left(x y z tright) in compressible mode).\nthetabar::A: Background potential temperature overlinetheta left(zright).\nrhobar::A: Background density overlinerho left(zright).\nn2::A: Squared buoyancy frequency N^2 left(zright).\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\nmodel: Dynamic equations.\nbackground: Atmospheric background.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.compute_n2!\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Constants","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Constants","text":"Constants{A <: AbstractFloat}\n\nComposite type for natural constants, reference quantities and non-dimensional parameters.\n\nConstants(namelists::Namelists)::Constants\n\nCreate a Constants instance.\n\nThe Reynolds number is the only constant that depends on the model parameters in namelists. If namelists.atmosphere.specify_reynolds_number is false, the Reynolds number is mathrmRe = L_mathrmref u_mathrmref  mu, with mu being the kinematic viscosity at the surface, given by namelists.atmosphere.kinematic_viscosity. Otherwise, it is set to the inverse of namelists.atmosphere.inverse_reynolds_number.\n\nFields\n\nNatural constants:\n\ngamma::A: Ratio of specific heats gamma = c_p  c_V = 14.\ngammainv::A: Inverse ratio of specific heats 1  gamma.\nkappa::A: Ratio between specific gas constant and specific heat capacity at constant pressure kappa = left(gamma - 1right)  gamma = R  c_p = 2  7.\nkappainv::A: Ratio between specific heat capacity at constant pressure and specific gas constant 1  kappa.\nrsp::A: Specific gas constant R = 287  mathrmJ  kg^- 1  K^- 1.\ng::A: Gravitational acceleration g = 981  mathrmm  s^- 2.\n\nReference quantities:\n\nrhoref::A: Reference density rho_mathrmref = 1184  mathrmkg  m^- 3.\npref::A: Reference pressure p_mathrmref = 101325  mathrmPa.\naref::A: Reference sound speed c_mathrmref = sqrtp_mathrmref  rho_mathrmref.\nuref::A: Reference wind u_mathrmref = a_mathrmref.\nlref::A: Reference length L_mathrmref = p_mathrmref left(g rho_mathrmrefright).\ntref::A: Reference time t_mathrmref = L_mathrmref  a_mathrmref.\nthetaref::A: Reference potential temperature theta_mathrmref = a_mathrmref^2  R.\nfref::A: Reference body force F_mathrmref = rho_mathrmref u_mathrmref^2  L_mathrmref.\n\nNon-dimensional parameters\n\ng_ndim::A: Non-dimensional gravitational acceleration widehatg = g L_mathrmref  u_mathrmref^2.\nre::A: Reynolds number mathrmRe = L_mathrmref u_mathrmref  mu (with mu being the kinematic viscosity at the surface).\nma::A: Mach number mathrmMa = u_mathrmref  a_mathrmref.\nmainv2::A: Inverse Mach number squared mathrmMa^- 2.\nma2::A: Mach number squared mathrmMa^2.\nfr::A: Froude number mathrmFr = u_mathrmref  sqrtg L_mathrmref.\nfrinv2::A: Inverse Froude number squared mathrmFr^- 2.\nfr2::A: Froude number squared mathrmFr^2.\nsig::A: Ratio between squared Mach number and squared Froude number sigma = mathrmMa^2  mathrmFr^2.\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Domain","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Domain","text":"Domain{A <: MPI.Comm, B <: Bool, C <: Integer}\n\nCollection of domain-decomposition and MPI-communication parameters.\n\nDomain(namelists::Namelists)::Domain\n\nConstruct a Domain instance from the model parameters in namelists.\n\nIf namelists.domain.base_comm is equal to MPI.COMM_WORLD, this method first initializes the MPI parallelization by calling MPI.Init(). It then creates a Cartesian topology from the base communicator, with periodic boundaries in the first two dimensions (widehatx and widehaty) but not in the last (widehatz). The domain is divided into corresponding subdomains, where in each direction, the number of grid points (nx, ny and nz) is the result of floor division of the global grid size (namelists.domain.x_size, namelists.domain.y_size and namelists.domain.z_size) by the number of processes in that direction (namelists.domain.npx, namelists.domain.npy and namelists.domain.npz). The remainder of the floor division is included in the grid-point count of the last processes (in each direction). The index bounds ((i0, i1), (j0, j1) and (k0, k1)) are set such that they exclude the first and last namelists.domain.nbx, namelists.domain.nby and namelists.domain.nbz cells in widehatx, widehaty and widehatz, respectively (these are not included in nx, ny and nz).\n\nFields\n\nGeneral MPI communication:\n\ncomm::A: MPI communicator with Cartesian topology for the computational domain.\nmaster::B: Boolean flag indicating if this process is the master process (rank 0).\nrank::C: MPI rank of this process within the communicator comm.\nroot::C: Root process rank (0).\n\nDimensions of the MPI subdomain:\n\nnx::C: Number of physical grid points in widehatx-direction.\nny::C: Number of physical grid points in widehaty-direction.\nnz::C: Number of physical grid points in widehatz-direction.\nnxx::C: Number of computational grid points in widehatx-direction (including halo/boundary cells).\nnyy::C: Number of computational grid points in widehaty-direction (including halo/boundary cells).\nnzz::C: Number of computational grid points in widehatz-direction (including halo/boundary cells).\n\nIndex offsets and bounds:\n\nio::C: MPI offset in widehatx-direction.\njo::C: MPI offset in widehaty-direction.\nko::C: MPI offset in widehatz-direction.\ni0::C: First physical grid cell of the subdomain in widehatx-direction.\ni1::C: Last physical grid cell of the subdomain in widehatx-direction.\nj0::C: First physical grid cell of the subdomain in widehaty-direction.\nj1::C: Last physical grid cell of the subdomain in widehaty-direction.\nk0::C: First physical grid cell of the subdomain in widehatz-direction.\nk1::C: Last physical grid cell of the subdomain in widehatz-direction.\n\nNeighbor-process ranks:\n\nleft::C: Rank of the next process to the left (negative x-direction).\nright::C: Rank of the next process to the right (positive x-direction).\nbackward::C: Rank of the next process to the back (negative y-direction).\nforward::C: Rank of the next process to the front (positive y-direction).\ndown::C: Rank of the next process to the bottom (negative z-direction).\nup::C: Rank of the next process to the top (positive z-direction).\n\nHorizontal and vertical communication:\n\nlayer_comm::A: MPI communicator for processes in the same layer (i.e. with the same vertical index).\ncolumn_comm::A: MPI communicator for processes in the same column (i.e. with the same horizontal indices).\n\nArguments\n\nnamelists: Namelists with all model parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Grid","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Grid","text":"Grid{\n    A <: AbstractFloat,\n    B <: AbstractVector{<:AbstractFloat},\n    C <: AbstractMatrix{<:AbstractFloat},\n    D <: AbstractArray{<:AbstractFloat, 3},\n    E <: AbstractArray{<:AbstractFloat, 5},\n}\n\nCollection of parameters and fields that describe the grid.\n\nGrid(namelists::Namelists, constants::Constants, domain::Domain)::Grid\n\nConstruct a Grid instance, using the specifications in namelists.grid and the MPI decomposition described by domain.\n\nThis constructor creates a 3D parallelized grid for a terrain-following, vertically stretched coordinate system. The global computational grid is defined by\n\nbeginalign*\n    widehatx_i  = - L_x  2 + left(i - i_0 + frac12right) Delta widehatx\n    widehaty_j  = - L_y  2 + left(j - j_0 + frac12right) Delta widehaty\n    widehatz_k  = left(k - k_0 + frac12right) Delta widehatz\nendalign*\n\nwhere left(L_x L_yright), left(i_0 j_0 k_0right) and left(Delta widehatx Delta widehaty Delta widehatzright) are the horizontal extents of the domain, the lower index bounds of the MPI subdomains and the grid spacings (determined from the total extents and grid-point counts of the domain), respectively. Throughout the documentation, the position of any variable on this grid is indicated with the indices left(i j kright) in its subscript. Therein, unshifted indices are omitted for the sake of brevity. The grid is staggered, i.e. the wind components are defined at the midpoints of those cell surfaces that are orthogonal to their respective directions. Interpolations are therefore necessary in many places. These are indicated as in\n\nbeginalign*\n    rho_i + 1  2  = fracrho + rho_i + 12  rho_j + 1  2  = fracrho + rho_j + 12  rho_k + 1  2  = fracJ_k + 1 rho + J rho_k + 1J_k + 1 + J\n    u  = fracu_i - 1  2 + u_i + 1  22  u_j + 1  2  = fracu + u_j + 12  u_k + 1  2  = fracJ_k + 1 u + J u_k + 1J_k + 1 + J\n    v_i + 1  2  = fracv + v_i + 12  v  = fracv_j - 1  2 + v_j + 1  22  v_k + 1  2  = fracJ_k + 1 v + J v_k + 1J_k + 1 + J\n    widehatw_i + 1  2  = fracwidehatw + widehatw_i + 12  widehatw_j + 1  2  = fracwidehatw + widehatw_j + 12  widehatw  = fracwidehatw_k - 1  2 + widehatw_k + 1  22\nendalign*\n\nThe vertical layer centers and edges of the stretched and physical grids are given by\n\nbeginalign*\n    widetildez_k + 1  2  = L_z left(fracwidehatz_k + 1  2L_zright)^s  z_k + 1  2  = fracL_z - hL_z widetildez_k + 1  2 + h\n    widetildez  = fracwidetildez_k + 1  2 + widetildez_k - 1  22  z  = fracL_z - hL_z widetildez + h\nendalign*\n\nwhere L_z, s and h are the vertical extent of the domain (namelists.domain.lz), the vertical-stretching parameter (namelists.grid.stretch_exponent) and the surface topography (as returned by compute_topography), respectively. Finally, the Jacobian is\n\nJ = fracL_z - hL_z fracwidetildez_k + 1  2 - widetildez_k - 1  2Delta widehatz\n\nand the non-Cartesian elements of the metric tensor are\n\nbeginalign*\n    G^1 3  = frach_mathrmb i + 1 - h_mathrmb i - 12 Delta widehatx fracwidetildez - L_zL_z - h fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2\n    G^2 3  = frach_mathrmb j + 1 - h_mathrmb j - 12 Delta widehaty fracwidetildez - L_zL_z - h fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2\n    G^3 3  = leftleft(fracL_zL_z - hright)^2 + left(fracwidetildez - L_zL_z - hright)^2 leftleft(frach_mathrmb i + 1 - h_mathrmb i - 12 Delta widehatxright)^2 + left(frach_mathrmb j + 1 - h_mathrmb j - 12 Delta widehatyright)^2rightright\n     quad times left(fracDelta widehatzwidetildez_k + 1  2 - widetildez_k - 1  2right)^2\nendalign*\n\nFields\n\nDomain extent:\n\nlx::A: Non-dimensional domain extent in widehatx-direction.\nly::A: Non-dimensional domain extent in widehaty-direction.\nlz::A: Non-dimensional domain extent in widehatz-direction.\n\nGrid spacing:\n\ndx::A: Grid spacing Delta widehatx.\ndy::A: Grid spacing Delta widehaty.\ndz::A: Grid spacing Delta widehatz.\n\nHorizontal coordinates:\n\nx::B: Cell-centered widehatx-coordinate of the entire domain.\ny::B: Cell-centered widehaty-coordinate of the entire domain.\n\nTopography:\n\nhb::C: Resolved surface topography.\nhw::D: Spectrum of the unresolved surface topography.\nkh::D: Zonal wavenumbers of the spectrum.\nlh::D: Meridional wavenumbers of the spectrum.\n\nCoordinate transformation.\n\njac::D: Jacobian.\nmet::E: Metric tensor.\n\nVertical coordinates:\n\nzc::D: Physical height at cell centers.\nzctilde::D: Physical height at vertical cell edges.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.compute_topography\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Sponge","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Sponge","text":"Sponge{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractVector{<:AbstractFloat},\n}\n\nComposite type for Rayleigh-damping coefficients and an auxiliary array for the computation of horizontal means.\n\nSponge(domain::Domain)::Sponge\n\nConstruct a Sponge instance with zero-initialized arrays.\n\nFields\n\nalphar::A: Coefficient of the LHS sponge (used in all prognostic equations).\nbetar::A: Coefficient of the RHS sponge (used in the momentum equation).\nhorizontal_mean::C: Auxiliary array for the computation of horizontal means.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.Time","page":"Types","title":"PinCFlow.Types.FoundationalTypes.Time","text":"Time{A <: Integer, B <: NTuple{3, <:AbstractFloat}}\n\nTime integration parameters for the low-storage third-order Runge-Kutta scheme.\n\nTime()::Time\n\nConstruct a Time instance.\n\nFields\n\nnstages::A: Number of Runge-Kutta stages.\nalphark::B: Runge-Kutta coefficients for the total tendency, i.e. boldsymbolalpha_mathrmRK = left(0 - 5  9 - 153  128right).\nbetark::B: Runge-Kutta coefficients for the previous tendency, i.e. boldsymbolbeta_mathrmRK = left(1  3 15  16 8  15right).\nstepfrac::B: Time step fractions for each stage, i.e. boldsymbolf_mathrmRK = left(1  3 5  12 1  4right).\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.compute_n2!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.compute_n2!","text":"compute_n2!(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    grid::Grid,\n    thetabar::AbstractArray{<:AbstractFloat, 3},\n    n2::AbstractArray{<:AbstractFloat, 3},\n)\n\nCompute the buoyancy frequency N^2 left(zright) from the potential temperature.\n\nThe squared buoyancy frequency is given by\n\nbeginalign*\nN^2  = fracgoverlinetheta fracoverlinetheta_k + 1 - overlinetheta_k - 12 J Delta widehatz \nendalign*\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\nthetabar: Potential-temperature background.\nn2: Squared buoyancy frequency.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.compute_topography","page":"Types","title":"PinCFlow.Types.FoundationalTypes.compute_topography","text":"compute_topography(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    x::AbstractVector{<:AbstractFloat},\n    y::AbstractVector{<:AbstractFloat},\n)::Tuple{\n    <:AbstractMatrix{<:AbstractFloat},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n}\n\nCompute and return the topography by dispatching to a WKB-mode-specific method.\n\ncompute_topography(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    x::AbstractVector{<:AbstractFloat},\n    y::AbstractVector{<:AbstractFloat},\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::Tuple{\n    <:AbstractMatrix{<:AbstractFloat},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n}\n\nCompute and return the topography for WKB configurations.\n\nThe arrays in the returned tuple represent (in order) the resolved topography, the amplitudes of the unresolved topography, the corresponding zonal wavenumbers and the corresponding meridional wavenumbers.\n\ncompute_topography(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    x::AbstractVector{<:AbstractFloat},\n    y::AbstractVector{<:AbstractFloat},\n    wkb_mode::NoWKB,\n)::Tuple{\n    <:AbstractMatrix{<:AbstractFloat},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n    <:AbstractArray{<:AbstractFloat, 3},\n}\n\nCompute and return the topography for non-WKB configurations.\n\nThe arrays representing the unresolved spectrum are set to have the size (0, 0, 0). The topography is represented by the first array in the returned tuple.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nx: widehatx-coordinate grid points.\ny: widehaty-coordinate grid points.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!","text":"set_meridional_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce meridional boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npy > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_meridional_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce meridional boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_meridional_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_meridional_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_meridional_halos_of_field!","text":"set_meridional_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all meridional halo values of a matrix by performing bidirectional MPI communication between backward and forward neighbor processes.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_meridional_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of meridional halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!","text":"set_vertical_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain,\n    mode::Function;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n    staggered = false,\n)\n\nEnforce vertical boundary conditions for a 3D array (assuming solid-wall boundaries).\n\nHalo exchange is used for multi-process domains (npz > 1). Use mode = + (mode = -) for line-reflected (point-reflected) ghost-cell values.\n\nset_vertical_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange halo values of a 5D array if multiple processes are used in the vertical (npz > 1).\n\nThis method is applied to reconstruction arrays. Vertical boundary conditions are not enforced for these but for the fluxes determined from them.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmode: Method used for setting the boundary-cell values.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\nstaggered: A switch for whether or not the field is on the staggered vertical grid.\n\nSee also\n\nPinCFlow.MPIOperations.set_vertical_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_vertical_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_vertical_halos_of_field!","text":"set_vertical_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 3D array by performing MPI communication between downward and upward neighbor processes.\n\nSolid walls are assumed at the vertical boundaries of the domain. The corresponding ghost-cell values are not changed.\n\nset_vertical_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of vertical halo values of a 5D array with an algorithm similar to that implemented in the above method.\n\nThe vertical domain boundaries are treated as described above. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!","text":"set_zonal_boundaries_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nEnforce zonal boundary conditions for a matrix.\n\nHalo exchange is used for multi-process domains (npx > 1), otherwise periodic boundaries are set by copying values from opposite domain edges.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 3D array.\n\nHalo exchange is used in the same manner as in the method for matrices.\n\nset_zonal_boundaries_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nEnforce zonal boundary conditions for a 5D array.\n\nHalo exchange is used in the same manner as in the methods for matrices and 3D arrays. The first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of boundary layers in each dimension. Use -1 for the default values from namelists.\n\nSee also\n\nPinCFlow.MPIOperations.set_zonal_halos_of_field!\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.FoundationalTypes.set_zonal_halos_of_field!","page":"Types","title":"PinCFlow.Types.FoundationalTypes.set_zonal_halos_of_field!","text":"set_zonal_halos_of_field!(\n    field::AbstractMatrix{<:AbstractFloat},\n    namelists::Namelists,\n    domain::Domain,\n)\n\nExchange all zonal halo values of a matrix by performing bidirectional MPI communication between left and right neighbor processes.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:Real, 3},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 3D array with an algorithm similar to that implemented in the method for matrices.\n\nset_zonal_halos_of_field!(\n    field::AbstractArray{<:AbstractFloat, 5},\n    namelists::Namelists,\n    domain::Domain;\n    layers::NTuple{3, <:Integer} = (-1, -1, -1),\n)\n\nExchange a specified number of zonal halo values of a 5D array with an algorithm similar to that implemented in the method for 3D arrays.\n\nThe first three dimensions of the array are assumed to represent the dimensions of physical space.\n\nArguments\n\nfield: Input array.\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nKeywords\n\nlayers: The number of halo layers in each dimension. Use -1 for the default values from namelists.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.VariableTypes","page":"Types","title":"PinCFlow.Types.VariableTypes","text":"VariableTypes\n\nModule for composite types needed for the integration in time.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Auxiliaries","page":"Types","title":"PinCFlow.Types.VariableTypes.Auxiliaries","text":"Auxiliaries{A <: AbstractArray{<:AbstractFloat, 3}}\n\nAuxiliary array used in the reconstruction of prognostic variables.\n\nAuxiliaries(domain::Domain)::Auxiliaries\n\nConstruct an Auxiliaries instance with a zero-initialized auxiliary array sized according to the MPI subdomain dimensions.\n\nFields\n\nphi::A: Auxiliary array used as input for PinCFlow.FluxCalculator.apply_3d_muscl!.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Backups","page":"Types","title":"PinCFlow.Types.VariableTypes.Backups","text":"Backups{A <: AbstractArray{<:AbstractFloat, 3}}\n\nContainer for backup copies needed in the semi-implicit time scheme.\n\nBackups(domain::Domain)::Backups\n\nInitialize backup arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\nrhoold::A: Density backup.\nrhopold::A: Density-fluctuations backup.\nuold::A: Zonal-wind backup.\nvold::A: Meridional-wind backup.\nwold::A: Transformed-vertical-wind backup.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Fluxes","page":"Types","title":"PinCFlow.Types.VariableTypes.Fluxes","text":"Fluxes{A <: AbstractArray{<:AbstractFloat, 4}}\n\nArrays for fluxes needed in the computation of the left-hand sides.\n\nThe first three dimensions represent physical space and the fourth dimension represents the flux direction.\n\nFluxes(namelists::Namelists, domain::Domain)::Fluxes\n\nConstruct a Fluxes instance with dimensions depending on whether or not the model is compressible, by dispatching to the appropriate method.\n\nFluxes(domain::Domain, model::Boussinesq)::Fluxes\n\nConstruct a Fluxes instance in Boussinesq mode, with zero-size arrays for the density and mass-weighted potential-temperature fluxes.\n\nFluxes(domain::Domain, model::PseudoIncompressible)::Fluxes\n\nConstruct a Fluxes instance in pseudo-incompressible mode, with a zero-size array for mass-weighted potential-temperature fluxes.\n\nFluxes(domain::Domain, model::Compressible)::Fluxes\n\nConstruct a Fluxes instance in compressible mode.\n\nFields\n\nphirho::A: Density fluxes.\nphirhop::A: Density-fluctuations fluxes.\nphiu::A: Zonal-momentum fluxes.\nphiv::A: Meridional-momentum fluxes.\nphiw::A: Transformed-vertical-momentum fluxes.\nphitheta::A: Potential temperature fluxes.\nphip::A: Mass-weighted potential-temperature fluxes.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Increments","page":"Types","title":"PinCFlow.Types.VariableTypes.Increments","text":"Increments{A <: AbstractArray{<:AbstractFloat, 3}}\n\nContainer for the Runge-Kutta updates of the prognostic variables, as well as the Exner-pressure update of the Poisson solver.\n\nIncrements(namelists::Namelists, domain::Domain)::Increments\n\nCreate an Increments instance with dimensions depending on the model configuration, by dispatching to the appropriate method.\n\nIncrements(domain::Domain, model::Boussinesq)::Increments\n\nCreate an Increments instance in Boussinesq mode, with zero-size arrays for the density and mass-weighted potential-temperature update.\n\nIncrements(domain::Domain, model::PseudoIncompressible)::Increments\n\nCreate an Increments instance in pseudo-incompressible mode, with a zero-size array for the mass-weighted potential-temperature update.\n\nIncrements(domain::Domain, model::Compressible)::Increments\n\nCreate an Increments instance in compressible mode.\n\nFields\n\ndrho::A: Density update.\ndrhop::A: Density-fluctuations update.\ndu::A: Zonal-momentum update.\ndv::A: Meridional-momentum update.\ndw::A: Transformed-vertical-momentum update.\ndpip::A: Exner-pressure update.\ndp::A: Mass-weighted potential-temperature update.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Predictands","page":"Types","title":"PinCFlow.Types.VariableTypes.Predictands","text":"Predictands{A <: AbstractArray{<:AbstractFloat, 3}}\n\nArrays for prognostic variables.\n\nPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n)::Predictands\n\nConstruct a Predictands instance.\n\nThe predictands are initialized with the corresponding functions in namelists.atmosphere. The mass-weighted potential temperature P is constructed depending on the dynamic equations (see set_p).\n\nFields\n\nrho::A: Density.\nrhop::A: Density-fluctuations.\nu::A: Zonal wind.\nv::A: Meridional wind.\nw::A: Transformed vertical wind.\npip::A: Exner-pressure fluctuations.\np::A: Mass-weighted potential temperature.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\ngrid: Collection of parameters and fields that describe the grid.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_vertical_boundaries_of_field!\nPinCFlow.Types.VariableTypes.set_p\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Reconstructions","page":"Types","title":"PinCFlow.Types.VariableTypes.Reconstructions","text":"Reconstructions{A <: AbstractArray{<:AbstractFloat, 5}}\n\nArrays for the reconstructions of prognostic variables.\n\nThe first three dimensions represent physical space, the fourth represents the physical-space dimension of the reconstruction and the fifth the two directions in which it is computed.\n\nReconstructions(namelists::Namelists, domain::Domain)::Reconstructions\n\nConstruct a Reconstructions instance with dimensions depending on whether or not the model is Boussinesq, by dispatching to the appropriate method.\n\nReconstructions(domain::Domain, model::Boussinesq)::Reconstructions\n\nConstruct a Reconstructions instance in Boussinesq mode, with a zero-size array for density reconstructions.\n\nReconstructions(\n    domain::Domain,\n    model::Union{PseudoIncompressible, Compressible},\n)::Reconstructions\n\nConstruct a Reconstructions instance in non-Boussinesq modes.\n\nFields\n\nrhotilde::A: Reconstructed density.\nrhoptilde::A: Reconstructed density fluctuations.\nutilde::A: Reconstructed zonal momentum.\nvtilde::A: Reconstructed meridional momentum.\nwtilde::A: Reconstructed vertical momentum.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\nmodel: Dynamic equations.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.Variables","page":"Types","title":"PinCFlow.Types.VariableTypes.Variables","text":"Variables{\n    A <: Predictands,\n    B <: Increments,\n    C <: Backups,\n    D <: Auxiliaries,\n    E <: Reconstructions,\n    F <: Fluxes,\n}\n\nContainer for arrays needed for the prediction of the prognostic variables.\n\nVariables(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n)::Variables\n\nConstruct a Variables instance, with array dimensions and initial values set according to the model configuration.\n\nFields\n\npredictands::A: Prognostic variables.\nincrements::B: Runge-Kutta increments and pressure correction.\nbackups::C: Backups of the prognostic variables needed in the semi-implicit time scheme.\nauxiliaries::D: Auxiliary array needed in the reconstruction.\nreconstructions::E: Reconstructions of the prognostic variables.\nfluxes::F: Fluxes of the prognostic variables.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\n\nSee also\n\nPinCFlow.Types.VariableTypes.Predictands\nPinCFlow.Types.VariableTypes.Increments\nPinCFlow.Types.VariableTypes.Backups\nPinCFlow.Types.VariableTypes.Auxiliaries\nPinCFlow.Types.VariableTypes.Reconstructions\nPinCFlow.Types.VariableTypes.Fluxes\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.VariableTypes.set_p","page":"Types","title":"PinCFlow.Types.VariableTypes.set_p","text":"set_p(\n    model::Union{Boussinesq, PseudoIncompressible},\n    pbar::AbstractArray{<:AbstractFloat, 3},\n)::AbstractArray{<:AbstractFloat, 3}\n\nReturn a zero-size array in non-compressible modes.\n\nIn these cases, the mass-weighted potential temperature is a background field: constant in Boussinesq mode, vertically varying in pseudo-incompressible mode.\n\nset_p(\n    model::Compressible,\n    pbar::AbstractArray{<:AbstractFloat, 3},\n)::AbstractArray{<:AbstractFloat, 3}\n\nReturn a copy of overlineP = overlinerho overlinetheta in compressible mode.\n\nIn compressible mode, the mass-weighted potential temperature is a prognostic variable. Its initialization as P = overlinerho overlinetheta means that the initial potential temperature fluctuations are such that rho theta = overlinerho overlinetheta.\n\nArguments:\n\nmode: Dynamic equations.\npbar: Mass-weighted potential temperature.\n\n\n\n\n\n","category":"function"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes","page":"Types","title":"PinCFlow.Types.PoissonTypes","text":"PoissonTypes\n\nModule for composite types used by the Poisson solver.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.BiCGSTAB","page":"Types","title":"PinCFlow.Types.PoissonTypes.BiCGSTAB","text":"BiCGSTAB{A <: AbstractArray{<:AbstractFloat, 3}}\n\nWorkspace arrays used by PinCFlow.PoissonSolver.apply_bicgstab!.\n\nBiCGSTAB(domain::Domain)::BiCGSTAB\n\nCreate a BiCGSTAB instance with zero-initialized workspace arrays sized according to dimensions of the MPI subdomain.\n\nFields\n\np::A: Search direction.\nr0::A: Initial residual.\nrold::A: Previous residual.\nr::A: Current residual.\ns::A: Intermediate solution.\nt::A: Result of applying the linear operator to s.\nv::A: Result of applying the linear operator to p.\nmatvec::A: Intermediate result of applying the linear operator.\nv_pc::A: Output of the preconditioner.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Correction","page":"Types","title":"PinCFlow.Types.PoissonTypes.Correction","text":"Correction{A <: AbstractArray{<:AbstractFloat, 3}}\n\nCorrection terms used to update the horizontal wind in the corrector step.\n\nCorrection(domain::Domain)::Correction\n\nCreate a Correction instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\ncorx::A: Correction term for the zonal wind.\ncory::A: Correction term for the meridional wind.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Operator","page":"Types","title":"PinCFlow.Types.PoissonTypes.Operator","text":"Operator{A <: AbstractArray{<:AbstractFloat, 3}}\n\nWorkspace array for applying the linear operator of the Poisson solver.\n\nOperator(domain::Domain)::Operator\n\nCreate an Operator instance with a zero-initialized array sized according to the dimensions of the MPI subdomain.\n\nFields\n\ns::A: Auxiliary array for enforcing boundary conditions and performing MPI communication prior to the application of the linear operator.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Poisson","page":"Types","title":"PinCFlow.Types.PoissonTypes.Poisson","text":"Poisson{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: Tensor,\n    C <: Operator,\n    D <: Preconditioner,\n    E <: BiCGSTAB,\n    F <: Correction,\n}\n\nMain container for Poisson-solver workspace and solution arrays.\n\nPoisson(domain::Domain)::Poisson\n\nCreate a Poisson instance with an initialized Poisson-solver workspace, sized according to the dimensions of the MPI subdomain.\n\nFields\n\nrhs::A: Right-hand side.\nsolution::A: Solution of the Poisson problem.\ntensor::B: Tensor elements of the linear operator.\noperator::C: Workspace arrays for applying the linear operator.\npreconditioner::D: Workspace arrays for applying the preconditioner.\nbicgstab::E: Workspace arrays used by the BiCGSTAB algorithm.\ncorrection::F: Correction terms used to update the horizontal wind in the corrector step.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\nSee also\n\nPinCFlow.Types.PoissonTypes.Tensor\nPinCFlow.Types.PoissonTypes.Operator\nPinCFlow.Types.PoissonTypes.Preconditioner\nPinCFlow.Types.PoissonTypes.BiCGSTAB\nPinCFlow.Types.PoissonTypes.Correction\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Preconditioner","page":"Types","title":"PinCFlow.Types.PoissonTypes.Preconditioner","text":"Preconditioner{\n    A <: AbstractArray{<:AbstractFloat, 3},\n    B <: AbstractMatrix{<:AbstractFloat},\n}\n\nWorkspace arrays for applying the preconditioner.\n\nPreconditioner(domain::Domain)::Preconditioner\n\nCreate a Preconditioner instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\ns_pc::A: Solution computed by the preconditioner.\nq_pc::A: Auxiliary array used for the upward sweep.\np_pc::B: Auxiliary array used for the upward sweep and downward pass.\ns_pc_bc::B: MPI communication buffer for s_pc.\nq_pc_bc::B: MPI communication buffer for q_pc.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.PoissonTypes.Tensor","page":"Types","title":"PinCFlow.Types.PoissonTypes.Tensor","text":"Tensor{A <: AbstractArray{<:AbstractFloat, 3}}\n\nTensor elements of the linear operator, as computed by PinCFlow.PoissonSolver.compute_operator!.\n\nTensor(domain::Domain)::Tensor\n\nCreate a Tensor instance with zero-initialized arrays sized according to the dimensions of the MPI subdomain.\n\nFields\n\nac_b::A: Coefficient applied to s.\nal_b::A: Coefficient applied to s_i - 1.\nar_b::A: Coefficient applied to s_i + 1.\nab_b::A: Coefficient applied to s_j - 1.\naf_b::A: Coefficient applied to s_j + 1.\nad_b::A: Coefficient applied to s_k - 1.\nau_b::A: Coefficient applied to s_k + 1.\nald_b::A: Coefficient applied to s_i - 1 k - 1.\nalu_b::A: Coefficient applied to s_i - 1 k + 1.\nard_b::A: Coefficient applied to s_i + 1 k - 1.\naru_b::A: Coefficient applied to s_i + 1 k + 1.\nabd_b::A: Coefficient applied to s_j - 1 k - 1.\nabu_b::A: Coefficient applied to s_j - 1 k + 1.\nafd_b::A: Coefficient applied to s_j + 1 k - 1.\nafu_b::A: Coefficient applied to s_j + 1 k + 1.\nadd_b::A: Coefficient applied to s_k - 2.\nauu_b::A: Coefficient applied to s_k + 2.\naldd_b::A: Coefficient applied to s_i - 1 k - 2.\naluu_b::A: Coefficient applied to s_i - 1 k + 2.\nardd_b::A: Coefficient applied to s_i + 1 k - 2.\naruu_b::A: Coefficient applied to s_i + 1 k + 2.\nabdd_b::A: Coefficient applied to s_j - 1 k - 2.\nabuu_b::A: Coefficient applied to s_j - 1 k + 2.\nafdd_b::A: Coefficient applied to s_j + 1 k - 2.\nafuu_b::A: Coefficient applied to s_j + 1 k + 2.\n\nArguments\n\ndomain: Collection of domain-decomposition and MPI-communication parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes","page":"Types","title":"PinCFlow.Types.WKBTypes","text":"WKBTypes\n\nModule that contains a collection of types for WKB ray tracing calculations including ray data structures, surface indices, integrals, tendencies, and increments.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.VariableTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.MergedRays","page":"Types","title":"PinCFlow.Types.WKBTypes.MergedRays","text":"MergedRays{\n    A <: AbstractMatrix{<:AbstractFloat},\n    B <: AbstractVector{<:AbstractFloat},\n}\n\nComposite type used for creating merged ray volumes.\n\nMergedRays(bounds::Integer, count::Integer)::MergedRays\n\nConstruct a MergedRays instance, with arrays sized according to the given dimensions.\n\nFields\n\nxr::A: Outermost ray-volume bounds in x.\nyr::A: Outermost ray-volume bounds in y.\nzr::A: Outermost ray-volume bounds in z.\nkr::A: Outermost ray-volume bounds in k.\nlr::A: Outermost ray-volume bounds in l.\nmr::A: Outermost ray-volume bounds in m.\nnr::B: Wave-action integral.\n\nArguments\n\nbounds: Number of bounds in each dimension.\ncount: Maximum ray-volume count per grid cell.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.Rays","page":"Types","title":"PinCFlow.Types.WKBTypes.Rays","text":"Rays{A <: AbstractArray{<:AbstractFloat, 4}}\n\nContainer for prognostic ray-volume properties.\n\nRays(nray_wrk::Integer, nxx::Integer, nyy::Integer, nzz::Integer)::Rays\n\nConstruct a Rays instance, with arrays sized according to the given dimensions.\n\nFields\n\nx::A: Position in x.\ny::A: Position in y.\nz::A: Position in z.\nk::A: Position in k.\nl::A: Position in l.\nm::A: Position in m.\ndxray::A: Extent in x.\ndyray::A: Extent in y.\ndzray::A: Extent in z.\ndkray::A: Extent in k.\ndlray::A: Extent in l.\ndmray::A: Extent in m.\ndens::A: Phase-space wave-action density.\n\nArguments\n\nnray_wrk: Size of the spectral dimension of ray-volume arrays.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.SurfaceIndices","page":"Types","title":"PinCFlow.Types.WKBTypes.SurfaceIndices","text":"SurfaceIndices{A <: AbstractArray{<:Integer, 3}, B <: AbstractVector{<:Integer}}\n\nIndices that connect orographic wave modes to the corresponding ray volumes launched by PinCFlow.MSGWaM.RaySources.activate_orographic_source!.\n\nSurfaceIndices(n_sfc::Integer, nxx::Integer, nyy::Integer)::SurfaceIndices\n\nConstruct a SurfaceIndices instance, with arrays sized according to the given dimensions.\n\nFields\n\nrs::A: Ray-volume indices.\nixs::B: Zonal indices within grid cells.\njys::B: Meridional indices within grid cells.\nkzs::B: Vertical indices within grid cells.\niks::B: Indices in k.\njls::B: Indices in l.\nkms::B: Indices in m.\nalphas::B: Wave-mode indices.\n\nArguments\n\nn_sfc: Number of orographic wave modes per grid cell.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKB","page":"Types","title":"PinCFlow.Types.WKBTypes.WKB","text":"WKB{\n    A <: Integer,\n    B <: AbstractArray{<:Integer, 3},\n    C <: Rays,\n    D <: MergedRays,\n    E <: SurfaceIndices,\n    F <: WKBIncrements,\n    G <: WKBIntegrals,\n    H <: WKBTendencies,\n    I <: Ref{<:AbstractFloat},\n    J <: AbstractArray{<:AbstractFloat, 3},\n    K <: AbstractMatrix{<:AbstractFloat},\n}\n\nMain container for WKB ray-tracing data and parameters.\n\nWKB(namelists::Namelists, domain::Domain)::WKB\n\nConstruct a WKB instance by dispatching to a test-case-specific method.\n\nWKB(namelists::Namelists, domain::Domain, wkb_mode::NoWKB)::WKB\n\nConstruct a WKB instance with zero-size arrays for non-WKB configurations.\n\nWKB(\n    namelists::Namelists,\n    domain::Domain,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::WKB\n\nConstruct a WKB instance.\n\nThis method primarily determines the size of the spectral dimension of ray-volume arrays and initializes them and related arrays (with zeros) accordingly. The proper initialization with nonzero wave action is performed by PinCFlow.MSGWaM.RayUpdate.initialize_rays!.\n\nFields\n\nnxray::A: Number of ray volumes allowed in widehatx, per grid cell and wave mode (multiplication_factor * nrx * nrk, taken from namelists.wkb).\nnyray::A: Number of ray volumes allowed in widehaty, per grid cell and wave mode (multiplication_factor * nry * nrl, taken from namelists.wkb).\nnzray::A: Number of ray volumes allowed in widehatz, per grid cell and wave mode (multiplication_factor * nrz * nrm, taken from namelists.wkb).\nnxray_wrk::A: 2 * nxray.\nnyray_wrk::A: 2 * nyray.\nnzray_wrk::A: 2 * nzray.\nnray_max::A: Maximum ray-volume count allowed per grid-cell before merging is triggered (nxray * nyray * nzray * namelists.wkb.wave_modes).\nnray_wrk::A: Size of the spectral dimension of ray-volume arrays (nxray_wrk * nyray_wrk * nzray_wrk).\nn_sfc::A: Number of orographic wave modes.\nnray::B: Ray-volume count in each grid cell.\nrays::C: Prognostic ray-volume properties.\nmerged_rays::D: Container used for creating merged ray volumes.\nsurface_indices::E: Indices that connect orographic wave modes to ray volumes.\nincrements::F: WKBIncrements of the prognostic ray-volume properties.\nintegrals::G: Integrals of ray-volume properties.\ntendencies::H: Gravity-wave drag and heating fields.\ncgx_max::I: Maximum zonal group velocities.\ncgy_max::I: Maximum meridional group velocities.\ncgz_max::J: Maximum vertical group velocities.\nzb::K: Upper edge of the blocked layer.\ndiffusion::J: Diffusion induced by wave breaking.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ngrid: Collection of parameters and fields that describe the grid.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also\n\nPinCFlow.Types.WKBTypes.Rays\nPinCFlow.Types.WKBTypes.SurfaceIndices\nPinCFlow.Types.WKBTypes.WKBIncrements\nPinCFlow.Types.WKBTypes.WKBIntegrals\nPinCFlow.Types.WKBTypes.WKBTendencies\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBIncrements","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBIncrements","text":"WKBIncrements{A <: AbstractArray{<:AbstractFloat, 4}}\n\nRay-volume-propagation increments.\n\nWKBIncrements(\n    nray_wrk::Integer,\n    nxx::Integer,\n    nyy::Integer,\n    nzz::Integer,\n)::WKBIncrements\n\nConstruct an WKBIncrements instance, with arrays sized according to the given dimensions.\n\nFields\n\ndxray::A: WKBIncrements for the position in x.\ndyray::A: WKBIncrements for the position in y.\ndzray::A: WKBIncrements for the position in z.\ndkray::A: WKBIncrements for the position in k.\ndlray::A: WKBIncrements for the position in l.\ndmray::A: WKBIncrements for the position in m.\nddxray::A: WKBIncrements for the extent in x.\nddyray::A: WKBIncrements for the extent in y.\nddzray::A: WKBIncrements for the extent in z.\n\nArguments\n\nnray_wrk: Size of the spectral dimension of ray-volume arrays.\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBIntegrals","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBIntegrals","text":"WKBIntegrals{A <: AbstractArray{<:AbstractFloat, 3}}\n\nIntegrals of ray-volume properties.\n\nWKBIntegrals(nxx::Integer, nyy::Integer, nzz::Integer)::WKBIntegrals\n\nConstruct a WKBIntegrals instance, with arrays sized according to the given dimensions.\n\nFields\n\nuu::A: Zonal zonal-momentum flux.\nuv::A: Meridional zonal-momentum flux.\nuw::A: Vertical zonal-momentum flux.\nvv::A: Meridional meridional-momentum flux.\nvw::A: Vertical meridional-momentum flux.\nutheta::A: Zonal mass-weighted potential-temperature flux.\nvtheta::A: Meridional mass-weighted potential-temperature flux.\ne::A: Wave-energy density.\n\nArguments\n\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.WKBTypes.WKBTendencies","page":"Types","title":"PinCFlow.Types.WKBTypes.WKBTendencies","text":"WKBTendencies{A <: AbstractArray{<:AbstractFloat, 3}}\n\nGravity-wave drag and heating fields.\n\nWKBTendencies(nxx::Integer, nyy::Integer, nzz::Integer)::WKBTendencies\n\nConstruct a WKBTendencies instance, with arrays sized according to the given dimensions.\n\nFields\n\ndudt::A: Gravity-wave drag on the zonal momentum.\ndvdt::A: Gravity-wave drag on the meridional momentum.\ndthetadt::A: Gravity-wave heating term in the mass-weighted potential-temperature equation.\n\nArguments\n\nnxx: Number of subdomain grid points in widehatx-direction.\nnyy: Number of subdomain grid points in widehaty-direction.\nnzz: Number of subdomain grid points in widehatz-direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes","page":"Types","title":"PinCFlow.Types.TracerTypes","text":"TracerTypes\n\nModule for composite types needed for tracer transport.\n\nSee also\n\nPinCFlow.Types.NamelistTypes\nPinCFlow.Types.FoundationalTypes\nPinCFlow.Types.VariableTypes\n\n\n\n\n\n","category":"module"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.Tracer","page":"Types","title":"PinCFlow.Types.TracerTypes.Tracer","text":"Tracer{\n    A <: TracerPredictands,\n    B <: TracerIncrements,\n    C <: TracerAuxiliaries,\n    D <: TracerReconstructions,\n    E <: TracerFluxes,\n    F <: TracerForcings,\n}\n\nContainer for arrays needed for tracer transport.\n\nTracer(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    variables::Variables,\n)::Tracer\n\nConstruct a Tracer instance, with array dimensions and initial values set according to the model configuration.\n\nFields\n\ntracerpredictands::A: Tracers.\ntracerincrements::B: Runge-Kutta updates of the tracers.\ntracerauxiliaries::C: Initial states of the tracers.\ntracerreconstructions::D: Reconstructions of the tracers.\ntracerfluxes::E: Fluxes of the tracers.\ntracerforcings::F: Forcing terms due to gravity-waves and turbulence.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\ngrid: Collection of parameters and fields describing the grid.\nvariables: Container for arrays needed for the prediction of the prognostic variables.\n\nSee also\n\nPinCFlow.Types.TracerTypes.TracerPredictands\nPinCFlow.Types.TracerTypes.TracerIncrements\nPinCFlow.Types.TracerTypes.TracerAuxiliaries\nPinCFlow.Types.TracerTypes.TracerReconstructions\nPinCFlow.Types.TracerTypes.TracerFluxes\nPinCFlow.Types.TracerTypes.TracerForcings\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerAuxiliaries","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerAuxiliaries","text":"TracerAuxiliaries{A <: AbstractArray{<:AbstractFloat, 3}}\n\nInitial states of the tracers.\n\nTracerAuxiliaries(tracerpredictands::TracerPredictands)::TracerAuxiliaries\n\nConstruct a TracerAuxiliaries instance by copying the arrays in tracerpredictands.\n\nFields\n\ninitialtracer::A: Initial state of a non-dimensional tracer.\n\nArguments\n\ntracerpredictands: Tracers.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerFluxes","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerFluxes","text":"TracerFluxes{A <: AbstractArray{<:AbstractFloat, 4}}\n\nArrays for fluxes of tracers.\n\nThe first three dimensions represent physical space and the fourth dimension represents the flux direction.\n\nTracerFluxes(namelists::Namelists, domain::Domain)::TracerFluxes\n\nConstruct a TracerFluxes instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerFluxes(domain::Domain, tracer_setup::NoTracer)::TracerFluxes\n\nConstruct a TracerFluxes instance with zero-size arrays for configurations without tracer transport.\n\nTracerFluxes(domain::Domain, tracer_setup::TracerOn)::TracerFluxes\n\nConstruct a TracerFluxes instance with zero-initialized arrays.\n\nFields\n\nphichi::A: Fluxes of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerForcings","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerForcings","text":"TracerForcings{A <: TracerWKBImpact}\n\nContainer for TracerWKBImpact instance with all necessary terms for the right-hand side of the tracer equation.\n\nTracerForcings(namelists::Namelists, domain::Domain)::TracerForcings\n\nConstruct a TracerForcings instance set according to the model configuration.\n\nTracerForcings(\n    namelists::Namelists,\n    domain::Domain,\n    tracer_setup::NoTracer,\n)::TracerForcings\n\nConstruct a TracerForcings instance for configurations without tracer transport.\n\nTracerForcings(\n    namelists::Namelists,\n    domain::Domain,\n    tracer_setup::TracerOn,\n)::TracerForcings\n\nConstruct a TracerForcings instance for configurations with tracer transport.\n\nTracerForcings(domain::Domain, wkb_mode::NoWKB)::TracerForcings\n\nConstruct a TracerForcings instance for configurations without WKB model.\n\nTracerForcings(\n    domain::Domain,\n    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},\n)::TracerForcings\n\nConstruct a TracerForcings instance for configurations with tracer transport and WKB model.\n\nFields\n\nchiq0::A: Leading-order tracer forcings.\n\nArguments:\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracer_setup: General tracer-transport configuration.\nwkb_mode: Approximations used by MS-GWaM.\n\nSee also:\n\nPinCFlow.Types.TracerTypes.TracerWKBImpact\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerIncrements","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerIncrements","text":"TracerIncrements{A <: AbstractArray{<:AbstractFloat, 3}}\n\nArrays for the Runge-Kutta updates of tracers.\n\nTracerIncrements(namelists::Namelists, domain::Domain)::TracerIncrements\n\nConstruct a TracerIncrements instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerIncrements(domain::Domain, tracer_setup::NoTracer)::TracerIncrements\n\nConstruct a TracerIncrements instance with zero-size arrays for configurations without tracer transport.\n\nTracerIncrements(domain::Domain, tracer_setup::TracerOn)::TracerIncrements\n\nConstruct a TracerIncrements instance with zero-initialized arrays.\n\nFields\n\ndchi::A: Runge-Kutta update of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerPredictands","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerPredictands","text":"TracerPredictands{A <: AbstractArray{<:AbstractFloat, 3}}\n\nArrays for tracers.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with dimensions and initial values depending on the general configuration of tracer transport, by dispatching to the appropriate method.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    tracer_setup::NoTracer,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with zero-size arrays for configurations without tracer transport.\n\nTracerPredictands(\n    namelists::Namelists,\n    constants::Constants,\n    domain::Domain,\n    atmosphere::Atmosphere,\n    grid::Grid,\n    tracer_setup::TracerOn,\n    variables::Variables,\n)::TracerPredictands\n\nConstruct a TracerPredictands instance with a tracer initialized by the function initial_tracer in namelists.tracer. The tracer field is multiplied by the density.\n\nFields\n\nchi::A: Non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\nconstants: Physical constants and reference values.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\natmosphere: Atmospheric-background fields.\ngrid: Collection of parameters and fields describing the grid.\ntracer_setup: General tracer-transport configuration.\nvariables: Container for arrays needed for the prediction of the prognostic variables.\n\nSee also\n\nPinCFlow.Types.FoundationalTypes.set_zonal_boundaries_of_field!\nPinCFlow.Types.FoundationalTypes.set_meridional_boundaries_of_field!\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerReconstructions","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerReconstructions","text":"TracerReconstructions{A <: AbstractArray{<:AbstractFloat, 5}}\n\nArrays for the reconstruction of tracers.\n\nThe first three dimensions represent physical space, the fourth represents the physical-space dimension of the reconstruction and the fifth the two directions in which it is computed.\n\nTracerReconstructions(\n    namelists::Namelists,\n    domain::Domain,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with dimensions depending on the general tracer-transport configuration, by dispatching to the appropriate method.\n\nTracerReconstructions(\n    domain::Domain,\n    tracer_setup::NoTracer,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with zero-size arrays for configurations without tracer transport.\n\nTracerReconstructions(\n    domain::Domain,\n    tracer_setup::TracerOn,\n)::TracerReconstructions\n\nConstruct a TracerReconstructions instance with zero-initialized arrays.\n\nFields\n\nchitilde::A: Reconstructions of a non-dimensional tracer.\n\nArguments\n\nnamelists: Namelists with all model parameters.\ndomain: Collection of domain-decomposition and MPI-communication parameters.\ntracer_setup: General tracer-transport configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/types/#PinCFlow.Types.TracerTypes.TracerWKBImpact","page":"Types","title":"PinCFlow.Types.TracerTypes.TracerWKBImpact","text":"TracerWKBImpact{A <: AbstractArray{<:AbstractFloat, 3}}\n\nContainer for the gravity-wave-induced tracer fluxes and resulting tracer tendency.\n\nTracerWKBImpact(nxi::Integer, nyi::Integer, nzi::Integer)::TracerWKBImpact\n\nConstruct a TracerWKBImpact instance with array dimensions given by nxi, nyi, and nzi.\n\nFields\n\nuchi::A: Zonal tracer fluxes due to unresolved gravity waves.\nvchi::A: Meridional tracer fluxes due to unresolved gravity waves.\nwchi::A: Vertical tracer fluxes due to unresolved gravity waves.\ndchidt::A: Leading-order tracer impact of unresolved gravity waves.\n\nArguments:\n\nnxi: Grid-points in \\widehat{x}-direction.\nnyi: Grid-points in \\widehat{y}-direction.\nnzi: Grid-points in \\widehat{z}-direction.\n\n\n\n\n\n","category":"type"},{"location":"developer_guide/#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"developer_guide/#Workflow","page":"Developer guide","title":"Workflow","text":"The code is shared in a GitHub repository. Any contributions to the code should adhere to the following workflow.\n\nIf you are new to the repository, clone it.\nCreate a local branch for your contributions and commit your changes.\nPull recent changes made on the remote main branch into your local main branch and merge it into the branch with your contributions, resolving merge conflicts if necessary.\nEnsure that the model is stable and that all tests pass.\nPush your branch to remote repository.\nCreate a pull request for merging your commits into the remote main branch.\nRequest a review from a main developer.\nImplement changes requested by the reviewer until they approve the pull request.","category":"section"},{"location":"developer_guide/#Writing-code","page":"Developer guide","title":"Writing code","text":"Contributions to the code should respect the following rules.\n\nPut every module, composite type (including constructor methods) and function into a file on its own, with the file name matching that of the object. Create a folder for every module (see below for a diagram of PinCFlow.jl's modular structure).\nVariables that are communicated between functions should be stored at an appropriate level of the State instance (see below for a diagram of PinCFlow.jl's model-state structure).\nUse type parameters to declare the types of all composite-type fields.\nDeclare the types of all method arguments and the return types of all methods that return something other than nothing.\nUse PinCFlow.jl's @ivy in front of expressions that access elements of arrays/tuples. Always apply this macro to the outermost expression possible but do not create new blocks for this purpose.\nDo not use Unicode.\nUse CamelCase for the names of modules and types. Use single capital letters for type parameters (in alphabetical order). For all other objects, use snake_case.\n\n(Image: )\n\n(Image: )","category":"section"},{"location":"developer_guide/#Writing-documentation","page":"Developer guide","title":"Writing documentation","text":"Contributions to the code should always be accompanied by corresponding contributions to the documentation, respecting the following rules.\n\nWrite a docstring for every module, function and type.\nModule docstrings:\nInclude the exact full signature within a Julia code block, followed by a single descriptive (pseudo-)sentence and (if needed) additional paragraphs with more details.\nList links to imported modules in a # See also section, with one bullet for each.\nFunction docstrings:\nFor every method, include the exact full signature within a Julia code block, followed by a single, descriptive sentence in imperative form and (if needed) additional paragraphs with more details.\nList all positional and optional arguments with descriptions (but without types and default values) in an # Arguments section, with one bullet for each.\nList all keyword arguments with descriptions (but without types and default values) in a # Keywords section, with one bullet for each.\nList links to constructors/functions that are called in any of the function's methods in a # See also section, with one bullet for each.\nType docstrings:\nInclude the exact full signature within a Julia code block, followed by a single descriptive (pseudo-)sentence and (if needed) a additional paragraphs with more details.\nIf the type is composite, include the exact full signature within a Julia code block, followed by a single, descriptive sentence in imperative form and (if needed) additional paragraphs with more details, for each explicitly defined constructor method.\nIf the type is composite, list all fields with their type restrictions and descriptions in a # Fields section, with one bullet for each.\nIf the type is composite, list all positional and optional arguments of the explicitly defined constructor methods with descriptions (but without types and default values) in an # Arguments section, with one bullet for each.\nIf the type is composite, list all keyword arguments of the explicitly defined constructor methods with descriptions (but without types and default values) in a # Keywords section, with one bullet for each.\nIf the type is composite, list links to constructors/functions that are called in any of the explicitly defined constructor methods in a # See also section, with one bullet for each.\nUse single backticks to identify code and double backticks to identify equations. Use LaTeX escape sequences instead of Unicode characters.\nPlace the starting and ending \"\"\" characters on lines by themselves.","category":"section"},{"location":"developer_guide/#Markdown-syntax","page":"Developer guide","title":"Markdown syntax","text":"Markdown code should use the following syntax.\n\nHeadings:\n# Heading level 1\n\n## Heading level 2\n\n### Heading level 3\n\n#### Heading level 4\n\n##### Heading level 5\n\n###### Heading level 6\nParagraphs:\nThis is the first paragraph.\n\nThis is the second paragraph.\nEmphasis:\nThis sentence contains *italic*, **bold** and ***italic bold*** words.\nBlock quotes:\nThis is a sentence above a block quote.\n\n  > This is the first paragraph of a block quote.\n  >\n  >   > This is a nested block quote.\n  >\n  > This is the second paragraph of a block quote.\n\nThis is a sentence below a block quote.\n\nUnnumbered lists:\nThis is a sentence above an unnumbered list.\n\n  - This is the first paragraph of the first item.\n\n      - This is the first item of a nested list.\n\n      - This is the second item of a nested list.\n\n    This is the second paragraph of the first item.\n\n  - This is the second item.\n\nThis is a sentence below an unnumbered list.\nNumbered lists:\nThis is a sentence above a numbered list.\n\n 1. This is the first paragraph of the first item.\n\n     1. This is the first item of a nested list.\n\n     1. This is the second item of a nested list.\n\n    This is the second paragraph of the first item.\n\n 1. This is the second item.\n\n This is a sentence below a numbered list.\nInline code:\nThis sentence contains inline `code` and inline `` `nested code` ``.\nCode blocks:\nThis sentence contains the code block\n\n```julia\nif true\n    println(\"true\")\nend\n```\n\nand other stuff. This sentence contains the nested code blocks\n\n``````markdown\n```julia\nif true\n    println(\"true\")\nend\n```\n``````\n\nand other stuff.\nHorizontal rule:\n---\nURLs and email addresses:\nThis sentence contains the URL <http://example.com> and the email address <fake@example.com>.\nLinks:\nThis sentence contains a [link](http://example.com).\nImages:\n![](image.svg)\nBackslash escapes:\nThis sentence contains the backslash escapes \\\\\\`\\*\\_\\{\\}\\[\\]\\(\\)\\#\\+\\-\\.\\!.\nInline math:\nThis sentence contains the equation $x^2 + y^2 = z^2$.\nCentered math:\nThis sentence contains the equation\n\n$$x^2 + y^2 = z^2$$\n\nand other stuff.\n\nIn docstrings, the following syntax elements are different.\n\nInline math:\nThis sentence contains the equation ``x^2 + y^2 = z^2``.\nCentered math:\nThis sentence contains the equation\n\n```math\nx^2 + y^2 = z^2\n```\n\nand other stuff.\n\nMoreover, every backslash used for LaTeX commands in equations has to be doubled.","category":"section"},{"location":"developer_guide/#Building-and-accessing-the-documentation","page":"Developer guide","title":"Building and accessing the documentation","text":"PinCFlow.jl uses Documenter.jl. To build the documentation, run\n\njulia --project=docs -e 'using Pkg; Pkg.develop(; path = \".\"); Pkg.instantiate()'\njulia docs/make.jl\n\nin the root directory of the repository. The documentation will be generated in the docs/build directory. To view it, open docs/build/index.html in a web browser or preview the file in Visual Studio Code with Live Preview.","category":"section"},{"location":"developer_guide/#Running-and-updating-the-tests","page":"Developer guide","title":"Running and updating the tests","text":"PinCFlow.jl's tests run the example simulations with a few modified parameters (most notably a lower resolution) and check if the L_2 and L_infty norms of the resulting outputs agree with reference values (given a certain tolerance). For this purpose, the example scripts are directly read, modified and evaluated in the test environment. To run the tests, execute\n\njulia --project -e 'using Pkg; Pkg.test(; julia_args = `--check-bounds=auto`)'\n\nin the root directory of the repository. To update the reference values for the norms, run the tests after setting the variable update_references in test/runtests.jl to true.\n\nWhen you need to update the reference norms, please remember to also update the plots of the corresponding examples. Note that the exact results depend on the system and the level of parallelism you use. You may choose these freely.","category":"section"},{"location":"developer_guide/#Creating-new-releases","page":"Developer guide","title":"Creating new releases","text":"The creation of a new release must not be attempted without the express permission of one of PinCFlow.jl's maintainers. To create a new release, first update the version numbers in Project.toml, docs/Project.toml and examples/Project.toml (following the interpretation of semantic versioning) and add the release notes to NEWS.md, documenting all relevant changes that have been implemented since the last release. Push your commit, navigate to it on GitHub and add the comment @JuliaRegistrator register(). If the release includes breaking changes, the comment must mention where they are documented (an example of this can be found here).","category":"section"},{"location":"#PinCFlow.jl:-An-idealized-atmospheric-flow-solver-coupled-to-the-3D-transient-gravity-wave-model-MS-GWaM","page":"Home","title":"PinCFlow.jl: An idealized-atmospheric-flow solver coupled to the 3D transient gravity-wave model MS-GWaM","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Codecov) (Image: Coveralls) (Image: License: MIT) (Image: DOI)","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"PinCFlow.jl (Pseudo-inCompressible Flow solver) is an atmospheric-flow solver that was designed for conducting idealized simulations. It integrates the Boussinesq, pseudo-incompressible and compressible equations in a conservative flux form (Klein, 2009; Rieper et al., 2013), using a semi-implicit method that combines explicit and implicit time-stepping schemes (Benacchio & Klein, 2019; Schmid et al., 2021; Chew et al., 2022). Spatially, the equations are discretized with a finite-volume method, such that all quantities are represented by averages over grid cells and fluxes are computed on the respective cell interfaces. The grid is staggered (Arakawa & Lamb, 1977) so that the velocity components are defined at the same points as the corresponding fluxes of scalar quantities. PinCFlow.jl operates in a vertically stretched terrain-following coordinate system based on Gal-Chen and Somerville (1975a), Gal-Chen and Somerville (1975b) and Clark (1977).\n\nThe Lagrangian gravity-wave parameterization MS-GWaM (Multi-Scale Gravity-Wave Model) is interactively coupled to the dynamical core of PinCFlow.jl, so that unresolved gravity waves may be parameterized in a manner that accounts for transient wave-mean-flow interaction and horizontal wave propagation. The resolved fields are updated with tendencies computed by MS-GWaM at the beginning of every time step. A description of the theory behind MS-GWaM can be found in Achatz et al. (2017) and Achatz et al. (2023). For a numerical perspective and more information on the development, see Muraschko et al. (2014), Boeloeni et al. (2016), Wilhelm et al. (2018), Wei et al. (2019) and Jochum et al. (2025).","category":"section"},{"location":"#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install PinCFlow.jl, first make sure you have installed Julia. You can then run\n\njulia --project -e 'using Pkg; Pkg.add(\"PinCFlow\")'\n\nto add PinCFlow.jl to your current project environment.","category":"section"},{"location":"#Running-the-model","page":"Home","title":"Running the model","text":"As a minimal example, the script\n\nusing PinCFlow\n\nintegrate(Namelists())\n\nruns PinCFlow.jl in its default configuration, if executed with\n\njulia --project script.jl\n\nin your project's directory. This simulation will finish comparatively quickly and won't produce particularly interesting results, since PinCFlow.jl simply initializes a 1 times 1 times 1  mathrmkm^3 isothermal atmosphere at rest with a single grid cell and integrates the pseudo-incompressible equations over one hour. A more complex configuration can be set up by providing namelists with changed parameters. This is illustrated in PinCFlow.jl's example scripts. To run them, we recommend setting up an examples project by executing\n\njulia --project=examples -e 'using Pkg; Pkg.add([\"CairoMakie\", \"HDF5\", \"HDF5_jll\", \"MPI\", \"MPICH_jll\", \"MPIPreferences\", \"PinCFlow\", \"Revise\"])'\n\nHaving done this, you can easily run any of the example scripts without needing to worry about extra packages that you may need. For instance, executing the script\n\n# examples/scripts/periodic_hill.jl\n\nusing Pkg\n\nPkg.activate(\"examples\")\n\nusing MPI\nusing HDF5\nusing CairoMakie\nusing Revise\nusing PinCFlow\n\nnpx = length(ARGS) >= 1 ? parse(Int, ARGS[1]) : 1\nnpz = length(ARGS) >= 2 ? parse(Int, ARGS[2]) : 1\n\nh0 = 500.0\nl0 = 10000.0\n\nlz = 20000.0\nzr = 10000.0\n\natmosphere = AtmosphereNamelist(;\n    model = Boussinesq(),\n    background = StableStratification(),\n    coriolis_frequency = 0.0,\n    initial_u = (x, y, z) -> 10.0,\n)\ndomain = DomainNamelist(; x_size = 40, z_size = 40, lx = 20000.0, lz, npx, npz)\ngrid = GridNamelist(;\n    resolved_topography = (x, y) -> h0 / 2 * (1 + cos(pi / l0 * x)),\n)\noutput =\n    OutputNamelist(; output_variables = (:w,), output_file = \"periodic_hill.h5\")\nsponge = SpongeNamelist(;\n    rhs_sponge = (x, y, z, t, dt) ->\n        z >= zr ? sin(pi / 2 * (z - zr) / (lz - zr))^2 / dt : 0.0,\n)\n\nintegrate(Namelists(; atmosphere, domain, grid, output, sponge))\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    h5open(\"periodic_hill.h5\") do data\n        plot_output(\n            \"examples/results/periodic_hill.svg\",\n            data,\n            (\"w\", 1, 1, 1, 2);\n        )\n        return\n    end\nend\n\n\nruns a 2D simulation with an initial wind of 10  mathrmm  s^- 1 that generates a mountain wave above a periodic hill and visualizes the results.\n\nPinCFlow.jl uses parallel HDF5 to write simulation data. By default, the path to the output file is pincflow_output.h5. This may be changed by setting the parameter output_file of the namelist output accordingly (as illustrated above). The dimensions of most output fields are (in order) widehatx (zonal axis), widehaty (meridional axis), widehatz (axis orthogonal to the vertical coordinate surfaces) and t (time). Ray-volume-property fields differ slightly in that they have an additional (spectral) dimension in front and a vertical dimension that includes the first ghost layer below the surface. To specify which fields are to be written, set the parameters output_variables, save_ray_volumes and prepare_restart of the namelist output accordingly (more details are given in the \"Reference\" section of the documentation).\n\nFor the visualization of simulation results, we recommend using Makie.jl with the CairoMakie backend. PinCFlow.jl has an extension which exports a few convenience functions if CairoMakie is loaded. This is utilized in the above script, yielding a plot of the vertical wind at the end of the simulation (see below). You can find more examples on the \"Examples\" page of the documentation. A description of all namelists and their parameters is provided in the \"Reference\" section.\n\n(Image: )\n\nIf you want to run PinCFlow.jl in parallel, make sure you are using the correct backends for MPI.jl and HDF5.jl. By default, the two packages use JLL backends that have been automatically installed. If you want to keep this setting, you only need to make sure to use the correct MPI binary (specifically not that of a default MPI installation on your system). For example, with\n\nmpiexec=$(julia --project=examples -e 'using MPICH_jll; println(MPICH_jll.mpiexec_path)')\n${mpiexec} -n 9 julia examples/scripts/periodic_hill.jl 3 3\n\nyou can run the above simulation in 9 MPI processes. Note that by passing extra arguments to the script, you set the parameters npx and npz of the namelist domain, which represent the number of MPI processes in widehatx and widehatz. Their product must be equal to the total number of processes, otherwise PinCFlow.jl will throw an error.\n\nHowever, if you plan to run PinCFlow.jl on a cluster, you may want to consider using a provided MPI installation as backend. In that case, the MPI preferences need to be updated accordingly and the HDF5 backend has to be set to a library that has been installed with parallel support, using the chosen MPI installation. This can be done by running\n\njulia --project=examples -e 'using MPIPreferences; MPIPreferences.use_system_binary(; library_names = [\"/path/to/mpi/library/\"])'\njulia --project=examples -e 'using HDF5; HDF5.API.set_libraries!(\"/path/to/libhdf5.so\", \"/path/to/libhdf5_hl.so\")'\n\nwith the paths set appropriately (more details can be found in the documentations of MPI.jl and HDF5.jl). Note that this configuration will be saved in examples/LocalPreferences.toml, so that the new backends will be used by all future scripts run in the examples project. By running\n\njulia --project=examples -e 'using MPIPreferences; MPIPreferences.use_jll_binary()'\njulia --project=examples -e 'using HDF5; HDF5.API.set_libraries!()'\n\nyou can restore the default backends. Having configured MPI.jl and HDF5.jl to use installations on your system, you can run\n\nmpiexec -n 16 julia examples/scripts/periodic_hill.jl 4 4\n\nwith mpiexec being your chosen system binary. For users who would like to run PinCFlow.jl on Goethe or Levante, shell-script examples are provided in the folder examples/scripts of the repository.","category":"section"},{"location":"#List-of-publications","page":"Home","title":"List of publications","text":"Initial flow solver: Rieper et al. (2013)\nInitial gravity-wave scheme: Muraschko et al. (2014)\nGravity-wave breaking scheme: Boeloeni et al. (2016)\nGravity-wave theory: Achatz et al. (2017)\nCoupling of the flow solver and gravity-wave scheme: Wilhelm et al. (2018)\nHorizontal propagation and direct approach in the gravity-wave scheme: Wei et al. (2019)\nSemi-implicit time scheme: Schmid et al. (2021)\nExtended gravity-wave theory: Achatz et al. (2023)\nTerrain-following coordinates & orographic source: Jochum et al. (2025)","category":"section"}]
}
