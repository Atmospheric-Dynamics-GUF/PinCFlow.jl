<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MSGWaM · PinCFlow.jl</title><meta name="title" content="MSGWaM · PinCFlow.jl"/><meta property="og:title" content="MSGWaM · PinCFlow.jl"/><meta property="twitter:title" content="MSGWaM · PinCFlow.jl"/><meta name="description" content="Documentation for PinCFlow.jl."/><meta property="og:description" content="Documentation for PinCFlow.jl."/><meta property="twitter:description" content="Documentation for PinCFlow.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PinCFlow.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/mountain_wave_simulation/">Mountain-wave simulation</a></li><li><a class="tocitem" href="../../examples/wkb_mountain_wave_simulation/">WKB mountain-wave simulation</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/physics/">Physics</a></li><li><a class="tocitem" href="../../theory/numerics/">Numerics</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../pincflow/">PinCFlow</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../mpi_operations/">MPIOperations</a></li><li><a class="tocitem" href="../boundaries/">Boundaries</a></li><li><a class="tocitem" href="../flux_calculator/">FluxCalculator</a></li><li><a class="tocitem" href="../poisson_solver/">PoissonSolver</a></li><li><a class="tocitem" href="../update/">Update</a></li><li class="is-active"><a class="tocitem" href>MSGWaM</a><ul class="internal"><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#RayOperations"><span>RayOperations</span></a></li><li><a class="tocitem" href="#RaySources"><span>RaySources</span></a></li><li><a class="tocitem" href="#BoundaryRays"><span>BoundaryRays</span></a></li><li><a class="tocitem" href="#RayUpdate"><span>RayUpdate</span></a></li><li><a class="tocitem" href="#MeanFlowEffect"><span>MeanFlowEffect</span></a></li></ul></li><li><a class="tocitem" href="../integration/">Integration</a></li><li><a class="tocitem" href="../output/">Output</a></li></ul></li><li><a class="tocitem" href="../../developer_guide/">Developer guide</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>MSGWaM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MSGWaM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Atmospheric-Dynamics-GUF/PinCFlow.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MSGWaM"><a class="docs-heading-anchor" href="#MSGWaM">MSGWaM</a><a id="MSGWaM-1"></a><a class="docs-heading-anchor-permalink" href="#MSGWaM" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM" href="#PinCFlow.MSGWaM"><code>PinCFlow.MSGWaM</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MSGWaM</code></pre><p>3D transient implementation of MS-GWaM.</p><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays"><code>PinCFlow.MSGWaM.BoundaryRays</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayUpdate"><code>PinCFlow.MSGWaM.RayUpdate</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect"><code>PinCFlow.MSGWaM.MeanFlowEffect</code></a></p></li></ul><p><strong>External links</strong></p><ol><li><p><a href="https://doi.org/10.1002/qj.2381">Muraschko et al. (2014)</a></p></li><li><p><a href="https://doi.org/10.1175/JAS-D-16-0069.1">Boeloeni et al. (2016)</a></p></li><li><p><a href="https://doi.org/10.1175/JAS-D-17-0289.1">Wilhelm et al. (2018)</a></p></li><li><p><a href="https://doi.org/10.1175/JAS-D-18-0337.1">Wei et al. (2019)</a></p></li><li><p><a href="https://doi.org/10.1175/JAS-D-24-0158.1">Jochum et al. (2025)</a></p></li></ol></div></section></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation" href="#PinCFlow.MSGWaM.Interpolation"><code>PinCFlow.MSGWaM.Interpolation</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Interpolation</code></pre><p>Module for interpolating mean-flow quantities to ray-volume positions.</p><p>Provides functions that find the grid points closest to a given ray-volume position and perform trilinear interpolation of mean-flow quantities.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="../update/#PinCFlow.Update"><code>PinCFlow.Update</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DChiDX" href="#PinCFlow.MSGWaM.Interpolation.DChiDX"><code>PinCFlow.MSGWaM.Interpolation.DChiDX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DChiDX</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial \chi_\mathrm{b} / \partial x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DChiDY" href="#PinCFlow.MSGWaM.Interpolation.DChiDY"><code>PinCFlow.MSGWaM.Interpolation.DChiDY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DChiDY</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial \chi_\mathrm{b} / \partial y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DChiDZ" href="#PinCFlow.MSGWaM.Interpolation.DChiDZ"><code>PinCFlow.MSGWaM.Interpolation.DChiDZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DChiDZ</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial \chi_\mathrm{b} / \partial z$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DN2DZ" href="#PinCFlow.MSGWaM.Interpolation.DN2DZ"><code>PinCFlow.MSGWaM.Interpolation.DN2DZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DN2DZ</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial N^2 / \partial z$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DUDX" href="#PinCFlow.MSGWaM.Interpolation.DUDX"><code>PinCFlow.MSGWaM.Interpolation.DUDX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DUDX</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial u_\mathrm{b} / \partial x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DUDY" href="#PinCFlow.MSGWaM.Interpolation.DUDY"><code>PinCFlow.MSGWaM.Interpolation.DUDY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DUDY</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial u_\mathrm{b} / \partial y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DUDZ" href="#PinCFlow.MSGWaM.Interpolation.DUDZ"><code>PinCFlow.MSGWaM.Interpolation.DUDZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DUDZ</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial u_\mathrm{b} / \partial z$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DVDX" href="#PinCFlow.MSGWaM.Interpolation.DVDX"><code>PinCFlow.MSGWaM.Interpolation.DVDX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DVDX</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial v_\mathrm{b} / \partial x$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DVDY" href="#PinCFlow.MSGWaM.Interpolation.DVDY"><code>PinCFlow.MSGWaM.Interpolation.DVDY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DVDY</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial v_\mathrm{b} / \partial y$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.DVDZ" href="#PinCFlow.MSGWaM.Interpolation.DVDZ"><code>PinCFlow.MSGWaM.Interpolation.DVDZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DVDZ</code></pre><p>Singleton for dispatch to interpolation of <span>$\partial v_\mathrm{b} / \partial z$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.N2" href="#PinCFlow.MSGWaM.Interpolation.N2"><code>PinCFlow.MSGWaM.Interpolation.N2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">N2</code></pre><p>Singleton for dispatch to interpolation of <span>$N^2$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.compute_derivatives" href="#PinCFlow.MSGWaM.Interpolation.compute_derivatives"><code>PinCFlow.MSGWaM.Interpolation.compute_derivatives</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DUDX,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the zonal derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial x$</span>) at <span>$\left(i, j, k_\mathrm{D}\right)$</span> and <span>$\left(i, j, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial u_\mathrm{b}}{\partial x}\right) = \frac{u_{\mathrm{b}, i + 1 / 2} - u_{\mathrm{b}, i - 1 / 2}}{\Delta \widehat{x}} + G^{13} \frac{u_{\mathrm{b}, k + 1} - u_{\mathrm{b}, k - 1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DUDY,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the meridional derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial y$</span>) at <span>$\left(i + 1 / 2, j + 1 / 2, k_\mathrm{D}\right)$</span> and <span>$\left(i + 1 / 2, j + 1 / 2, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\begin{align*}
    \left(\frac{\partial u_\mathrm{b}}{\partial y}\right)_{i + 1 / 2, j + 1 / 2} &amp; = \frac{u_{\mathrm{b}, i + 1 / 2, j + 1} - u_{\mathrm{b}, i + 1 / 2}}{\Delta \widehat{y}} + G_{i + 1 / 2, j + 1 / 2}^{23} \frac{u_{\mathrm{b}, i + 1 / 2, j + 1 / 2, k + 1} - u_{\mathrm{b}, i + 1 / 2, j + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.
\end{align*}\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DUDZ,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the vertical derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial z$</span>) at <span>$\left(i + 1 / 2, j, k_\mathrm{D} + 1 / 2\right)$</span> and <span>$\left(i + 1 / 2, j, k_\mathrm{U} + 1 / 2\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial u_\mathrm{b}}{\partial z}\right)_{i + 1 / 2, k + 1 / 2} = \frac{u_{\mathrm{b}, i + 1 / 2, k + 1} - u_{\mathrm{b}, i + 1 / 2}}{J_{i + 1 / 2, k + 1 / 2} \Delta \widehat{z}}.\]</p><p>At grid points beyond the vertical boundaries, it is set to zero.</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DVDX,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the zonal derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial x$</span>) at <span>$\left(i + 1 / 2, j + 1 / 2, k_\mathrm{D}\right)$</span> and <span>$\left(i + 1 / 2, j + 1 / 2, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial v_\mathrm{b}}{\partial x}\right)_{i + 1 / 2, j + 1 / 2} = \frac{v_{\mathrm{b}, i + 1, j + 1 / 2} - v_{\mathrm{b}, j + 1 / 2}}{\Delta \widehat{x}} + G_{i + 1 / 2, j + 1 / 2}^{13} \frac{v_{\mathrm{b}, i + 1 / 2, j + 1 / 2, k + 1} - v_{\mathrm{b}, i + 1 / 2, j + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DVDY,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the meridional derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial y$</span>) at <span>$\left(i, j, k_\mathrm{D}\right)$</span> and <span>$\left(i, j, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial v_\mathrm{b}}{\partial y}\right) = \frac{v_{\mathrm{b}, j + 1 / 2} - v_{\mathrm{b}, j - 1 / 2}}{\Delta \widehat{y}} + G^{23} \frac{v_{\mathrm{b}, k + 1} - v_{\mathrm{b}, k - 1} }{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DVDZ,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the vertical derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial z$</span>) at <span>$\left(i, j + 1 / 2, k_\mathrm{D} + 1 / 2\right)$</span> and <span>$\left(i, j + 1 / 2, k_\mathrm{U} + 1 / 2\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial v_\mathrm{b}}{\partial z}\right)_{j + 1 / 2, k + 1 / 2} = \frac{v_{\mathrm{b}, j + 1 / 2, k + 1} - v_{\mathrm{b}, j + 1 / 2}}{J_{j + 1 / 2, k + 1 / 2} \Delta \widehat{z}}.\]</p><p>At grid points beyond the vertical boundaries, it is set to zero.</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DChiDX,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the zonal derivative of the tracer field (<span>$\partial \chi_\mathrm{b} / \partial x$</span>) at <span>$\left(i + 1 / 2, j, k_\mathrm{D}\right)$</span> and <span>$\left(i + 1 / 2, j, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial \chi_\mathrm{b}}{\partial x}\right)_{i + 1 / 2} = \frac{\chi_{\mathrm{b}, i + 1} - \chi_\mathrm{b}}{\Delta \widehat{x}} + G_{i + 1 / 2}^{13} \frac{\chi_{\mathrm{b}, i + 1 / 2, k + 1} - \chi_{\mathrm{b}, i + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DChiDY,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the meridional derivative of the tracer field (<span>$\partial \chi_\mathrm{b} / \partial y$</span>) at <span>$\left(i, j + 1 / 2, k_\mathrm{D}\right)$</span> and <span>$\left(i, j + 1 / 2, k_\mathrm{U}\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial \chi_\mathrm{b}}{\partial y}\right)_{j + 1 / 2} = \frac{\chi_{\mathrm{b}, j + 1} - \chi_\mathrm{b}}{\Delta \widehat{y}} + G_{j + 1 / 2}^{23} \frac{\chi_{\mathrm{b}, j + 1 / 2, k + 1} - \chi_{\mathrm{b}, j + 1 / 2, k - 1}}{2 \Delta \widehat{z}}.\]</p><pre><code class="language-julia hljs">compute_derivatives(
    state::State,
    i::Integer,
    j::Integer,
    kd::Integer,
    ku::Integer,
    phitype::DChiDZ,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the vertical derivative of the tracer field (<span>$\partial \chi_\mathrm{b} / \partial z$</span>) at <span>$\left(i, j, k_\mathrm{D} + 1 / 2\right)$</span> and <span>$\left(i, j, k_\mathrm{U} + 1 / 2\right)$</span>.</p><p>The derivative is given by</p><p class="math-container">\[\left(\frac{\partial \chi_\mathrm{b}}{\partial z}\right)_{k + 1 / 2} = \frac{\chi_{\mathrm{b}, k + 1} - \chi_\mathrm{b}}{J_{k + 1 / 2} \Delta \widehat{z}}.\]</p><p>At grid points beyond the vertical boundaries, it is set to zero.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>kd</code>: Lower vertical grid-cell index.</p></li><li><p><code>ku</code>: Upper vertical grid-cell index.</p></li><li><p><code>phitype</code>: Type of derivative to compute.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.get_next_half_level" href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_next_half_level(
    i::Integer,
    j::Integer,
    z::AbstractFloat,
    state::State;
    dkd::Integer = 0,
    dku::Integer = 0,
)::Integer</code></pre><p>Determine and return the index of the next half-level above <code>z</code> at the horizontal position <span>$\left(i, j\right)$</span>.</p><p>This method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.</p><ul><li><p>In MPI processes at the lower boundary of the domain, the computed index has the lower bound <code>state.domain.k0</code>. In other processes, an error is thrown if it is below <code>1 + dkd</code>.</p></li><li><p>In MPI processes at the upper boundary of the domain, the computed index has the upper bound <code>state.domain.k1</code>. In other processes, an error is thrown if it is above <code>state.domain.nzz - dku</code>.</p></li></ul><p>In case an error is thrown, the parameter <code>wkb_cfl_number</code> of the discretization namelist should be set to a smaller value.</p><p><strong>Arguments</strong></p><ul><li><p><code>i</code>: Zonal index.</p></li><li><p><code>j</code>: Meridional index.</p></li><li><p><code>z</code>: Vertical position.</p></li><li><p><code>state</code>: Model state.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>dkd</code>: Number of levels needed below.</p></li><li><p><code>dku</code>: Number of levels needed above.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.get_next_level" href="#PinCFlow.MSGWaM.Interpolation.get_next_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_level</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_next_level(
    i::Integer,
    j::Integer,
    z::AbstractFloat,
    state::State;
    dkd::Integer = 0,
    dku::Integer = 0,
)::Integer</code></pre><p>Determine and return the index of the next level above <code>z</code> at the horizontal position <span>$\left(i, j\right)$</span>.</p><p>This method is heavily used for interpolation to ray-volume positions. To ensure that the vertical boundary conditions are met and no out-of-bounds errors occur, the following constraints are set.</p><ul><li><p>In MPI processes at the lower boundary of the domain, the computed index has the lower bound <code>state.domain.k0</code>. In other processes, an error is thrown if it is below <code>1 + dkd</code>.</p></li><li><p>In MPI processes at the upper boundary of the domain, the computed index has the upper bound <code>state.domain.k1 + 1</code>. In other processes, an error is thrown if it is above <code>state.domain.nzz - dku</code>.</p></li></ul><p>In case an error is thrown, the parameter <code>wkb_cfl_number</code> of the discretization namelist should be set to a smaller value.</p><p><strong>Arguments</strong></p><ul><li><p><code>i</code>: Zonal index.</p></li><li><p><code>j</code>: Meridional index.</p></li><li><p><code>z</code>: Vertical position.</p></li><li><p><code>state</code>: Model state.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>dkd</code>: Number of levels needed below.</p></li><li><p><code>dku</code>: Number of levels needed above.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.interpolate" href="#PinCFlow.MSGWaM.Interpolation.interpolate"><code>PinCFlow.MSGWaM.Interpolation.interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate(
    state::State;
    philbd::AbstractFloat = NaN,
    philbu::AbstractFloat = NaN,
    philfd::AbstractFloat = NaN,
    philfu::AbstractFloat = NaN,
    phirbd::AbstractFloat = NaN,
    phirbu::AbstractFloat = NaN,
    phirfd::AbstractFloat = NaN,
    phirfu::AbstractFloat = NaN,
    zlbd::AbstractFloat = NaN,
    zlbu::AbstractFloat = NaN,
    zlfd::AbstractFloat = NaN,
    zlfu::AbstractFloat = NaN,
    zrbd::AbstractFloat = NaN,
    zrbu::AbstractFloat = NaN,
    zrfd::AbstractFloat = NaN,
    zrfu::AbstractFloat = NaN,
    zlc::AbstractFloat = NaN,
    yb::AbstractFloat = NaN,
    yf::AbstractFloat = NaN,
    ylc::AbstractFloat = NaN,
    xl::AbstractFloat = NaN,
    xr::AbstractFloat = NaN,
    xlc::AbstractFloat = NaN,
)::AbstractFloat</code></pre><p>Perform trilinear interpolation to <code>(xlc, ylc, zlc)</code>, with values from eight surrounding grid points (two zonal positions, two meridional positions and eight vertical positions), and return the result.</p><p>Out of the eight grid points, four each are assumed to be to the left, to the right, behind, in front of, below and above the location of interest. Due to the grid being terrain-following, this includes eight different vertical positions, but only two zonal and two meridional positions. This is handled by performing successive linear interpolations, where the vertical position is interpolated along with the field of interest.</p><p>The exact algorithm is as follows.</p><ol><li><p>Interpolation in <span>$x$</span>:</p><p class="math-container">\[\begin{align*}
\psi_\mathrm{BD} &amp; = f_x \psi_\mathrm{LBD} + (1 - f_x) \psi_\mathrm{RBD},\\
\psi_\mathrm{BU} &amp; = f_x \psi_\mathrm{LBU} + (1 - f_x) \psi_\mathrm{RBU},\\
\psi_\mathrm{FD} &amp; = f_x \psi_\mathrm{LFD} + (1 - f_x) \psi_\mathrm{RFD},\\
\psi_\mathrm{FU} &amp; = f_x \psi_\mathrm{LFU} + (1 - f_x) \psi_\mathrm{RFU}
\end{align*}\]</p></li><li><p>Interpolation in <span>$y$</span>:</p><p class="math-container">\[\begin{align*}
\psi_\mathrm{D} &amp; = f_y \psi_\mathrm{BD} + (1 - f_y) \psi_\mathrm{FD},\\
\psi_\mathrm{U} &amp; = f_y \psi_\mathrm{BU} + (1 - f_y) \psi_\mathrm{FU}
\end{align*}\]</p></li><li><p>Interpolation in <span>$z$</span>:</p><p class="math-container">\[\phi_\mathrm{C} = f_z \phi_\mathrm{D} + (1 - f_z) \phi_\mathrm{U}\]</p></li></ol><p>Therein, <span>$\mathrm{L}$</span>, <span>$\mathrm{R}$</span>, <span>$\mathrm{B}$</span>, <span>$\mathrm{F}$</span>, <span>$\mathrm{D}$</span> and <span>$\mathrm{U}$</span> denote grid points to the left, to the right, forward, backward, downward and upward of the location of interest (denoted by <span>$\mathrm{C}$</span>), respectively, <span>$\psi = \left(\phi, z\right)$</span> and</p><p class="math-container">\[f_\alpha = \begin{cases}
0 &amp; \mathrm{if} \quad \alpha_\beta = \alpha_\gamma,\\
1 &amp; \mathrm{if} \quad \alpha_\mathrm{C} &lt; \alpha_\beta,\\
\frac{\alpha_\gamma - \alpha_\mathrm{C}}{\alpha_\gamma - \alpha_\beta} &amp; \mathrm{if} \quad \alpha_\beta \leq \alpha_\mathrm{C} \leq \alpha_\gamma,\\
0 &amp; \mathrm{if} \quad \alpha_\gamma &lt; \alpha_\mathrm{C},
\end{cases}\]</p><p>where <span>$\left(\alpha, \beta, \gamma\right) \in \left\{\left(x, \mathrm{L}, \mathrm{R}\right), \left(y, \mathrm{B}, \mathrm{F}\right), \left(z, \mathrm{D}, \mathrm{U}\right)\right\}$</span>.</p><p>Due to their large number, the positions and values are given as keyword arguments with the default value <code>NaN</code>, so that their order does not matter and calls with missing arguments are easy to detect.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>philbd</code>: Value at the point to the left, behind and below.</p></li><li><p><code>philbu</code>: Value at the point to the left, behind and above.</p></li><li><p><code>philfd</code>: Value at the point to the left, in front and below.</p></li><li><p><code>philfu</code>: Value at the point to the left, in front and above.</p></li><li><p><code>phirbd</code>: Value at the point to the right, behind and below.</p></li><li><p><code>phirbu</code>: Value at the point to the right, behind and above.</p></li><li><p><code>phirfd</code>: Value at the point to the right, in front and below.</p></li><li><p><code>phirfu</code>: Value at the point to the right, in front and above.</p></li><li><p><code>zlbd</code>: Vertical coordinate of the point to the left, behind and below.</p></li><li><p><code>zlbu</code>: Vertical coordinate of the point to the left, behind and above.</p></li><li><p><code>zlfd</code>: Vertical coordinate of the point to the left, in front and below.</p></li><li><p><code>zlfu</code>: Vertical coordinate of the point to the left, in front and above.</p></li><li><p><code>zrbd</code>: Vertical coordinate of the point to the right, behind and below.</p></li><li><p><code>zrbu</code>: Vertical coordinate of the point to the right, behind and above.</p></li><li><p><code>zrfd</code>: Vertical coordinate of the point to the right, in front and below.</p></li><li><p><code>zrfu</code>: Vertical coordinate of the point to the right, in front and above.</p></li><li><p><code>zlc</code>: Vertical position of interest.</p></li><li><p><code>yb</code>: Meridional coordinate of the points behind.</p></li><li><p><code>yf</code>: Meridional coordinate of the points in front.</p></li><li><p><code>ylc</code>: Meridional position of interest.</p></li><li><p><code>xl</code>: Zonal coordinate of the points to the left.</p></li><li><p><code>xr</code>: Zonal coordinate of the points to the right.</p></li><li><p><code>xlc</code>: Zonal position of interest.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow" href="#PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow"><code>PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::U,
)::AbstractFloat</code></pre><p>Interpolate the zonal wind (<span>$u_\mathrm{b}$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x} + \Delta \widehat{x} / 2$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$u_\mathrm{b}$</span> to the location of interest, using <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::V,
)::AbstractFloat</code></pre><p>Interpolate the meridional wind (<span>$v_\mathrm{b}$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y} + \Delta \widehat{y} / 2$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. The steps that follow are analogous to those in the method for the zonal wind (<span>$u_\mathrm{b}$</span>).</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::W,
)::AbstractFloat</code></pre><p>Interpolate the vertical wind (<span>$w_\mathrm{b}$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z + J \Delta \widehat{z} / 2$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$w_\mathrm{b}$</span> to the location of interest, using <code>compute_vertical_wind</code> and <code>interpolate</code>. At grid points beyond the vertical boundaries, the values used in the interpolation are replaced with zeros.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DUDX,
)::AbstractFloat</code></pre><p>Interpolate the zonal derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial x$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial u_\mathrm{b} / \partial x$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DUDY,
)::AbstractFloat</code></pre><p>Interpolate the meridional derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial y$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x} + \Delta \widehat{x} / 2$</span> and <span>$\widehat{y} + \Delta \widehat{y} / 2$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial u_\mathrm{b} / \partial y$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DUDZ,
)::AbstractFloat</code></pre><p>Interpolate the vertical derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial z$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x} + \Delta \widehat{x} / 2$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z + J \Delta \widehat{z} / 2$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial u_\mathrm{b} / \partial z$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DVDX,
)::AbstractFloat</code></pre><p>Interpolate the zonal derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial x$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x} + \Delta \widehat{x} / 2$</span> and <span>$\widehat{y} + \Delta \widehat{y} / 2$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. The steps that follow are analogous to those in the method for the meridional derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial y$</span>).</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DVDY,
)::AbstractFloat</code></pre><p>Interpolate the meridional derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial y$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. The steps that follow are analogous to those in the method for the zonal derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial x$</span>).</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DVDZ,
)::AbstractFloat</code></pre><p>Interpolate the vertical derivative of the meridional wind (<span>$\partial v_\mathrm{b} / \partial z$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y} + \Delta \widehat{y} / 2$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. The steps that follow are analogous to those in the method for the vertical derivative of the zonal wind (<span>$\partial u_\mathrm{b} / \partial z$</span>).</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DChiDX,
)::AbstractFloat</code></pre><p>Interpolate the zonal derivative of the tracer mixing ratio (<span>$\partial \chi_\mathrm{b} / \partial x$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x} + \Delta \widehat{x} / 2$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial \chi_\mathrm{b} / \partial x$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DChiDY,
)::AbstractFloat</code></pre><p>Interpolate the meridional derivative of the tracer mixing ratio (<span>$\partial \chi_\mathrm{b} / \partial y$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y} + \Delta \widehat{y} / 2$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial \chi_\mathrm{b} / \partial y$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><pre><code class="language-julia hljs">interpolate_mean_flow(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
    phitype::DChiDZ,
)::AbstractFloat</code></pre><p>Interpolate the vertical derivative of the tracer mixing ratio (<span>$\partial \chi_\mathrm{b} / \partial z$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z + J \Delta \widehat{z} / 2$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\partial \chi_\mathrm{b} / \partial z$</span> to the location of interest, using <code>compute_derivatives</code> and <code>interpolate</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>xlc</code>: Zonal position of interest.</p></li><li><p><code>ylc</code>: Meridional position of interest.</p></li><li><p><code>zlc</code>: Vertical position of interest.</p></li><li><p><code>state</code>: Model state.</p></li><li><p><code>phitype</code>: Mean-flow quantity to interpolate.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_level</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate"><code>PinCFlow.MSGWaM.Interpolation.interpolate</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li><li><p><a href="../update/#PinCFlow.Update.compute_vertical_wind"><code>PinCFlow.Update.compute_vertical_wind</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.compute_derivatives"><code>PinCFlow.MSGWaM.Interpolation.compute_derivatives</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.interpolate_sponge" href="#PinCFlow.MSGWaM.Interpolation.interpolate_sponge"><code>PinCFlow.MSGWaM.Interpolation.interpolate_sponge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_sponge(
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    state::State,
)::AbstractFloat</code></pre><p>Interpolate the Rayleigh-damping coefficient of the LHS sponge (<span>$\alpha_\mathrm{R}$</span>) to <code>(xlc, ylc, zlc)</code>, using a trilinear-interpolation algorithm, and return the result.</p><p>This method first determines the two points in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span> that are closest to <code>xlc</code> and <code>ylc</code>, respectively. For each of these four horizontal positions, it then determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. The resulting eight grid points are used to interpolate <span>$\alpha_\mathrm{R}$</span> to the location of interest, using <code>interpolate</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>xlc</code>: Zonal position of interest.</p></li><li><p><code>ylc</code>: Meridional position of interest.</p></li><li><p><code>zlc</code>: Vertical position of interest.</p></li><li><p><code>state</code>: Model state.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_level</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate"><code>PinCFlow.MSGWaM.Interpolation.interpolate</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.Interpolation.interpolate_stratification" href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_stratification(
    zlc::AbstractFloat,
    state::State,
    strtype::N2,
)::AbstractFloat</code></pre><p>Interpolate the squared buoyancy frequency (<span>$N^2$</span>) to <code>zlc</code> and return the result.</p><p>This method first determines the two points in <span>$z$</span> that are closest to <code>zlc</code>. As horizontal position, it uses <code>(i0, j0)</code>, which is arbitrary, since <span>$N^2$</span> has no horizontal dependence. Subsequently, simple linear interpolation is performed to find <span>$N^2$</span> at <code>zlc</code>.</p><pre><code class="language-julia hljs">interpolate_stratification(
    zlc::AbstractFloat,
    state::State,
    strtype::DN2DZ,
)::AbstractFloat</code></pre><p>Interpolate the vertical derivative of the squared buoyancy frequency (<span>$\partial N^2 / \partial z$</span>) to <code>zlc</code> and return the result.</p><p>This method first determines the two points in <span>$z + J \Delta \widehat{z} / 2$</span> that are closest to <code>zlc</code>. As for <span>$N^2$</span>, <code>(i0, j0)</code> is used as the horizontal position, and simple linear interpolation is performed to find <span>$\partial N^2 / \partial z$</span> at <code>zlc</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>zlc</code>: Vertical position of interest.</p></li><li><p><code>state</code>: Model state.</p></li><li><p><code>strtype</code>: Stratification quantity to interpolate.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_level</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li></ul></div></section></article><h2 id="RayOperations"><a class="docs-heading-anchor" href="#RayOperations">RayOperations</a><a id="RayOperations-1"></a><a class="docs-heading-anchor-permalink" href="#RayOperations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations" href="#PinCFlow.MSGWaM.RayOperations"><code>PinCFlow.MSGWaM.RayOperations</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayOperations</code></pre><p>Module for various ray-volume operations needed throughout <code>PinCFlow.MSGWaM</code>.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation"><code>PinCFlow.MSGWaM.Interpolation</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.check_rays" href="#PinCFlow.MSGWaM.RayOperations.check_rays"><code>PinCFlow.MSGWaM.RayOperations.check_rays</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_rays(state::State)</code></pre><p>Check if all ray volumes are assigned to the correct grid cells.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency" href="#PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency"><code>PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_intrinsic_frequency(
    state::State,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::AbstractFloat</code></pre><p>Return the intrinsic frequency of the ray volume specified by <span>$\left(r, i, j, k\right)$</span>.</p><p>The intrinsic frequency is calculated from the dispersion relation</p><p class="math-container">\[\widehat{\omega}_r = \sigma \sqrt{\frac{N_r^2 \left(k_r^2 + l_r^2\right) + f^2 m_r^2}{\left|\boldsymbol{k}_r\right|^2}},\]</p><p>where <span>$N_r^2$</span> is the squared buoyancy frequency interpolated to the ray volume&#39;s vertical position and <span>$\sigma$</span> is the frequency branch.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.compute_merge_index" href="#PinCFlow.MSGWaM.RayOperations.compute_merge_index"><code>PinCFlow.MSGWaM.RayOperations.compute_merge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_merge_index(
    wnr::AbstractFloat,
    wnr_min_p::AbstractFloat,
    wnr_max_p::AbstractFloat,
    wnr_min_n::AbstractFloat,
    wnr_max_n::AbstractFloat,
    dwnr_mrg_p::AbstractFloat,
    dwnr_mrg_n::AbstractFloat,
    nray::Integer,
)::Integer</code></pre><p>Return the index of the wavenumber <code>wnr</code> on a 1D spectral grid specified by the other arguments.</p><p>This method is used by <a href="#PinCFlow.MSGWaM.RayUpdate.merge_rays!"><code>PinCFlow.MSGWaM.RayUpdate.merge_rays!</code></a> to sort ray volumes into spectral bins.</p><p><strong>Arguments</strong></p><ul><li><p><code>wnr</code>: Wavenumber value.</p></li><li><p><code>wnr_min_p</code>: Minimum positive wavenumber.</p></li><li><p><code>wnr_max_p</code>: Maximum positive wavenumber.</p></li><li><p><code>wnr_min_n</code>: Minimum negative wavenumber.</p></li><li><p><code>wnr_max_n</code>: Maximum negative wavenumber.</p></li><li><p><code>dwnr_mrg_p</code>: Logarithmic spacing of discrete positive wavenumbers.</p></li><li><p><code>dwnr_mrg_n</code>: Logarithmic spacing of discrete negative wavenumbers.</p></li><li><p><code>nray</code>: Number of spectral grid points.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals" href="#PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals"><code>PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_saturation_integrals(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{2, &lt;:AbstractFloat}</code></pre><p>Compute and return the two spectral integrals <span>$S_1$</span> and <span>$S_2$</span>, as needed by the saturation scheme (in the grid cell <span>$\left(i, j, k\right)$</span>).</p><p>Computes the sums</p><p class="math-container">\[\begin{align*}
    S_1 &amp; \approx \sum\limits_r \left(m_r \left|b_{\mathrm{w}, r}\right|\right)^2 f_r,\\
    S_2 &amp; \approx \sum\limits_r \left(m_r \left|b_{\mathrm{w}, r}\right| \left|\boldsymbol{k}_r\right|\right)^2 f_r,
\end{align*}\]</p><p>where</p><p class="math-container">\[f_r = \max \left(1, \frac{\Delta x_r}{\Delta \widehat{x}}\right) \max \left(1, \frac{\Delta y_r}{\Delta \widehat{y}}\right) \max \left(1, \frac{\Delta z_r}{J \Delta \widehat{z}}\right)\]</p><p>is the maximum grid-cell fraction that can be covered by each ray volume (with <span>$\left(\Delta x_r, \Delta y_r, \Delta z_r\right)$</span> being the ray-volume extents in physical space) and</p><p class="math-container">\[\left|b_{\mathrm{w}, r}\right|^2 = \frac{2}{\overline{\rho}} \frac{N_r^4 \left(k_r^2 + l_r^2\right)}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2} \mathcal{N}_r \Delta k_r \Delta l_r \Delta m_r\]</p><p>is the squared gravity-wave amplitude of the buoyancy. Therein, <span>$N_r^2$</span> is the squared buoyancy frequency interpolated to the ray-volume position (using <code>interpolate_stratification</code>) and <span>$\left(\Delta k_r, \Delta l_r, \Delta m_r\right)$</span> are the ray-volume extents in spectral space.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency"><code>PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds" href="#PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds"><code>PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_spectral_bounds(
    wavenumbers::AbstractVector{&lt;:AbstractFloat},
)::NTuple{4, &lt;:AbstractFloat}</code></pre><p>Compute the minima and maxima of positive and negative entries in <code>wavenumbers</code> and return them (in the order positive minimum, positive maximum, negative minimum, negative maximum).</p><p>This method is used by <a href="#PinCFlow.MSGWaM.RayUpdate.merge_rays!"><code>PinCFlow.MSGWaM.RayUpdate.merge_rays!</code></a> to create spectral bins.</p><p><strong>Arguments</strong></p><ul><li><code>wavenumbers</code>: Vector of wavenumbers in the considered spectral dimension.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral" href="#PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral"><code>PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_wave_action_integral(
    merge_mode::ConstantWaveAction,
    nr::AbstractFloat,
    omegar::AbstractFloat,
    fxk::AbstractFloat,
    fyl::AbstractFloat,
    fzm::AbstractFloat,
)</code></pre><p>Return the wave action obtained by multiplying the given phase-space wave-action density with the given phase-space volume.</p><p>This method is used to implement conservation of wave action in ray-volume merging.</p><pre><code class="language-julia hljs">compute_wave_action_integral(
    merge_mode::ConstantWaveEnergy,
    nr::AbstractFloat,
    omegar::AbstractFloat,
    fxk::AbstractFloat,
    fyl::AbstractFloat,
    fzm::AbstractFloat,
)::AbstractFloat</code></pre><p>Return the wave energy obtained by multiplying the given phase-space wave-action density with the given intrinsic frequency and phase-space volume.</p><p>This method is used to implement conservation of wave energy in ray-volume merging.</p><p><strong>Arguments</strong></p><ul><li><p><code>merge_mode</code>: Merging strategy.</p></li><li><p><code>nr</code>: Phase-space wave-action density.</p></li><li><p><code>omegar</code>: Intrinsic frequency.</p></li><li><p><code>fxk</code>: Phase space factor in the <span>$x$</span>-<span>$k$</span> subspace.</p></li><li><p><code>fyl</code>: Phase space factor in the <span>$y$</span>-<span>$l$</span> subspace.</p></li><li><p><code>fzm</code>: Phase space factor in the <span>$z$</span>-<span>$m$</span> subspace.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.copy_rays!" href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy_rays!(
    rays::Rays,
    r::Pair{&lt;:Integer, &lt;:Integer},
    i::Pair{&lt;:Integer, &lt;:Integer},
    j::Pair{&lt;:Integer, &lt;:Integer},
    k::Pair{&lt;:Integer, &lt;:Integer},
)</code></pre><p>Copy all properties of the ray volume specified by the first components of the index pairs to that specified by the second components.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume indices.</p></li><li><p><code>i</code>: Zonal grid-cell indices.</p></li><li><p><code>j</code>: Meridional grid-cell indices.</p></li><li><p><code>k</code>: Vertical grid-cell indices.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.get_physical_extent" href="#PinCFlow.MSGWaM.RayOperations.get_physical_extent"><code>PinCFlow.MSGWaM.RayOperations.get_physical_extent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_physical_extent(
    rays::Rays,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{3, &lt;:AbstractFloat}</code></pre><p>Return the physical extents of the ray volume specified by <span>$\left(r, i, j, k\right)$</span> as the tuple <code>(dxr, dyr, dzr)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.get_physical_position" href="#PinCFlow.MSGWaM.RayOperations.get_physical_position"><code>PinCFlow.MSGWaM.RayOperations.get_physical_position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_physical_position(
    rays::Rays,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{3, &lt;:AbstractFloat}</code></pre><p>Return the physical position of the ray volume specified by <span>$\left(r, i, j, k\right)$</span> as the tuple <code>(xr, yr, zr)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.get_spectral_extent" href="#PinCFlow.MSGWaM.RayOperations.get_spectral_extent"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_extent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_spectral_extent(
    rays::Rays,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{3, &lt;:AbstractFloat}</code></pre><p>Return the spectral extents of the ray volume specified by <span>$\left(r, i, j, k\right)$</span> as the tuple <code>(dkr, dlr, dmr)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.get_spectral_position" href="#PinCFlow.MSGWaM.RayOperations.get_spectral_position"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_spectral_position(
    rays::Rays,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{3, &lt;:AbstractFloat}</code></pre><p>Return the spectral position of the ray volume specified by <span>$\left(r, i, j, k\right)$</span> as the tuple <code>(kr, lr, mr)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.get_surfaces" href="#PinCFlow.MSGWaM.RayOperations.get_surfaces"><code>PinCFlow.MSGWaM.RayOperations.get_surfaces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_surfaces(
    rays::Rays,
    r::Integer,
    i::Integer,
    j::Integer,
    k::Integer,
)::NTuple{3, &lt;:AbstractFloat}</code></pre><p>Compute phase-space surface areas of the ray volume specified by <span>$\left(r, i, j, k\right)$</span> and return them as the tuple <code>(axk, ayl, azm)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rays</code>: Collection of ray-volume-property arrays.</p></li><li><p><code>r</code>: Ray-volume index.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.remove_rays!" href="#PinCFlow.MSGWaM.RayOperations.remove_rays!"><code>PinCFlow.MSGWaM.RayOperations.remove_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_rays!(state::State)</code></pre><p>Remove gaps (i.e. zero-wave-action ray volumes between nonzero-wave-action ray volumes) in the ray-volume arrays.</p><p>In each grid cell, this method moves all ray volumes as far to the front of the arrays possible and updates <code>nray</code> accordingly, so that every ray volume in the range <code>1:nray[i, j, k]</code> has nonzero wave action.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayOperations.update_merged_rays!" href="#PinCFlow.MSGWaM.RayOperations.update_merged_rays!"><code>PinCFlow.MSGWaM.RayOperations.update_merged_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_merged_rays!(
    merge_mode::AbstractMergeMode,
    merged_rays::MergedRays,
    bin::Integer,
    xr::AbstractFloat,
    dxr::AbstractFloat,
    yr::AbstractFloat,
    dyr::AbstractFloat,
    zr::AbstractFloat,
    dzr::AbstractFloat,
    kr::AbstractFloat,
    dkr::AbstractFloat,
    lr::AbstractFloat,
    dlr::AbstractFloat,
    mr::AbstractFloat,
    dmr::AbstractFloat,
    fxk::AbstractFloat,
    fyl::AbstractFloat,
    fzm::AbstractFloat,
    nr::AbstractFloat,
    omegar::AbstractFloat,
)</code></pre><p>Update the fields of <code>merged_rays</code> at <code>bin</code> such that they contain the outermost bounds and total wave action/energy of all contributing ray volumes.</p><p>This method is used to compute the properties of merged ray volumes. It is called for every old ray volume that contributes to the new, merged volume and updates the outermost bounds in physical and spectral space, as well as the total wave action/energy, accordingly.</p><p><strong>Arguments</strong></p><ul><li><p><code>merge_mode</code>: Merging strategy.</p></li><li><p><code>merged_rays</code>: Properties of merged ray volumes.</p></li><li><p><code>bin</code>: Index of the bin to update.</p></li><li><p><code>xr</code>: Position of the old ray volume in <span>$x$</span>.</p></li><li><p><code>dxr</code>: Extent of the old ray volume in <span>$x$</span>.</p></li><li><p><code>yr</code>: Position of the old ray volume in <span>$y$</span>.</p></li><li><p><code>dyr</code>: Extent of the old ray volume in <span>$y$</span>.</p></li><li><p><code>zr</code>: Position of the old ray volume in <span>$z$</span>.</p></li><li><p><code>dzr</code>: Extent of the old ray volume in <span>$z$</span>.</p></li><li><p><code>kr</code>: Position of the old ray volume in <span>$k$</span>.</p></li><li><p><code>dkr</code>: Extent of the old ray volume in <span>$k$</span>.</p></li><li><p><code>lr</code>: Position of the old ray volume in <span>$l$</span>.</p></li><li><p><code>dlr</code>: Extent of the old ray volume in <span>$k$</span>.</p></li><li><p><code>mr</code>: Position of the old ray volume in <span>$m$</span>.</p></li><li><p><code>dmr</code>: Extent of the old ray volume in <span>$m$</span>.</p></li><li><p><code>fxk</code>: Phase-space factor of the old ray volume in <span>$x$</span>-<span>$k$</span> subspace.</p></li><li><p><code>fyl</code>: Phase-space factor of the old ray volume in <span>$y$</span>-<span>$l$</span> subspace.</p></li><li><p><code>fzm</code>: Phase-space factor of the old ray volume in <span>$z$</span>-<span>$m$</span> subspace.</p></li><li><p><code>nr</code>: Phase-space wave-action density of the old ray volume.</p></li><li><p><code>omegar</code>: Intrinsic frequency of the old ray volume.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral"><code>PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral</code></a></li></ul></div></section></article><h2 id="RaySources"><a class="docs-heading-anchor" href="#RaySources">RaySources</a><a id="RaySources-1"></a><a class="docs-heading-anchor-permalink" href="#RaySources" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RaySources" href="#PinCFlow.MSGWaM.RaySources"><code>PinCFlow.MSGWaM.RaySources</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RaySources</code></pre><p>Module for ray-volume sources.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations"><code>PinCFlow.MSGWaM.RayOperations</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RaySources.activate_orographic_source!" href="#PinCFlow.MSGWaM.RaySources.activate_orographic_source!"><code>PinCFlow.MSGWaM.RaySources.activate_orographic_source!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">activate_orographic_source!(
    state::State,
    omi_ini::AbstractArray{&lt;:AbstractFloat, 4},
    wnk_ini::AbstractArray{&lt;:AbstractFloat, 4},
    wnl_ini::AbstractArray{&lt;:AbstractFloat, 4},
    wnm_ini::AbstractArray{&lt;:AbstractFloat, 4},
    wad_ini::AbstractArray{&lt;:AbstractFloat, 4},
)</code></pre><p>Compute ray-volume properties in the launch layer (i.e. at <code>k = k0 - 1</code>) for the initialization of MS-GWaM.</p><p>Sets the launch-layer values of arrays for initial ray-volume properties (intrinsic frequencies, wavenumbers and wave-action densities). For this purpose, the horizontal components of the resolved wind, the background density and the squared buoyancy frequency are vertically averaged between the surface and an approximation for the summits of the unresolved orography. The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking is inferred (see below). Afterwards, the ray-volume properties are obtained by calling <code>compute_orographic_mode</code> with the correspondingly scaled mode of the orographic spectrum and the vertical averages as arguments.</p><pre><code class="language-julia hljs">activate_orographic_source!(state::State)</code></pre><p>Launch ray volumes that represent unresolved orographic gravity waves.</p><p>In each column of MPI processes at the lower boundary, this method first computes vertical averages of the horizontal components of the resolved wind, the background density and the squared buoyancy frequency between <span>$h_\mathrm{b}$</span> (the surface) and <span>$h_\mathrm{b} + \Delta h$</span> (an approximation for the summits of the unresolved orography, with <span>$\Delta h = \sum_\alpha \left|h_{\mathrm{w}, \alpha}\right|$</span>). The vertical averages are then used to compute a non-dimensionalized mountain wave amplitude, from which an approximate reduction of the generated wave amplitude due to blocking, as well as the depth of the blocked layer, is inferred. A loop over the spectral modes of the unresolved orography follows, in which the properties of each mode are computed, using <code>compute_orographic_mode</code> with the scaled mode of the orographic spectrum and vertical averages as arguments, and corresponding ray volumes are launched at <code>k = k0 - 1</code>.</p><p>The parameterization of blocking is built around the non-dimensionalized mountain wave amplitude, or Long number,</p><p class="math-container">\[\mathrm{Lo} = \frac{N_h \Delta h}{\left|\boldsymbol{u}_h\right|},\]</p><p>where <span>$N_h$</span> is the square root of the vertically averaged squared buoyancy frequency and <span>$\boldsymbol{u}_h$</span> is the vertically averaged resolved horizontal wind. This number is used to estimate the depth of the blocked layer as</p><p class="math-container">\[\Delta z_\mathrm{B} = 2 \Delta h \max \left(0, \frac{\mathrm{Lo} - C}{\mathrm{Lo}}\right),\]</p><p>where <span>$C$</span> is a critical value represented by the model parameter <code>state.namelists.wkb.long_threshold</code>. The corresponding scaling of the orographic spectrum is given by</p><p class="math-container">\[r \left(\mathrm{Lo}\right) = \frac{2 \Delta h - \Delta z_\mathrm{B}}{2 \Delta h} = \min \left(1, \frac{C}{\mathrm{Lo}}\right),\]</p><p>so that <span>$\Delta z_\mathrm{B} = 2 \Delta h \left(1 - r\right)$</span>. In addition to the reduction of the mountain-wave amplitude, the present blocked-layer scheme adds a blocked-flow drag to the mean-flow impact. This is implemented in <a href="#PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!"><code>PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!</code></a>.</p><p>The launch algorithm distinguishes between the following situations (regarding previously launched ray volumes).</p><ol><li><p>There is no ray volume with nonzero wave-action density. A new ray volume is launched.</p></li><li><p>There is a ray volume with nonzero wave-action density that has at least partially passed through the lower boundary. The ray volume is either clipped or extended, such that its lower edge coincides with the surface, and the part below the surface is discarded. Then, it is assigned to the first model layer <code>k0</code>, i.e. its indices are changed from <code>(r, i, j, k0 - 1)</code> to <code>(rray, i, j, k0)</code>, where <code>rray</code> is the new last ray-volume index at <code>(i, j, k0)</code>. Finally, a new ray volume is launched.</p></li><li><p>There is a ray volume with nonzero wave-action density, which has not yet crossed the lower boundary. It is replaced with a new one.</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>omi_ini</code>: Array for intrinsic frequencies.</p></li><li><p><code>wnk_ini</code>: Array for zonal wavenumbers.</p></li><li><p><code>wnl_ini</code>: Array for meridional wavenumbers.</p></li><li><p><code>wnm_ini</code>: Array for vertical wavenumbers.</p></li><li><p><code>wad_ini</code>: Array for wave-action densities.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RaySources.compute_orographic_mode"><code>PinCFlow.MSGWaM.RaySources.compute_orographic_mode</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RaySources.compute_orographic_mode" href="#PinCFlow.MSGWaM.RaySources.compute_orographic_mode"><code>PinCFlow.MSGWaM.RaySources.compute_orographic_mode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_orographic_mode(
    displm::AbstractFloat,
    wnk::AbstractFloat,
    wnl::AbstractFloat,
    uavg::AbstractFloat,
    vavg::AbstractFloat,
    rhoavg::AbstractFloat,
    bvsavg::AbstractFloat,
    fc::AbstractFloat,
    branch::Integer,
)::NTuple{5, &lt;:AbstractFloat}</code></pre><p>Compute and return the properties of an orographic-gravity-wave mode.</p><p>Calculates the intrinsic frequency, wavenumbers and wave-action density of a gravity-wave mode generated by flow over topography, using linear mountain-wave theory. The implemented formulas are as follows (where this method&#39;s arguments are represented by <span>$h_{\mathrm{w}, \alpha}$</span>, <span>$k_{h, \alpha}$</span>, <span>$l_{h, \alpha}$</span>, <span>$u_h$</span>, <span>$v_h$</span>, <span>$\overline{\rho}_h$</span>, <span>$N_h^2$</span>, <span>$f$</span> and <span>$\sigma$</span>).</p><ul><li><p>Intrinsic frequency:</p><p class="math-container">\[\widehat{\omega}_\alpha = \sigma \left|- k_{h, \alpha} u_h - l_{h, \alpha} v_h\right|\]</p></li><li><p>Horizontal wavenumbers:</p><p class="math-container">\[\begin{align*}
    k_\alpha &amp; = \sigma \mathrm{sgn} \left(- k_{h, \alpha} u_h - l_{h, \alpha} v_h\right) k_{h, \alpha},\\
    l_\alpha &amp; = \sigma \mathrm{sgn} \left(- k_{h, \alpha} u_h - l_{h, \alpha} v_h\right) l_{h, \alpha}
\end{align*}\]</p></li><li><p>Vertical wavenumber:</p><p class="math-container">\[m_\alpha = - \sigma \sqrt{\frac{\left(k_\alpha^2 + l_\alpha^2\right) \left(N_h^2 - \widehat{\omega}_\alpha^2\right)}{\widehat{\omega}_\alpha^2 - f^2}}\]</p></li><li><p>Wave-action density:</p><p class="math-container">\[\mathcal{A}_\alpha = \frac{\overline{\rho}_h}{2} \frac{\widehat{\omega}_\alpha \left|\boldsymbol{k}_\alpha\right|^2}{k_\alpha^2 + l_\alpha^2} \left|h_{\mathrm{w}, \alpha}\right|^2\]</p></li></ul><p>If the squared intrinsic frequency is smaller than the squared Coriolis parameter or larger than the squared buoyancy frequency (and thus outside of the gravity-wave spectrum), the vertical wavenumber and wave-action density are set to zero.</p><p><strong>Arguments</strong></p><ul><li><p><code>displm</code>: Topographic displacement.</p></li><li><p><code>wnk</code>: Zonal wavenumber from the topographic spectrum.</p></li><li><p><code>wnl</code>: Meridional wavenumber from the topographic spectrum.</p></li><li><p><code>uavg</code>: Vertically averaged resolved zonal wind.</p></li><li><p><code>vavg</code>: Vertically averaged resolved meridional wind.</p></li><li><p><code>rhoavg</code>: Vertically averaged background density.</p></li><li><p><code>bvsavg</code>: Vertically averaged squared buoyancy frequency.</p></li><li><p><code>fc</code>: Coriolis parameter.</p></li><li><p><code>branch</code>: Frequency branch.</p></li></ul></div></section></article><h2 id="BoundaryRays"><a class="docs-heading-anchor" href="#BoundaryRays">BoundaryRays</a><a id="BoundaryRays-1"></a><a class="docs-heading-anchor-permalink" href="#BoundaryRays" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays" href="#PinCFlow.MSGWaM.BoundaryRays"><code>PinCFlow.MSGWaM.BoundaryRays</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryRays</code></pre><p>Module for enforcing boundary conditions for ray volumes.</p><p>Provides functions for configurations that are serial or parallel in any dimension of physical space. Assumes periodicity in the horizontal and solid-wall boundaries in the vertical.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="../mpi_operations/#PinCFlow.MPIOperations"><code>PinCFlow.MPIOperations</code></a></p></li><li><p><a href="../boundaries/#PinCFlow.Boundaries"><code>PinCFlow.Boundaries</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations"><code>PinCFlow.MSGWaM.RayOperations</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_boundary_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_boundary_rays!(state::State)</code></pre><p>Enforce boundary conditions for ray volumes by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">set_boundary_rays!(state::State, wkb_mode::NoWKB)</code></pre><p>Return for non-WKB configurations.</p><pre><code class="language-julia hljs">set_boundary_rays!(state::State, wkb_mode::SteadyState)</code></pre><p>Enforce horizontal boundary conditions for &quot;ray volumes&quot; in steady-state mode.</p><p>Zonal (meridional) boundary conditions are only enforced if <code>state.namelists.domain.x_size &gt; 1</code> (<code>state.namelists.domain.y_size &gt; 1</code>).</p><pre><code class="language-julia hljs">set_boundary_rays!(state::State, wkb_mode::Union{SingleColumn, MultiColumn})</code></pre><p>Enforce horizontal and vertical boundary conditions for ray volumes in single-column or multi-column mode.</p><p>Zonal (meridional) boundary conditions are only enforced if <code>state.namelists.domain.x_size &gt; 1</code> (<code>state.namelists.domain.y_size &gt; 1</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_meridional_boundary_rays!(state::State)</code></pre><p>Set the ray volumes at the meridional boundaries.</p><p>This method first enforces meridional boundary conditions for <code>state.wkb.nray</code> (by applying <code>set_meridional_boundaries_of_field!</code> to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in <span>$\widehat{y}$</span>, ray volumes are communicated between MPI processes, using <code>set_meridional_halo_rays!</code>. At the meridional boundaries of the domain, the <span>$y$</span>-coordinates of ray volumes are adjusted such that shifting works properly.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul><p><strong>See also</strong></p><ul><li><p><a href="../boundaries/#PinCFlow.Boundaries.set_meridional_boundaries_of_field!"><code>PinCFlow.Boundaries.set_meridional_boundaries_of_field!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_meridional_halo_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_meridional_halo_rays!(state::State)</code></pre><p>Exchange ray volumes in meridional halo cells.</p><p>Performs bidirectional MPI communication between backward and forward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the backward and forward boundaries of the MPI subdomains.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_vertical_boundary_rays!(state::State)</code></pre><p>Enforce vertical boundary conditions for ray volumes.</p><p>If the domain is parallelized in <span>$\widehat{z}$</span>, ray-volume counts and the ray volumes themselves are first communicated between MPI processes, using <code>set_vertical_halos_of_field!</code> and <code>set_vertical_halo_rays!</code>, respectively. The vertical boundary conditions are then enforced by cutting (removing) ray volumes that have partially (fully) crossed the upper boundary and reflecting ray volumes (by adjusting the vertical position and wavenumber) that have at least partially crossed the lower boundary from above.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul><p><strong>See also</strong></p><ul><li><p><a href="../mpi_operations/#PinCFlow.MPIOperations.set_vertical_halos_of_field!"><code>PinCFlow.MPIOperations.set_vertical_halos_of_field!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_vertical_halo_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_vertical_halo_rays!(state::State)</code></pre><p>Exchange ray volumes in vertical halo cells.</p><p>Performs MPI communication between downward and upward neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the downward and upward boundaries of the MPI subdomains. Solid walls are assumed at the vertical boundaries of the full domain. The corresponding ghost-cell ray volumes are not changed.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_zonal_boundary_rays!(state::State)</code></pre><p>Set the ray volumes at the zonal boundaries.</p><p>This method first enforces zonal boundary conditions for <code>state.wkb.nray</code> (by applying <code>set_zonal_boundaries_of_field!</code> to it) and then sets the corresponding boundary ray volumes, assuming periodicity. If the domain is parallelized in <span>$\widehat{x}$</span>, ray volumes are communicated between MPI processes, using <code>set_zonal_halo_rays!</code>. At the zonal boundaries of the domain, the <span>$x$</span>-coordinates of ray volumes are adjusted such that shifting works properly.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul><p><strong>See also</strong></p><ul><li><p><a href="../boundaries/#PinCFlow.Boundaries.set_zonal_boundaries_of_field!"><code>PinCFlow.Boundaries.set_zonal_boundaries_of_field!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!" href="#PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_zonal_halo_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_zonal_halo_rays!(state::State)</code></pre><p>Exchange ray volumes in zonal halo cells.</p><p>Performs bidirectional MPI communication between left and right neighbor processes. The number of communicated ray volumes is determined from the maximum counts at the left and right boundaries of the MPI subdomains.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul></div></section></article><h2 id="RayUpdate"><a class="docs-heading-anchor" href="#RayUpdate">RayUpdate</a><a id="RayUpdate-1"></a><a class="docs-heading-anchor-permalink" href="#RayUpdate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate" href="#PinCFlow.MSGWaM.RayUpdate"><code>PinCFlow.MSGWaM.RayUpdate</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RayUpdate</code></pre><p>Module for the integration of the ray equations.</p><p>In addition to ray-volume initialization and propagation, functions for tracking ray volumes on the model grid and controlling their count, as well as a saturation scheme for capturing wave breaking, are provided.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays"><code>PinCFlow.MSGWaM.BoundaryRays</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation"><code>PinCFlow.MSGWaM.Interpolation</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations"><code>PinCFlow.MSGWaM.RayOperations</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RaySources"><code>PinCFlow.MSGWaM.RaySources</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.X" href="#PinCFlow.MSGWaM.RayUpdate.X"><code>PinCFlow.MSGWaM.RayUpdate.X</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X</code></pre><p>Singleton for dispatch to operations in <span>$x$</span>-direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.XYZ" href="#PinCFlow.MSGWaM.RayUpdate.XYZ"><code>PinCFlow.MSGWaM.RayUpdate.XYZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XYZ</code></pre><p>Singleton for dispatch to operations in all directions.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.XZ" href="#PinCFlow.MSGWaM.RayUpdate.XZ"><code>PinCFlow.MSGWaM.RayUpdate.XZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XZ</code></pre><p>Singleton for dispatch to operations in <span>$x$</span>- and <span>$z$</span>-direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.Y" href="#PinCFlow.MSGWaM.RayUpdate.Y"><code>PinCFlow.MSGWaM.RayUpdate.Y</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Y</code></pre><p>Singleton for dispatch to operations in <span>$y$</span>-direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.YZ" href="#PinCFlow.MSGWaM.RayUpdate.YZ"><code>PinCFlow.MSGWaM.RayUpdate.YZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YZ</code></pre><p>Singleton for dispatch to operations in <span>$y$</span>- and <span>$z$</span>-direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.Z" href="#PinCFlow.MSGWaM.RayUpdate.Z"><code>PinCFlow.MSGWaM.RayUpdate.Z</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Z</code></pre><p>Singleton for dispatch to operations in <span>$z$</span>-direction.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!" href="#PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!"><code>PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_saturation_scheme!(state::State, dt::AbstractFloat)</code></pre><p>Apply the saturation scheme by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">apply_saturation_scheme!(
    state::State,
    dt::AbstractFloat,
    wkb_mode::Union{NoWKB, SteadyState},
)</code></pre><p>Return for configurations without WKB / with steady-state WKB.</p><p>In steady-state mode, saturation is handled by <a href="#PinCFlow.MSGWaM.RayUpdate.propagate_rays!"><code>PinCFlow.MSGWaM.RayUpdate.propagate_rays!</code></a>.</p><pre><code class="language-julia hljs">apply_saturation_scheme!(
    state::State,
    dt::AbstractFloat,
    wkb_mode::Union{SingleColumn, MultiColumn},
)</code></pre><p>Apply the saturation scheme.</p><p>Saturation is assumed to occur when the static-instability criterion</p><p class="math-container">\[\sum\limits_r \left(m_r \left|b_{\mathrm{w}, r}\right|\right)^2 f_r \geq \alpha_\mathrm{s}^2 N^4\]</p><p>is locally fulfilled (i.e. within a grid cell). Therein, <span>$\left|b_{\mathrm{w}, r}\right|^2$</span> is the squared gravity-wave amplitude of the buoyancy, <span>$f_r$</span> is the maximum grid-cell fraction each ray volume can cover and <span>$\alpha_\mathrm{s}$</span> is a saturation coefficient that represents the uncertainties of the criterion. The phase-space wave-action density is then reduced in accordance with</p><p class="math-container">\[\frac{\Delta \left|b_{\mathrm{w}, r}\right|^2}{\Delta t} = - 2 K \left|\boldsymbol{k}_r\right|^2 \left|b_{\mathrm{w}, r}\right|^2,\]</p><p>which is based on the assumption that wave breaking leads to turbulent fluxes that may be parameterized with a flux-gradient ansatz. The turbulent viscosity and diffusivity</p><p class="math-container">\[K = \left[2 \Delta t\sum\limits_r \left(m_r \left|b_{\mathrm{w}, r}\right| \left|\boldsymbol{k}_r\right|\right)^2 f_r\right]^{- 1} \max \left[0, \sum_r \left(m_r \left|b_{\mathrm{w}, r}\right|\right)^2 f_r - \alpha_\mathrm{s}^2 N^4\right]\]</p><p>is such that wave action is reduced exactly to the saturation threshold. The two sums involved in this scheme (discretizations of spectral integrals) are computed with <code>compute_spectral_integrals</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>dt</code>: Time step.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals"><code>PinCFlow.MSGWaM.RayOperations.compute_saturation_integrals</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.remove_rays!"><code>PinCFlow.MSGWaM.RayOperations.remove_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.initialize_rays!" href="#PinCFlow.MSGWaM.RayUpdate.initialize_rays!"><code>PinCFlow.MSGWaM.RayUpdate.initialize_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_rays!(state::State)</code></pre><p>Complete the initialization of MS-GWaM by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">initialize_rays!(state::State, wkb_mode::NoWKB)</code></pre><p>Return for non-WKB configurations.</p><pre><code class="language-julia hljs">initialize_rays!(
    state::State,
    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},
)</code></pre><p>Complete the initialization of MS-GWaM.</p><p>In each grid cell, <code>wave_modes</code> wave modes are computed, using <code>state.namelists.wkb.initial_wave_field</code>, as well as <code>activate_orographic_source!</code> for mountain waves. For each of these modes, <code>nrx * nry * nrz * nrk * nrl * nrm</code> ray volumes are then defined such that they evenly divide the volume one would get for <code>nrx = nry = nrz = nrk = nrl = nrm = 1</code> (the parameters are taken from <code>state.namelists.wkb</code>). Finally, the maximum group velocities are determined for the corresponding CFL condition that is used in the computation of the time step.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RaySources.activate_orographic_source!"><code>PinCFlow.MSGWaM.RaySources.activate_orographic_source!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow"><code>PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.merge_rays!" href="#PinCFlow.MSGWaM.RayUpdate.merge_rays!"><code>PinCFlow.MSGWaM.RayUpdate.merge_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_rays!(state::State)</code></pre><p>Merge ray volumes by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">merge_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})</code></pre><p>Return for configurations without WKB / with steady-state WKB.</p><pre><code class="language-julia hljs">merge_rays!(state::State, wkb_mode::Union{SingleColumn, MultiColumn})</code></pre><p>Merge ray volumes in grid cells in which their count exceeds a threshold.</p><p>This method checks in each grid cell if the number of ray volumes exceeds a maximum that was determined from namelist parameters (<code>state.wkb.nray_max</code>). If it does, the ray volumes in that cell are merged such that the new count is smaller or equal to the threshold. This is done by binning them on a spectral grid with logarithmic spacing, defined from the minima and maxima of the contributing negative and positive wavenumbers in all spectral dimensions. The merging is performed such that the bounds of the new ray volumes coincide with the outermost bounds of the old ray volumes and wave action (or wave energy, depending on the merging strategy) is conserved.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds"><code>PinCFlow.MSGWaM.RayOperations.compute_spectral_bounds</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_physical_position"><code>PinCFlow.MSGWaM.RayOperations.get_physical_position</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_spectral_position"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_position</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_physical_extent"><code>PinCFlow.MSGWaM.RayOperations.get_physical_extent</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_spectral_extent"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_extent</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_surfaces"><code>PinCFlow.MSGWaM.RayOperations.get_surfaces</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency"><code>PinCFlow.MSGWaM.RayOperations.compute_intrinsic_frequency</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_merge_index"><code>PinCFlow.MSGWaM.RayOperations.compute_merge_index</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.update_merged_rays!"><code>PinCFlow.MSGWaM.RayOperations.update_merged_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral"><code>PinCFlow.MSGWaM.RayOperations.compute_wave_action_integral</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.propagate_rays!" href="#PinCFlow.MSGWaM.RayUpdate.propagate_rays!"><code>PinCFlow.MSGWaM.RayUpdate.propagate_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagate_rays!(state::State, dt::AbstractFloat, rkstage::Integer)</code></pre><p>Integrate the wave-action-density and ray equations by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">propagate_rays!(
    state::State,
    dt::AbstractFloat,
    rkstage::Integer,
    wkb_mode::NoWKB,
)</code></pre><p>Return for non-WKB configurations.</p><pre><code class="language-julia hljs">propagate_rays!(
    state::State,
    dt::AbstractFloat,
    rkstage::Integer,
    wkb_mode::Union{SingleColumn, MultiColumn},
)</code></pre><p>Integrate the wave-action-density and ray equations derived from 1D or 3D transient WKB theory.</p><p>The updates of the RK tendencies for the phase-space position of each ray volume are given by</p><p class="math-container">\[\begin{align*}
    q_r^x &amp; \rightarrow \Delta t \left(u_{\mathrm{b}, r} + k_r \frac{N_r^2 - \widehat{\omega}_r^2}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2}\right) + \alpha_\mathrm{RK} q_r^x,\\
    q_r^y &amp; \rightarrow \Delta t \left(v_{\mathrm{b}, r} + l_r \frac{N_r^2 - \widehat{\omega}_r^2}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2}\right) + \alpha_\mathrm{RK} q_r^y,\\
    q_r^z &amp; \rightarrow - \Delta t \frac{m_r \left(\widehat{\omega}_r^2 - f^2\right)}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2} + \alpha_\mathrm{RK} q_r^z,\\
    q_r^k &amp; \rightarrow - \Delta t \left[k_r \left(\frac{\partial u_\mathrm{b}}{\partial x}\right)_r - l_r \left(\frac{\partial v_\mathrm{b}}{\partial x}\right)_r\right] + \alpha_\mathrm{RK} q_r^k,\\
    q_r^l &amp; \rightarrow - \Delta t \left[k_r \left(\frac{\partial u_\mathrm{b}}{\partial y}\right)_r - l_r \left(\frac{\partial v_\mathrm{b}}{\partial y}\right)_r\right] + \alpha_\mathrm{RK} q_r^l,\\
    q_r^m &amp; \rightarrow - \Delta t \left[k_r \left(\frac{\partial u_\mathrm{b}}{\partial z}\right)_r - l_r \left(\frac{\partial v_\mathrm{b}}{\partial z}\right)_r - \frac{k_r^2 + l_r^2}{2 \widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2} \left(\frac{\partial N^2}{\partial z}\right)_r\right] + \alpha_\mathrm{RK} q_r^m
\end{align*}\]</p><p>and the position update is</p><p class="math-container">\[\begin{align*}
    x_r &amp; = x_r + \beta_\mathrm{RK} q_r^x, &amp; y_r &amp; \rightarrow y_r + \beta_\mathrm{RK} q_r^y, &amp; z_r &amp; \rightarrow z_r + \beta_\mathrm{RK} q_r^z,\\
    k_r &amp; \rightarrow k_r + \beta_\mathrm{RK} q_r^k, &amp; l_r &amp; \rightarrow l_r + \beta_\mathrm{RK} q_r^l, &amp; m_r &amp; \rightarrow m_r + \beta_\mathrm{RK} q_r^m,
\end{align*}\]</p><p>where the subscript <span>$r$</span> indicates either a ray-volume property or a mean-flow property interpolated to the ray-volume position, via <code>interpolate_mean_flow</code> and <code>interpolate_stratification</code>. In addition, MS-GWaM updates the ray-volume extents, following</p><p class="math-container">\[\begin{align*}
    q_r^{\Delta x} &amp; \rightarrow \Delta t \left(u_{\mathrm{b}, r, +} - u_{\mathrm{b}, r, -}\right) + \alpha_\mathrm{RK} q_r^{\Delta x}, &amp; \Delta x_r &amp; \rightarrow \Delta x_r + \beta_\mathrm{RK} q_r^{\Delta x},\\
    q_r^{\Delta y} &amp; \rightarrow \Delta t \left(v_{\mathrm{b}, r, +} - v_{\mathrm{b}, r, -}\right) + \alpha_\mathrm{RK} q_r^{\Delta y}, &amp; \Delta y_r &amp; \rightarrow \Delta y_r + \beta_\mathrm{RK} q_r^{\Delta y},\\
    q_r^{\Delta z} &amp; \rightarrow \Delta t \left(c_{\mathrm{g} z, r, +} - c_{\mathrm{g} z, r, -}\right) + \alpha_\mathrm{RK} q_r^{\Delta z}, &amp; \Delta z_r &amp; \rightarrow \Delta z_r + \beta_\mathrm{RK} q_r^{\Delta z},
\end{align*}\]</p><p>where <span>$u_{\mathrm{b}, r, \pm}$</span> is the interpolation of <span>$u_\mathrm{b}$</span> to <span>$x_{r, \pm} = x_r \pm \Delta x_r / 2$</span> (from before the position update) and <span>$v_{\mathrm{b}, r, \pm}$</span> is the equivalent for <span>$v_\mathrm{b}$</span> in <span>$y$</span>-direction. In the computation of <span>$c_{\mathrm{g} z, r, \pm}$</span>, the intrinsic frequency and squared buoyancy frequency are interpolated to <span>$z_{r, \pm} = z_r \pm \Delta z_r / 2$</span> (also from before the position update). The update of the spectral ray-volume extents uses the fact that the surfaces in the <span>$x$</span>-<span>$k$</span>, <span>$y$</span>-<span>$l$</span> and <span>$z$</span>-<span>$m$</span> subspaces are conserved. Finally, the update of the phase-space wave-action density reads</p><p class="math-container">\[\mathcal{N}_r \rightarrow \left(1 + 2 \alpha_{\mathrm{R}, r} f_\mathrm{RK} \Delta t\right)^{- 1} \mathcal{N}_r,\]</p><p>where <span>$\alpha_{\mathrm{R}, r}$</span> is the interpolation of the Rayleigh-damping coefficient to the updated ray-volume position, obtained from <code>interpolate_sponge</code>.</p><p>The group velocities that are calculated for the propagation in physical space are also used to determine the maxima needed for the WKB-CFL condition used in the time-step computation.</p><pre><code class="language-julia hljs">propagate_rays!(
    state::State,
    dt::AbstractFloat,
    rkstage::Integer,
    wkb_mode::SteadyState,
)</code></pre><p>Update the vertical wavenumber and wave-action density, using steady-state WKB theory.</p><p>In steady-state mode, the ray volumes are stationary in physical space. In mountain-wave simulations, this method first updates the ray volumes in the launch layer by calling <code>activate_orographic_source!</code>. Subsequently, it performs a vertical sweep to update all other ray volumes. Therein, the vertical wavenumber is set to</p><p class="math-container">\[m_r = - \sigma \sqrt{\frac{\left(k_r^2 + l_r^2\right) \left(N_r^2 - \widehat{\omega}_r^2\right)}{\widehat{\omega}_r^2 - f^2}},\]</p><p>where <span>$N_r^2$</span> is the squared buoyancy frequency interpolated to the ray-volume position (with <code>interpolate_stratification</code>) and <span>$\widehat{\omega}_r = - k_r u_\mathrm{b} - l_r v_\mathrm{b}$</span> (in the case of mountain waves, for which <span>$\omega_r = 0$</span>). The new wave-action-density field is obtained by integrating</p><p class="math-container">\[\frac{\partial}{\partial z} \left(c_{\mathrm{g} z, r} \mathcal{A}_r\right) = - 2 \alpha_{\mathrm{R}, r} \mathcal{A}_r - 2 K \left|\boldsymbol{k}_r\right|^2 \mathcal{A}_r,\]</p><p>where <span>$\alpha_{\mathrm{R}, r}$</span> is the Rayleigh-damping coefficient interpolated to the ray-volume position (using <code>interpolate_sponge</code>) and</p><p class="math-container">\[K = \left[2 \sum\limits_r \frac{J \Delta \widehat{z}}{c_{\mathrm{g}, z, r}} \left(m_r \left|b_{\mathrm{w}, r}\right| \left|\boldsymbol{k}_r\right|\right)^2 f_r\right]^{- 1} \max \left[0, \sum_r \left(m_r \left|b_{\mathrm{w}, r}\right|\right)^2 f_r - \alpha_\mathrm{s}^2 N^4\right]\]</p><p>is the turbulent viscosity and diffusivity due to wave breaking (see <a href="#PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!"><code>PinCFlow.MSGWaM.RayUpdate.apply_saturation_scheme!</code></a> for more details). After the first right-hand-side term has been integrated with the implicit step</p><p class="math-container">\[\mathcal{A}_r = \left[1 + \frac{2 \alpha_{\mathrm{R}, r}}{c_{\mathrm{g} z, r}} \left(z_r - z_{r, k - 1}\right)\right]^{- 1} \frac{c_{\mathrm{g} z, r, k - 1}}{c_{\mathrm{g} z, r}} \mathcal{A}_{r, k - 1},\]</p><p>the second term is integrated with the pseudo-time step <span>$J \Delta \widehat{z} / c_{\mathrm{g} z, r}$</span>, which corresponds to the substitution <span>$\mathcal{A}_r \rightarrow \left(1 - 2 J \Delta \widehat{z} / c_{\mathrm{g} z, r} K \left|\boldsymbol{k}_r\right|^2\right) \mathcal{A}_r$</span>.</p><p>If the domain is parallelized in the vertical, the integration in vertical subdomains is performed sequentially, with one-way communication providing boundary conditions.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>dt</code>: Time step.</p></li><li><p><code>rkstage</code>: Runge-Kutta-stage index.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_physical_position"><code>PinCFlow.MSGWaM.RayOperations.get_physical_position</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_spectral_position"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_position</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_physical_extent"><code>PinCFlow.MSGWaM.RayOperations.get_physical_extent</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.get_spectral_extent"><code>PinCFlow.MSGWaM.RayOperations.get_spectral_extent</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow"><code>PinCFlow.MSGWaM.Interpolation.interpolate_mean_flow</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_sponge"><code>PinCFlow.MSGWaM.Interpolation.interpolate_sponge</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RaySources.activate_orographic_source!"><code>PinCFlow.MSGWaM.RaySources.activate_orographic_source!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.shift_rays!" href="#PinCFlow.MSGWaM.RayUpdate.shift_rays!"><code>PinCFlow.MSGWaM.RayUpdate.shift_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shift_rays!(state::State)</code></pre><p>Shift the array positions of ray volumes such that they are attributed to the correct grid cells by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">shift_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})</code></pre><p>Return for configurations without WKB / with steady-state WKB.</p><pre><code class="language-julia hljs">shift_rays!(state::State, wkb_mode::SingleColumn)</code></pre><p>Shift the vertical array positions of ray volumes such that they are attributed to the correct grid cells.</p><p>This method enforces the vertical boundary conditions (via <code>set_vertical_boundary_rays!</code>), checks if ray volumes need to be shifted and, if they do, copies them to the correct grid cells and marks them for removal (by dispatching to the appropriate method). A second call of <code>set_vertical_boundary_rays!</code> ensures that ray volumes that have moved across MPI processes are included in the appropriate halo cells. Finally, the gaps that were created by marking ray volumes for removal are filled (via <code>remove_rays!</code>).</p><pre><code class="language-julia hljs">shift_rays!(state::State, wkb_mode::MultiColumn)</code></pre><p>Shift the array positions of ray volumes such that they are attributed to the correct grid cells.</p><p>For each dimension in physical space (with more than one grid point), this method performs the corresponding equivalent of the algorithm that is implemented in the method for single-column mode.</p><pre><code class="language-julia hljs">shift_rays!(state::State, direction::X)</code></pre><p>For each ray volume, check if it is attributed to the correct position in <span>$\widehat{x}$</span> and, if it is not, create a copy that is and mark the original for removal.</p><p>Ray volumes that should be attributed to a halo cell are marked for removal but not copied, since the copies are created from the corresponding halo cell in the adjacent MPI process.</p><pre><code class="language-julia hljs">shift_rays!(state::State, direction::Y)</code></pre><p>For each ray volume, check if it is attributed to the correct position in <span>$\widehat{y}$</span> and, if it is not, create a copy that is and mark the original for removal.</p><p>Ray volumes in halo cells are treated in the same way as in the method for shifting in <span>$\widehat{x}$</span>.</p><pre><code class="language-julia hljs">shift_rays!(state::State, direction::Z)</code></pre><p>For each ray volume, check if it is attributed to the correct position in <span>$\widehat{z}$</span> and, if it is not, create a copy that is and mark the original for removal.</p><p>Ray volumes in halo cells are treated in the same way as in the methods for shifting in <span>$\widehat{x}$</span> and <span>$\widehat{z}$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li><li><p><code>direction</code>: Shift direction.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_zonal_boundary_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_meridional_boundary_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!"><code>PinCFlow.MSGWaM.BoundaryRays.set_vertical_boundary_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.remove_rays!"><code>PinCFlow.MSGWaM.RayOperations.remove_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.check_rays"><code>PinCFlow.MSGWaM.RayOperations.check_rays</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.RayUpdate.split_rays!" href="#PinCFlow.MSGWaM.RayUpdate.split_rays!"><code>PinCFlow.MSGWaM.RayUpdate.split_rays!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_rays!(state::State)</code></pre><p>Split ray volumes that have become larger than the local grid cell by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">split_rays!(state::State, wkb_mode::Union{NoWKB, SteadyState})</code></pre><p>Return for configurations without WKB / with steady-state WKB.</p><pre><code class="language-julia hljs">split_rays!(state::State, wkb_mode::SingleColumn)</code></pre><p>Split ray volumes which have a vertical extent larger than the local vertical grid spacing.</p><pre><code class="language-julia hljs">split_rays!(state::State, wkb_mode::MultiColumn)</code></pre><p>In each dimension of physical space, split ray volumes which have an extent larger than the local grid spacing.</p><p>The splitting is performed sequentially, such that a ray volume with extents that are all between once and twice as large as allowed is split into exactly eight smaller ray volumes (all of which have the same size).</p><pre><code class="language-julia hljs">split_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::X)</code></pre><p>In the grid cell specified by <span>$\left(i, j, k\right)$</span>, split ray volumes with <span>$\Delta x_r &gt; \Delta \widehat{x}$</span>.</p><p>The number of splits is the result of ceiling division of <span>$\Delta x_r$</span> by <span>$\Delta \widehat{x}$</span>. Each split is carried out by adjusting the position and extent of the ray volume, copying it and changing the position of the copy appropriately.</p><pre><code class="language-julia hljs">split_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Y)</code></pre><p>In the grid cell specified by <span>$\left(i, j, k\right)$</span>, split ray volumes with <span>$\Delta y_r &gt; \Delta \widehat{y}$</span>.</p><p>The splitting is analogous to that in <span>$\widehat{x}$</span>.</p><pre><code class="language-julia hljs">split_rays!(i::Integer, j::Integer, k::Integer, state::State, axis::Z)</code></pre><p>In the grid cell specified by <span>$\left(i, j, k\right)$</span>, split ray volumes with <span>$\Delta z_r &gt; J_{\min} \Delta \widehat{z}$</span>, with <span>$J_{\min}$</span> being the minimum value of the Jacobian in all grid cells that are at least partially covered by the ray volume (at its true horizontal position on the grid).</p><p>The splitting is analogous to that in <span>$\widehat{x}$</span> and <span>$\widehat{y}$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li><li><p><code>i</code>: Grid-cell index in <span>$\widehat{x}$</span>-direction</p></li><li><p><code>j</code>: Grid-cell index in <span>$\widehat{y}$</span>-direction</p></li><li><p><code>k</code>: Grid-cell index in <span>$\widehat{z}$</span>-direction</p></li><li><p><code>axis</code>: Axis perpendicular to the split.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.RayOperations.copy_rays!"><code>PinCFlow.MSGWaM.RayOperations.copy_rays!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li></ul></div></section></article><h2 id="MeanFlowEffect"><a class="docs-heading-anchor" href="#MeanFlowEffect">MeanFlowEffect</a><a id="MeanFlowEffect-1"></a><a class="docs-heading-anchor-permalink" href="#MeanFlowEffect" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect" href="#PinCFlow.MSGWaM.MeanFlowEffect"><code>PinCFlow.MSGWaM.MeanFlowEffect</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeanFlowEffect</code></pre><p>Module for computing the mean-flow effect of gravity waves.</p><p>Provides functions that compute mean-flow tendencies by integrating ray-volume properties in spectral space and mapping the result to physical grid cells. Also provides two filters for smoothing the tendencies, as well as a simple blocked-layer scheme that includes a blocked-flow drag in mountain-wave simulations.</p><p><strong>See also</strong></p><ul><li><p><a href="../types/#PinCFlow.Types"><code>PinCFlow.Types</code></a></p></li><li><p><a href="../boundaries/#PinCFlow.Boundaries"><code>PinCFlow.Boundaries</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation"><code>PinCFlow.MSGWaM.Interpolation</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.RayUpdate"><code>PinCFlow.MSGWaM.RayUpdate</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.UChi" href="#PinCFlow.MSGWaM.MeanFlowEffect.UChi"><code>PinCFlow.MSGWaM.MeanFlowEffect.UChi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UChi</code></pre><p>Singleton for dispatch to calculation of zonal gravity-wave-tracer fluxes.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.VChi" href="#PinCFlow.MSGWaM.MeanFlowEffect.VChi"><code>PinCFlow.MSGWaM.MeanFlowEffect.VChi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VChi</code></pre><p>Singleton for dispatch to calculation of meridional gravity-wave-tracer fluxes.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.WChi" href="#PinCFlow.MSGWaM.MeanFlowEffect.WChi"><code>PinCFlow.MSGWaM.MeanFlowEffect.WChi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WChi</code></pre><p>Singleton for dispatch to calculation of vertical gravity-wave-tracer fluxes.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!" href="#PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!"><code>PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_blocked_layer_scheme!(state::State)</code></pre><p>Compute the blocked-flow drag and adjust the mean-flow impact accordingly.</p><p>The blocked-flow drag is given by</p><p class="math-container">\[\left(\frac{\partial \boldsymbol{u}_\mathrm{b}}{\partial t}\right)_\mathrm{B} = - D \frac{\left|\boldsymbol{k}_h\right| \left|\boldsymbol{u}_\mathrm{p}\right|}{2 \pi} \boldsymbol{u}_\mathrm{p},\]</p><p>where <span>$\boldsymbol{u}_\mathrm{b} = \left(u_\mathrm{b}, v_\mathrm{b}, 0\right)^\mathrm{T}$</span> is the resolved horizontal wind, <span>$D$</span> is a dimensionless drag coefficient (represented by <code>state.namelists.wkb.drag_coefficient</code>),</p><p class="math-container">\[\boldsymbol{k}_h = \frac{\sum_\alpha \left|h_{\mathrm{w}, \alpha}\right| \boldsymbol{k}_{h, \alpha}}{\sum_\alpha \left|h_{\mathrm{w}, \alpha}\right|}\]</p><p>is a weighted average of the orography&#39;s wavevectors <span>$\boldsymbol{k}_{h, \alpha}$</span> (with <span>$h_{\mathrm{w}, \alpha}$</span> being the corresponding spectral modes) and</p><p class="math-container">\[\boldsymbol{u}_\mathrm{p} = \frac{\left(\boldsymbol{u}_\mathrm{b} \cdot \boldsymbol{k}_h\right) \boldsymbol{k}_h}{\left|\boldsymbol{k}_h\right|^2}\]</p><p>is the projection of <span>$\boldsymbol{u}_\mathrm{b}$</span> onto <span>$\boldsymbol{k}_h$</span>. This drag replaces the drag due to gravity waves below <span>$z_\mathrm{B}$</span>, the upper edge of the blocked layer that has been determined by <a href="#PinCFlow.MSGWaM.RaySources.activate_orographic_source!"><code>PinCFlow.MSGWaM.RaySources.activate_orographic_source!</code></a>. In grid cells that contain this upper edge, blocking and gravity waves both contribute to the total drag, weighted by the corresponding grid-cell fractions. The gravity-wave heating is treated similarly, with the &quot;blocking contribution&quot; being zero.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: Model state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!" href="#PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!"><code>PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_shapiro_filter!(
    output::AbstractVector{&lt;:AbstractFloat},
    input::AbstractVector{&lt;:AbstractFloat},
    scope::UnitRange{&lt;:Integer},
    order::Val{1},
)</code></pre><p>Apply the first-order Shapiro filter to <code>input</code>.</p><p>The elements of <code>output</code> are given by</p><p class="math-container">\[\widetilde{\phi}_i = \frac{1}{4} \left(\phi_{i - 1} + 2 \phi_i + \phi_{i + 1}\right),\]</p><p>where <span>$\phi_i$</span> are the elements of <code>input</code>.</p><pre><code class="language-julia hljs">apply_shapiro_filter!(
    output::AbstractVector{&lt;:AbstractFloat},
    input::AbstractVector{&lt;:AbstractFloat},
    scope::UnitRange{&lt;:Integer},
    order::Val{2},
)</code></pre><p>Apply the second-order Shapiro filter to <code>input</code>.</p><p>The elements of <code>output</code> are given by</p><p class="math-container">\[\widetilde{\phi}_i = \frac{1}{16} \left(- \phi_{i - 2} + 4 \phi_{i - 1} + 10 \phi_i + 4 \phi_{i + 1} - \phi_{i + 2}\right),\]</p><p>where <span>$\phi_i$</span> are the elements of <code>input</code>.</p><pre><code class="language-julia hljs">apply_shapiro_filter!(
    output::AbstractVector{&lt;:AbstractFloat},
    input::AbstractVector{&lt;:AbstractFloat},
    scope::UnitRange{&lt;:Integer},
    order::Val{3},
)</code></pre><p>Apply the third-order Shapiro filter to <code>input</code>.</p><p>The elements of <code>output</code> are given by</p><p class="math-container">\[\widetilde{\phi}_i = \frac{1}{64} \left(\phi_{i - 3} - 6 \phi_{i - 2} + 15 \phi_{i - 1} + 44 \phi_i + 15 \phi_{i + 1} - 6 \phi_{i + 2} + \phi_{i + 3}\right),\]</p><p>where <span>$\phi_i$</span> are the elements of <code>input</code>.</p><pre><code class="language-julia hljs">apply_shapiro_filter!(
    output::AbstractVector{&lt;:AbstractFloat},
    input::AbstractVector{&lt;:AbstractFloat},
    scope::UnitRange{&lt;:Integer},
    order::Val{4},
)</code></pre><p>Apply the fourth-order Shapiro filter to <code>input</code>.</p><p>The elements of <code>output</code> are given by</p><p class="math-container">\[\widetilde{\phi}_i = \frac{1}{256} \left(- \phi_{i - 4} + 8 \phi_{i - 3} - 28 \phi_{i - 2} + 56 \phi_{i - 1} + 186 \phi_i + 56 \phi_{i + 1} - 28 \phi_{i + 2} + 8 \phi_{i + 3} - \phi_{i + 4}\right),\]</p><p>where <span>$\phi_i$</span> are the elements of <code>input</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>output</code>: Filtered output vector.</p></li><li><p><code>input</code>: Input vector.</p></li><li><p><code>scope</code>: Index range.</p></li><li><p><code>order</code>: Order of the Shapiro filter.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_gw_integrals!(state::State)</code></pre><p>Compute the gravity-wave integrals needed for the computation of the mean-flow impact by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">compute_gw_integrals!(state::State, wkb_mode::MultiColumn)</code></pre><p>Compute the gravity-wave integrals needed for the computation of the mean-flow impact in multi-column mode.</p><p>This method computes the sums</p><p class="math-container">\[\begin{align*}
    \overline{\rho} \left\langle u&#39; u&#39; \right\rangle &amp; = \overline{\rho} \sum_{r, \lambda, \mu, \nu} \left(F u_\mathrm{w} u_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho} \left\langle u&#39; v&#39; \right\rangle &amp; = \overline{\rho} \sum_{r, \lambda, \mu, \nu} \left(F u_\mathrm{w} v_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho} \left\langle u&#39; w&#39; \right\rangle &amp; = \overline{\rho} \sum_{r, \lambda, \mu, \nu} \left(F u_\mathrm{w} w_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho} \left\langle v&#39; v&#39; \right\rangle &amp; = \overline{\rho} \sum_{r, \lambda, \mu, \nu} \left(F v_\mathrm{w} v_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho} \left\langle v&#39; w&#39; \right\rangle &amp; = \overline{\rho} \sum_{r, \lambda, \mu, \nu} \left(F v_\mathrm{w} w_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \left\langle \theta&#39; u&#39; \right\rangle &amp; = \sum_{r, \lambda, \mu, \nu} \left(F \theta_\mathrm{w} u_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \left\langle \theta&#39; v&#39; \right\rangle &amp; = \sum_{r, \lambda, \mu, \nu} \left(F \theta_\mathrm{w} v_\mathrm{w}^*\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \mathcal{E} &amp; = \sum_{r, \lambda, \mu, \nu} \left(F \mathcal{A} \widehat{\omega}\right)_{r, i + \lambda, j + \mu, k + \nu}.
\end{align*}\]</p><p>Therein, <span>$\left(\lambda, \mu, \nu\right)$</span> are index shifts to ray volumes that are at least partially within the grid cell at <span>$\left(i, j, k\right)$</span>, <span>$F_{r, i + \lambda, j + \mu, k + \nu}$</span> are the corresponding ray volume fractions and <span>$\left(u_\mathrm{w}, v_\mathrm{w}, w_\mathrm{w}, \theta_\mathrm{w}\right)_{r, i + \lambda, j + \mu, k + \nu}$</span> are the wave amplitudes of the wind and the potential temperature. The computation is based on the relations</p><p class="math-container">\[\begin{align*}
    \overline{\rho} u_{\mathrm{w}, r} u_{\mathrm{w}, r}^* &amp; = \left(k_r \widehat{c}_{\mathrm{g} x, r} - \mathrm{sgn} \left(\left|f\right|\right) \frac{k_r \widehat{c}_{\mathrm{g} x, r} + l_r \widehat{c}_{\mathrm{g} y, r}}{1 - \left(\widehat{\omega}_r / f\right)^2}\right) \mathcal{A}_r,\\
    \overline{\rho} u_{\mathrm{w}, r} v_{\mathrm{w}, r}^* &amp; = l_r \widehat{c}_{\mathrm{g} x, r} \mathcal{A}_r,\\
    \overline{\rho} u_{\mathrm{w}, r} w_{\mathrm{w}, r}^* &amp; = \frac{k_r \widehat{c}_{\mathrm{g} z, r}}{1 - \left(f / \widehat{\omega}_r\right)^2} \mathcal{A}_r,\\
    \overline{\rho} v_{\mathrm{w}, r} v_{\mathrm{w}, r}^* &amp; = \left(l_r \widehat{c}_{\mathrm{g} y, r} - \mathrm{sgn} \left(\left|f\right|\right) \frac{k_r \widehat{c}_{\mathrm{g} x, r} + l_r \widehat{c}_{\mathrm{g} y, r}}{1 - \left(\widehat{\omega}_r / f\right)^2}\right) \mathcal{A}_r,\\
    \overline{\rho} v_{\mathrm{w}, r} w_{\mathrm{w}, r}^* &amp; = \frac{l_r \widehat{c}_{\mathrm{g} z, r}}{1 - \left(f / \widehat{\omega}_r\right)^2} \mathcal{A}_r,\\
    \theta_{\mathrm{w}, r} u_{\mathrm{w}, r}^* &amp; = \frac{f \overline{\theta}}{g \overline{\rho}} \frac{l_r m_r N_r^2}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2} \mathcal{A}_r,\\
    \theta_{\mathrm{w}, r} v_{\mathrm{w}, r}^* &amp; = - \frac{f \overline{\theta}}{g \overline{\rho}} \frac{k_r m_r N_r^2}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2} \mathcal{A}_r,
\end{align*}\]</p><p>where <span>$N_r^2$</span> is the squared buoyancy frequency interpolated to the ray-volume position. The components of the intrinsic group velocity are given by</p><p class="math-container">\[\begin{align*}
    \widehat{c}_{\mathrm{g} x, r} &amp; = \frac{k_r \left(N_r^2 - \widehat{\omega}_r^2\right)}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2},\\
    \widehat{c}_{\mathrm{g} y, r} &amp; = \frac{l_r \left(N_r^2 - \widehat{\omega}_r^2\right)}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2},\\
    \widehat{c}_{\mathrm{g} z, r} &amp; = - \frac{m_r \left(\widehat{\omega}_r^2 - f^2\right)}{\widehat{\omega}_r \left|\boldsymbol{k}_r\right|^2}.
\end{align*}\]</p><pre><code class="language-julia hljs">compute_gw_integrals!(state::State, wkb_mode::SingleColumn)</code></pre><p>Compute the gravity-wave integrals needed for the computation of the mean-flow impact in single-column mode.</p><p>This method computes <span>$\overline{\rho} \left\langle u&#39; w&#39; \right\rangle$</span>, <span>$\overline{\rho} \left\langle v&#39; w&#39; \right\rangle$</span>, <span>$\left\langle \theta&#39; u&#39; \right\rangle$</span>, <span>$\left\langle \theta&#39; v&#39; \right\rangle$</span> and <span>$\mathcal{E}$</span> (see above for details).</p><pre><code class="language-julia hljs">compute_gw_integrals!(state::State, wkb_mode::SteadyState)</code></pre><p>Compute the gravity-wave integrals needed for the computation of the mean-flow impact in steady-state mode.</p><p>This method computes the sums <span>$\overline{\rho} \left\langle u&#39; w&#39; \right\rangle$</span> and <span>$\overline{\rho} \left\langle v&#39; w&#39; \right\rangle$</span> (see above for details). In contrast to the multi-column and single-column modes, the steady-state mode uses the pseudo-momentum approximation</p><p class="math-container">\[\begin{align*}
    \overline{\rho} u_{\mathrm{w}, r} w_{\mathrm{w}, r}^* &amp; = k_r \widehat{c}_{\mathrm{g} z, r} \mathcal{A}_r,\\
    \overline{\rho} v_{\mathrm{w}, r} w_{\mathrm{w}, r}^* &amp; = l_r \widehat{c}_{\mathrm{g} z, r} \mathcal{A}_r.
\end{align*}\]</p><p><strong>Arguments</strong></p><ul><li><p><code>state::State</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.Interpolation.interpolate_stratification"><code>PinCFlow.MSGWaM.Interpolation.interpolate_stratification</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.Interpolation.get_next_half_level"><code>PinCFlow.MSGWaM.Interpolation.get_next_half_level</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_gw_tendencies!(state::State)</code></pre><p>Compute the gravity-wave impact on the momentum and mass-weighted potential temperature.</p><p>Calculates the tendencies that are to be added to the equations for momentum and mass-weighted potential temperature. These are given by</p><p class="math-container">\[\begin{align*}
    \left(\frac{\partial \rho_\mathrm{b} u_\mathrm{b}}{\partial t}\right)_\mathrm{w} &amp; = - \frac{\rho_\mathrm{b}}{\overline{\rho}} \left[\frac{\left(\overline{\rho} \left\langle u&#39; u&#39; \right\rangle\right)_{i + 1} - \left(\overline{\rho} \left\langle u&#39; u&#39; \right\rangle\right)_{i - 1}}{2 \Delta \widehat{x}} + G^{13} \frac{\left(\overline{\rho} \left\langle u&#39; u&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle u&#39; u&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\right.\\
    &amp; \qquad \qquad + \frac{\left(\overline{\rho} \left\langle u&#39; v&#39; \right\rangle\right)_{j + 1} - \left(\overline{\rho} \left\langle u&#39; v&#39; \right\rangle\right)_{j - 1}}{2 \Delta \widehat{y}} + G^{23} \frac{\left(\overline{\rho} \left\langle u&#39; v&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle u&#39; v&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\\
    &amp; \qquad \qquad + \left.\frac{\left(\overline{\rho} \left\langle u&#39; w&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle u&#39; w&#39; \right\rangle\right)_{k - 1}}{2 J \Delta \widehat{z}}\right] - \rho_\mathrm{b} \frac{f}{\overline{\theta}} \left\langle \theta&#39; v&#39; \right\rangle,\\
    \left(\frac{\partial \rho_\mathrm{b} v_\mathrm{b}}{\partial t}\right)_\mathrm{w} &amp; = - \frac{\rho_\mathrm{b}}{\overline{\rho}} \left[\frac{\left(\overline{\rho} \left\langle v&#39; u&#39; \right\rangle\right)_{i + 1} - \left(\overline{\rho} \left\langle v&#39; u&#39; \right\rangle\right)_{i - 1}}{2 \Delta \widehat{x}} + G^{13} \frac{\left(\overline{\rho} \left\langle v&#39; u&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle v&#39; u&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\right.\\
    &amp; \qquad \qquad + \frac{\left(\overline{\rho} \left\langle v&#39; v&#39; \right\rangle\right)_{j + 1} - \left(\overline{\rho} \left\langle v&#39; v&#39; \right\rangle\right)_{j - 1}}{2 \Delta \widehat{y}} + G^{23} \frac{\left(\overline{\rho} \left\langle v&#39; v&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle v&#39; v&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\\
    &amp; \qquad \qquad + \left.\frac{\left(\overline{\rho} \left\langle v&#39; w&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle v&#39; w&#39; \right\rangle\right)_{k - 1}}{2 J \Delta \widehat{z}}\right] + \rho_\mathrm{b} \frac{f}{\overline{\theta}} \left\langle \theta&#39; u&#39; \right\rangle,\\
    \left(\frac{\partial \rho_\mathrm{b} \widehat{w}_\mathrm{b}}{\partial t}\right)_\mathrm{w} &amp; = G^{13} \left(\frac{\partial \rho_\mathrm{b} u_\mathrm{b}}{\partial t}\right)_\mathrm{w} + G^{23} \left(\frac{\partial \rho_\mathrm{b} v_\mathrm{b}}{\partial t}\right)_\mathrm{w},\\
    \left(\frac{\partial P_\mathrm{b}}{\partial t}\right)_\mathrm{w} &amp; = - \rho_\mathrm{b} \left[\frac{\left(\overline{\rho} \left\langle \theta&#39; u&#39; \right\rangle\right)_{i + 1} - \left(\overline{\rho} \left\langle \theta&#39; u&#39; \right\rangle\right)_{i - 1}}{2 \Delta \widehat{x}} + G^{13} \frac{\left(\overline{\rho} \left\langle \theta&#39; u&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle \theta&#39; u&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\right.\\
    &amp; \qquad \qquad + \left.\frac{\left(\overline{\rho} \left\langle \theta&#39; v&#39; \right\rangle\right)_{j + 1} - \left(\overline{\rho} \left\langle \theta&#39; v&#39; \right\rangle\right)_{j - 1}}{2 \Delta \widehat{y}} + G^{23} \frac{\left(\overline{\rho} \left\langle \theta&#39; v&#39; \right\rangle\right)_{k + 1} - \left(\overline{\rho} \left\langle \theta&#39; v&#39; \right\rangle\right)_{k - 1}}{2 \Delta \widehat{z}}\right],
\end{align*}\]</p><p>where <span>$\left(u_\mathrm{b}, v_\mathrm{b}, \widehat{w}_\mathrm{b}\right)$</span> are the components of the transformed (i.e. terrain-following) resolved wind, <span>$\rho_\mathrm{b}$</span> is the resolved density (including the reference part <span>$\overline{\rho}$</span>) and <span>$P_\mathrm{b}$</span> is the resolved mass-weighted potential temperature. For a documentation of the fluxes, see <a href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!</code></a>. Below <code>state.namelists.wkb.impact_altitude</code>, all tendencies are set to zero.</p><p><strong>Arguments</strong></p><ul><li><code>state::State</code>: Model state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_horizontal_cell_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_horizontal_cell_indices(
    state::State,
    xr::AbstractFloat,
    yr::AbstractFloat,
    dxr::AbstractFloat,
    dyr::AbstractFloat,
)::NTuple{4, &lt;:Integer}</code></pre><p>From the given horizontal ray-volume position and extent, determine the indices of the grid cells that contain the ray-volume edges and return them (in the order left, right, backward and forward).</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>xr</code>: Ray-volume position in <span>$x$</span>.</p></li><li><p><code>yr</code>: Ray-volume position in <span>$y$</span>.</p></li><li><p><code>dxr</code>: Ray-volume extent in <span>$x$</span>.</p></li><li><p><code>dyr</code>: Ray-volume extent in <span>$y$</span>.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_fluxes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_leading_order_tracer_fluxes!(
    state::State,
    tracer_setup::NoTracer,
    fc::AbstractFloat,
    omir::AbstractFloat,
    wnrk::AbstractFloat,
    wnrl::AbstractFloat,
    wnrm::AbstractFloat,
    wadr::AbstractFloat,
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    i::Integer,
    j::Integer,
    k::Integer,
)</code></pre><p>Return for configurations without tracer transport.</p><pre><code class="language-julia hljs">compute_leading_order_tracer_fluxes!(
    state::State,
    tracer_setup::TracerOn,
    fc::AbstractFloat,
    omir::AbstractFloat,
    wnrk::AbstractFloat,
    wnrl::AbstractFloat,
    wnrm::AbstractFloat,
    wadr::AbstractFloat,
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    i::Integer,
    j::Integer,
    k::Integer,
)</code></pre><p>Compute the leading-order gravity-wave tracer fluxes at <span>$(i, j, k)$</span>.</p><p>The zonal, meridional, and vertical fluxes are given by</p><p class="math-container">\[\begin{align*}
    \overline{\rho}\left\langle u&#39; \chi&#39;\right\rangle &amp; = \overline{\rho}\sum_{r, \lambda,\mu,\nu}\left(F u_\mathrm{w}\chi^*_\mathrm{w}\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho}\left\langle v&#39; \chi&#39;\right\rangle &amp; = \overline{\rho}\sum_{r,  \lambda, \mu, \nu} \left(F v_\mathrm{w} \chi^*_\mathrm{w}\right)_{r, i + \lambda, j + \mu, k + \nu},\\
    \overline{\rho}\left\langle w&#39; \chi&#39;\right\rangle &amp; = \overline{\rho}\sum_{r, \lambda, \mu, \nu} \left(F w_\mathrm{w} \chi^*_\mathrm{w}\right)_{r, i + \lambda, j + \mu, k + \nu}.
\end{align*}\]</p><p><strong>Arguments:</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>tracer_setup</code>:  General tracer-transport configuration.</p></li><li><p><code>fc</code>: Coriolis parameter.</p></li><li><p><code>omir</code>: Gravity-wave intrinsic frequency.</p></li><li><p><code>wnrk</code>: Zonal wavenumber.</p></li><li><p><code>wnrl</code>: Meridional wavenumber.</p></li><li><p><code>wnrm</code>: Vertical wavenumber.</p></li><li><p><code>wadr</code>: Phase-space wave-action density.</p></li><li><p><code>xlc</code>: Zonal location of the ray-volume.</p></li><li><p><code>ylc</code>: Meridional location of the ray-volume.</p></li><li><p><code>zlc</code>: Vertical location of the ray-volume.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li></ul><p><strong>See also:</strong></p><ul><li><a href="#PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes"><code>PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!-Tuple{State, Integer, Integer, Integer, TracerOn}" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!-Tuple{State, Integer, Integer, Integer, TracerOn}"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_leading_order_tracer_forcing!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_leading_order_tracer_forcing!(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    tracer_setup::TracerOn,
)</code></pre><p>Compute and return the leading-order tracer forcing at <span>$\left(i, j, k\right)$</span>.</p><pre><code class="language-julia hljs">compute_leading_order_tracer_forcing!(
    state::State,
    i::Integer,
    j::Integer,
    k::Integer,
    tracer_setup::NoTracer,
)</code></pre><p>Return for configurations without tracer transport.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>i</code>: Zonal grid-cell index.</p></li><li><p><code>j</code>: Meridional grid-cell index.</p></li><li><p><code>k</code>: Vertical grid-cell index.</p></li><li><p><code>tracer_setup</code>: General tracer-transport configuration.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!" href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_mean_flow_effect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_mean_flow_effect!(state::State)</code></pre><p>Calculate the mean-flow impact of unresolved gravity waves by dispatching to a WKB-mode-specific method.</p><pre><code class="language-julia hljs">compute_mean_flow_effect!(state::State, wkb_mode::NoWKB)</code></pre><p>Return for non-WKB configurations.</p><pre><code class="language-julia hljs">compute_mean_flow_effect!(
    state::State,
    wkb_mode::Union{SteadyState, SingleColumn, MultiColumn},
)</code></pre><p>Calculate the mean-flow impact of unresolved gravity waves.</p><p>This method first computes several spectral integrals (using <code>compute_gw_integrals!</code>), most of which represent gravity-wave fluxes. After the boundary conditions for these have been enforced (using <code>set_boundaries!</code>), the corresponding tendencies are calculated (using <code>compute_gw_tendencies!</code>). These also have boundary conditions that need to be enforced (once again using <code>set_boundaries!</code>) before they are smoothed to remove small-scale features that may occur due to a coarse ray-volume distribution (using <code>smooth_gw_tendencies!</code>). Afterwards, if MS-GWaM parameterizes mountain waves, the tendencies are adjusted to account for the formation of blocked layers (using <code>apply_blocked_layer_scheme!</code>), before the boundary conditions are enforced again.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>wkb_mode</code>: Approximations used by MS-GWaM.</p></li></ul><p><strong>See also</strong></p><ul><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_integrals!</code></a></p></li><li><p><a href="../boundaries/#PinCFlow.Boundaries.set_boundaries!"><code>PinCFlow.Boundaries.set_boundaries!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!"><code>PinCFlow.MSGWaM.MeanFlowEffect.compute_gw_tendencies!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!"><code>PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!</code></a></p></li><li><p><a href="#PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!"><code>PinCFlow.MSGWaM.MeanFlowEffect.apply_blocked_layer_scheme!</code></a></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes" href="#PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes"><code>PinCFlow.MSGWaM.MeanFlowEffect.leading_order_tracer_fluxes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leading_order_tracer_fluxes(
    state::State,
    fc::AbstractFloat,
    omir::AbstractFloat,
    wnrk::AbstractFloat,
    wnrl::AbstractFloat,
    wnrm::AbstractFloat,
    wadr::AbstractFloat,
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    direction::UChi,
)::AbstractFloat</code></pre><p>Compute and return the contribution of a ray volume located at <code>(xlc,ylc,zlc)</code> to the zonal leading-order gravity-wave tracer fluxes <span>$\overline{\rho}\langle u&#39;\chi&#39;\rangle$</span>.</p><p>The flux-contributions are given by</p><p class="math-container">\[\overline{\rho} u_{\mathrm{w}, r}\chi^*_{\mathrm{w}, r} = \frac{f}{\widehat{\omega}_r} \frac{m_r}{\left|\boldsymbol{k}_r\right|^2} \mathcal{A}_r \left[l_r \left(\frac{\partial \chi_\mathrm{b}}{\partial z}\right)_r - m_r \left(\frac{\partial \chi_\mathrm{b}}{\partial y}\right)_r\right].\]</p><pre><code class="language-julia hljs">leading_order_tracer_fluxes(
    state::State,
    fc::AbstractFloat,
    omir::AbstractFloat,
    wnrk::AbstractFloat,
    wnrl::AbstractFloat,
    wnrm::AbstractFloat,
    wadr::AbstractFloat,
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    direction::VChi,
)::AbstractFloat</code></pre><p>Compute and return the contribution of a ray volume located at <code>(xlc,ylc,zlc)</code> to the meridional leading-order gravity-wave tracer fluxes <span>$\overline{\rho}\langle v&#39;\chi&#39;\rangle$</span>.</p><p>The fluxes are given by</p><p class="math-container">\[\overline{\rho} v_{\mathrm{w}, r} \chi^*_{\mathrm{w}, r} = \frac{f}{\widehat{\omega}_{r}} \frac{m_r}{\left|\boldsymbol{k}_{r}\right|^2} \mathcal{A}_r \left[m_r \left(\frac{\partial \chi_\mathrm{b}}{\partial x}\right)_r - k_r \left(\frac{\partial \chi_\mathrm{b}}{\partial z}\right)_r\right].\]</p><pre><code class="language-julia hljs">leading_order_tracer_fluxes(
    state::State,
    fc::AbstractFloat,
    omir::AbstractFloat,
    wnrk::AbstractFloat,
    wnrl::AbstractFloat,
    wnrm::AbstractFloat,
    wadr::AbstractFloat,
    xlc::AbstractFloat,
    ylc::AbstractFloat,
    zlc::AbstractFloat,
    direction::WChi,
)::AbstractFloat</code></pre><p>Compute and return the contribution of a ray volume located at <code>(xlc,ylc,zlc)</code> to the vertical leading-order gravity-wave tracer fluxes <span>$\overline{\rho}\langle w&#39;\chi&#39;\rangle$</span>.</p><p>The fluxes are given by</p><p class="math-container">\[\overline{\rho} w_{\mathrm{w}, r} \chi^*_{\mathrm{w}, r} = \frac{f}{\widehat{\omega}_r} \frac{m_r}{\left|\boldsymbol{k}_r\right|^2} \mathcal{A}_r \left[k_r \left(\frac{\partial \chi_\mathrm{b}}{\partial y}\right)_r - l_r \left(\frac{\partial \chi_\mathrm{b}}{\partial x}\right)_r\right].\]</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!" href="#PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!"><code>PinCFlow.MSGWaM.MeanFlowEffect.set_tracer_field_zero!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_tracer_field_zero!(state)</code></pre><p>Reset the gravity-wave-induced tracer fluxes to zero by dispatching over tracer configurations.</p><pre><code class="language-julia hljs">set_tracer_field_zero!(state::State, tracer_setup::NoTracer)</code></pre><p>Return for configurations without tracer transport.</p><pre><code class="language-julia hljs">set_tracer_field_zero!(state::State, tracer_setup::TracerOn)</code></pre><p>Set the gravity-wave-induced tracer fluxes to zero.</p><p><strong>Arguments:</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>tracer_setup</code>: General tracer-transport configuration.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!" href="#PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!"><code>PinCFlow.MSGWaM.MeanFlowEffect.smooth_gw_tendencies!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth_gw_tendencies!(state::State)</code></pre><p>Apply spatial smoothing to gravity-wave tendency fields by dispatching to a method specific for the chosen filter (<code>state.namelists.wkb.filter_type</code>) and dimensionality of the domain.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Box,
    direction::XYZ,
)</code></pre><p>Apply a 3D box filter to smooth in all spatial directions.</p><p>Applies the moving average</p><p class="math-container">\[\widetilde{\phi}_{i, j, k} = \left(2 N_\mathrm{s} + 1\right)^{- 3} \sum\limits_{\lambda = i - N_\mathrm{s}}^{i + N_\mathrm{s}} \sum\limits_{\mu = j - N_\mathrm{s}}^{j + N_\mathrm{s}} \sum\limits_{\nu = k - N_\mathrm{s}}^{k + N_\mathrm{s}} \phi_{\lambda, \mu, \nu},\]</p><p>where <span>$N_\mathrm{s}$</span> is the order of the filter (<code>state.namelists.wkb.filter_order</code>).</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Box,
    direction::XZ,
)</code></pre><p>Apply a 2D box filter to smooth in <span>$\widehat{x}$</span> and <span>$\widehat{z}$</span>.</p><p>Applies the moving average</p><p class="math-container">\[\widetilde{\phi}_{i, j, k} = \left(2 N_\mathrm{s} + 1\right)^{- 2} \sum\limits_{\lambda = i - N_\mathrm{s}}^{i + N_\mathrm{s}} \sum\limits_{\nu = k - N_\mathrm{s}}^{k + N_\mathrm{s}} \phi_{\lambda, j, \nu},\]</p><p>where <span>$N_\mathrm{s}$</span> is the order of the filter (<code>state.namelists.wkb.filter_order</code>).</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Box,
    direction::YZ,
)</code></pre><p>Apply a 2D box filter to smooth in <span>$\widehat{y}$</span> and <span>$\widehat{z}$</span>.</p><p>Applies the moving average</p><p class="math-container">\[\widetilde{\phi}_{i, j, k} = \left(2 N_\mathrm{s} + 1\right)^{- 2} \sum\limits_{\mu = j - N_\mathrm{s}}^{j + N_\mathrm{s}} \sum\limits_{\nu = k - N_\mathrm{s}}^{k + N_\mathrm{s}} \phi_{i, \mu, \nu},\]</p><p>where <span>$N_\mathrm{s}$</span> is the order of the filter (<code>state.namelists.wkb.filter_order</code>).</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Box,
    direction::Z,
)</code></pre><p>Apply a 1D box filter to smooth in <span>$\widehat{z}$</span>.</p><p>Applies the moving average</p><p class="math-container">\[\widetilde{\phi}_{i, j, k} = \left(2 N_\mathrm{s} + 1\right)^{- 1} \sum\limits_{\nu = k - N_\mathrm{s}}^{k + N_\mathrm{s}} \phi_{i, j, \nu},\]</p><p>where <span>$N_\mathrm{s}$</span> is the order of the filter (<code>state.namelists.wkb.filter_order</code>).</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::XYZ,
)</code></pre><p>Apply a 3D Shapiro filter to smooth in all spatial directions.</p><p>A 1D Shapiro filter is applied sequentially in <span>$\widehat{x}$</span>, <span>$\widehat{y}$</span> and <span>$\widehat{z}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::XZ,
)</code></pre><p>Apply a 2D Shapiro filter to smooth in <span>$\widehat{x}$</span> and <span>$\widehat{z}$</span>.</p><p>A 1D Shapiro filter is applied sequentially in <span>$\widehat{x}$</span> and <span>$\widehat{z}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::YZ,
)</code></pre><p>Apply a 2D Shapiro filter to smooth in <span>$\widehat{y}$</span> and <span>$\widehat{z}$</span>.</p><p>A 1D Shapiro filter is applied sequentially in <span>$\widehat{y}$</span> and <span>$\widehat{z}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::Z,
)</code></pre><p>Apply a 1D Shapiro filter to smooth in <span>$\widehat{z}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::Y,
)</code></pre><p>Apply a 1D Shapiro filter to smooth in <span>$\widehat{y}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(
    output::AbstractArray{&lt;:AbstractFloat, 3},
    state::State,
    filter_type::Shapiro,
    direction::X,
)</code></pre><p>Apply a 1D Shapiro filter to smooth in <span>$\widehat{x}$</span>.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(state::State, tracer_setup::TracerOn)</code></pre><p>Apply smoothing to tracer tendencies.</p><pre><code class="language-julia hljs">smooth_gw_tendencies!(state::State, tracer_setup::NoTracer)</code></pre><p>Return for configurations without tracer transport.</p><p><strong>Arguments</strong></p><ul><li><p><code>state</code>: Model state.</p></li><li><p><code>output</code>: Field to smooth.</p></li><li><p><code>filter_type</code>: Filter type.</p></li><li><p><code>direction</code>: Directions to smooth in.</p></li><li><p><code>tracer_setup</code>: General tracer-transport configuration.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!"><code>PinCFlow.MSGWaM.MeanFlowEffect.apply_shapiro_filter!</code></a></li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../update/">« Update</a><a class="docs-footer-nextpage" href="../integration/">Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 29 October 2025 16:49">Wednesday 29 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
